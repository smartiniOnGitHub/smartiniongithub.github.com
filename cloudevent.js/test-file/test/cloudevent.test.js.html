<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">test/cloudevent.test.js | cloudevent</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="JavaScript/Node.js implementation of the CloudEvents standard format"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="cloudevent"><meta property="twitter:description" content="JavaScript/Node.js implementation of the CloudEvents standard format"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  <a href="test.html" data-ice="testLink">Test</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/smartiniOnGitHub/cloudevent.js"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/cloudevent.js~CloudEvent.html">CloudEvent</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/transformer.js~Transformer.html">Transformer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/validator.js~Validator.html">Validator</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">test/cloudevent.test.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">/*
 * Copyright 2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
&apos;use strict&apos;

const assert = require(&apos;assert&apos;)
const test = require(&apos;tap&apos;).test

/** create some common options, for better reuse in tests */
const ceCommonOptions = {
  time: new Date(),
  extensions: { &apos;exampleExtension&apos;: &apos;value&apos; },
  contenttype: &apos;application/json&apos;,
  schemaurl: &apos;http://my-schema.localhost.localdomain&apos;,
  strict: false
}
/** create some common options with strict flag enabled, for better reuse in tests */
const ceCommonOptionsStrict = { ...ceCommonOptions, strict: true }
/** create a sample namespace for events here, for better reuse in tests */
const ceNamespace = &apos;com.github.smartiniOnGitHub.cloudeventjs.testevent&apos;
/** create a sample common server URL, for better reuse in tests */
const ceServerUrl = &apos;/test&apos;
/** create some common data from an object, for better reuse in tests */
const ceCommonData = { &apos;hello&apos;: &apos;world&apos;, year: 2019 }
/** create some common data from a Map, for better reuse in tests */
const ceMapData = new Map() // empty Map
// const ceMapData = new Map([[&apos;key-1&apos;, &apos;value 1&apos;], [&apos;key-2&apos;, &apos;value 2&apos;]])
ceMapData.set(&apos;key-1&apos;, &apos;value 1&apos;)
ceMapData.set(&apos;key-2&apos;, &apos;value 2&apos;)

/** @test {CloudEvent} */
test(&apos;ensure CloudEvent class (and related Validator and Transformer classes) are exported by the library&apos;, (t) =&gt; {
  t.plan(13)

  {
    const { CloudEvent, CloudEventValidator: V, CloudEventTransformer: T } = require(&apos;../src/&apos;) // get references via destructuring
    t.ok(CloudEvent)
    // optional, using some standard Node.js assert statements, as a sample
    assert(CloudEvent !== null)
    assert.strictEqual(typeof CloudEvent, &apos;function&apos;)
    assert(new CloudEvent() instanceof CloudEvent)
    assert.strictEqual(CloudEvent.mediaType(), &apos;application/cloudevents+json&apos;)
    t.ok(V)
    t.strictEqual(typeof CloudEvent, &apos;function&apos;)
    t.strictEqual(typeof V, &apos;function&apos;)
    t.strictEqual(typeof T, &apos;function&apos;)
    t.ok(V.isFunction(CloudEvent))
    t.ok(V.isFunction(V))
    t.strictEqual(typeof CloudEvent, &apos;function&apos;)
    t.strictEqual(new CloudEvent() instanceof CloudEvent, true)
    t.strictEqual(CloudEvent.mediaType(), &apos;application/cloudevents+json&apos;)

    // create an instance with only mandatory arguments (no strict mode, but doesn&apos;t matter in this case): expected success ...
    const ceMinimal = new CloudEvent(&apos;1&apos;, // id
      ceNamespace, // type
      &apos;/&apos;, // source
      {} // data (empty) // optional, but useful the same in this sample usage
    )
    t.ok(ceMinimal)
    // console.log(`DEBUG - cloudEvent details: ceMinimal = ${JSON.stringify(ceMinimal)}`)
    // console.log(`DEBUG - cloudEvent details: ${T.dumpObject(ceMinimal, &apos;ceMinimal&apos;)}`)

    // check that created instances belongs to the right base class
    t.strictEqual(typeof ceMinimal, &apos;object&apos;)
    t.ok(V.isClass(ceMinimal, CloudEvent))
  }
})

/** @test {CloudEvent} */
test(&apos;ensure isValid and validate works good on undefined and null objects&apos;, (t) =&gt; {
  t.plan(7)
  const { CloudEvent } = require(&apos;../src/&apos;)
  t.ok(CloudEvent)

  // undefined
  t.notOk()
  t.notOk(CloudEvent.isValidEvent())
  t.strictSame(CloudEvent.validateEvent(), [new Error(&apos;CloudEvent undefined or null&apos;)])

  // null
  t.notOk(null)
  t.notOk(CloudEvent.isValidEvent(null))
  t.strictSame(CloudEvent.validateEvent(null), [new Error(&apos;CloudEvent undefined or null&apos;)])
})

/** @test {CloudEvent} */
test(&apos;create some CloudEvent instances (empty, without minimal arguments set or not set) and ensure they are different objects&apos;, (t) =&gt; {
  t.plan(12)
  const { CloudEvent } = require(&apos;../src/&apos;)
  t.ok(CloudEvent)

  {
    // create an instance without mandatory arguments (but no strict mode): expected success ...
    const ceEmpty = new CloudEvent()
    t.ok(ceEmpty)
    t.ok(!CloudEvent.isValidEvent(ceEmpty))
    // t.strictSame(CloudEvent.validateEvent(ceEmpty), []) // temp, to see the error during development ...
    t.strictSame(CloudEvent.validateEvent(ceEmpty).length, 3) // simplify comparison of results, check only the  number of expected errors ...
    // the same but using normal instance methods, to ensure they works good ...
    t.ok(!ceEmpty.isValid())
    t.strictSame(ceEmpty.validate(ceEmpty).length, 3) // simplify comparison of results, check only the  number of expected errors ...
    t.ok(!ceEmpty.isStrict)
  }

  {
    // create an instance without mandatory arguments (but with strict mode): expected failure ...
    let ceEmpty2 = null
    try {
      ceEmpty2 = new CloudEvent(undefined, undefined, undefined, undefined, { strict: true })
      assert(ceEmpty2 === null) // never executed
    } catch (e) {
      t.ok(e) // expected error here
      t.ok(!CloudEvent.isValidEvent(ceEmpty2))
      t.strictSame(CloudEvent.validateEvent(ceEmpty2), [new Error(&apos;CloudEvent undefined or null&apos;)])
      // the same but using normal instance methods, to ensure they works good ... no because here instance is null
    }
    t.equal(ceEmpty2, null)
    // the same test, but in a shorter form ...
    t.throws(function () {
      const ce = new CloudEvent(undefined, undefined, undefined, undefined, { strict: true })
      assert(ce === null) // never executed
    }, Error, &apos;Expected exception when creating a CloudEvent without mandatory arguments with strict flag enabled&apos;)
  }
})

/** @test {CloudEvent} */
test(&apos;create some CloudEvent instances (with minimal fields set) and ensure they are different objects&apos;, (t) =&gt; {
  t.plan(41)
  const { CloudEvent } = require(&apos;../src/&apos;)
  t.ok(CloudEvent)

  // t.notSame(CloudEvent.isValidEvent, CloudEvent.validateEvent)
  t.strictNotSame(CloudEvent.isValidEvent, CloudEvent.validateEvent)

  {
    // create an instance with only mandatory arguments (no strict mode, but doesn&apos;t matter in this case): expected success ...
    const ceMinimal = new CloudEvent(&apos;1&apos;, // id
      ceNamespace, // type
      &apos;/&apos;, // source
      {} // data (empty) // optional, but useful the same in this sample usage
    )
    t.ok(ceMinimal)
    // console.log(`DEBUG - cloudEvent details: ceMinimal = ${JSON.stringify(ceMinimal)}`)
    // console.log(`DEBUG - cloudEvent details: ${T.dumpObject(ceMinimal, &apos;ceMinimal&apos;)}`)
    // console.log(`DEBUG - cloudEvent details: ${ceMinimal}`) // implicit call of its toString method ...
    t.ok(CloudEvent.isValidEvent(ceMinimal))
    t.strictSame(CloudEvent.validateEvent(ceMinimal), [])
    // t.strictSame(CloudEvent.validateEvent(ceEmpty), []) // temp, to see the error during development ...
    t.strictSame(CloudEvent.validateEvent(ceMinimal).length, 0) // simplify comparison of results, check only the  number of expected errors ...
    // create another instance, similar
    // the same but using normal instance methods, to ensure they works good ...
    t.ok(ceMinimal.isValid())
    t.strictSame(ceMinimal.validate(), [])
    t.strictSame(ceMinimal.validate().length, 0) // simplify comparison of results, check only the  number of expected errors ...
    t.ok(!ceMinimal.isStrict)
    const ceMinimal2 = new CloudEvent(&apos;2&apos;, // id
      ceNamespace, // type
      &apos;/&apos;, // source
      {} // data (empty) // optional, but useful the same in this sample usage
    )
    t.ok(ceMinimal2)
    t.ok(CloudEvent.isValidEvent(ceMinimal2)) // using default strict mode in the event
    t.ok(CloudEvent.isValidEvent(ceMinimal2, { strict: false })) // same of previous but using strict mode in validation options
    t.strictSame(CloudEvent.validateEvent(ceMinimal2), [])
    t.strictSame(CloudEvent.validateEvent(ceMinimal2).length, 0)
    // the same but using normal instance methods, to ensure they works good ...
    t.ok(ceMinimal2.isValid()) // using default strict mode in the event
    t.ok(ceMinimal2.isValid({ strict: false })) // same of previous but using strict mode in validation options
    t.strictSame(ceMinimal2.validate(), [])
    t.strictSame(ceMinimal2.validate().length, 0)
    // then ensure they are different (have different values inside) ...
    assert(ceMinimal !== ceMinimal2) // they must be different object references
    t.notSame(ceMinimal, ceMinimal2)
    t.strictNotSame(ceMinimal, ceMinimal2)
  }

  {
    // create an instance with a mandatory argument undefined (but no strict mode): expected success ...
    // note that undefined arguments will be handled by default arguments, so all will be good the same here ...
    const ceMinimalMandatoryUndefinedNoStrict = new CloudEvent(undefined, undefined, undefined, undefined, { strict: false })
    assert(ceMinimalMandatoryUndefinedNoStrict !== null)
    t.ok(ceMinimalMandatoryUndefinedNoStrict)
    t.ok(!CloudEvent.isValidEvent(ceMinimalMandatoryUndefinedNoStrict)) // using default strict mode in the event
    t.ok(!CloudEvent.isValidEvent(ceMinimalMandatoryUndefinedNoStrict, { strict: false })) // same of previous but using strict mode in validation options
    t.strictSame(CloudEvent.validateEvent(ceMinimalMandatoryUndefinedNoStrict, { strict: false }).length, 3)
    t.ok(!CloudEvent.isValidEvent(ceMinimalMandatoryUndefinedNoStrict, { strict: true })) // the same but validate with strict mode enabled ...
    // the same but using normal instance methods, to ensure they works good ...
    t.ok(!ceMinimalMandatoryUndefinedNoStrict.isValid()) // using default strict mode in the event
    t.ok(!ceMinimalMandatoryUndefinedNoStrict.isValid({ strict: false })) // same of previous but using strict mode in validation options
    t.strictSame(ceMinimalMandatoryUndefinedNoStrict.validate({ strict: false }).length, 3)
    t.ok(!ceMinimalMandatoryUndefinedNoStrict.isValid({ strict: true })) // the same but validate with strict mode enabled ...

    // the same but with strict mode: expected exception ...
    t.throws(function () {
      const ceMinimalMandatoryUndefinedStrict = new CloudEvent(undefined, undefined, undefined, undefined, { strict: true })
      assert(ceMinimalMandatoryUndefinedStrict === null) // never executed
    }, Error, &apos;Expected exception when creating a CloudEvent without mandatory arguments with strict flag enabled&apos;)
  }

  {
    // create an instance with a mandatory argument null (but no strict mode): expected success ...
    // note that undefined arguments will be handled by default arguments, so all will be good the same here ...
    const ceMinimalMandatoryNullNoStrict = new CloudEvent(null, null, null, null, { strict: false })
    assert(ceMinimalMandatoryNullNoStrict !== null)
    t.ok(ceMinimalMandatoryNullNoStrict)
    t.ok(!CloudEvent.isValidEvent(ceMinimalMandatoryNullNoStrict)) // using default strict mode in the event
    t.ok(!CloudEvent.isValidEvent(ceMinimalMandatoryNullNoStrict, { strict: false })) // same of previous but using strict mode in validation options
    t.strictSame(CloudEvent.validateEvent(ceMinimalMandatoryNullNoStrict, { strict: false }).length, 3)
    t.ok(!CloudEvent.isValidEvent(ceMinimalMandatoryNullNoStrict, { strict: true })) // the same but validate with strict mode enabled ...
    // the same but using normal instance methods, to ensure they works good ...
    t.ok(!ceMinimalMandatoryNullNoStrict.isValid()) // using default strict mode in the event
    t.ok(!ceMinimalMandatoryNullNoStrict.isValid({ strict: false })) // same of previous but using strict mode in validation options
    t.strictSame(ceMinimalMandatoryNullNoStrict.validate({ strict: false }).length, 3)
    t.ok(!ceMinimalMandatoryNullNoStrict.isValid({ strict: true })) // the same but validate with strict mode enabled ...

    // the same but with strict mode: expected exception ...
    t.throws(function () {
      const ceMinimalMandatoryNullStrict = new CloudEvent(null, null, null, null, { strict: true })
      assert(ceMinimalMandatoryNullStrict === null) // never executed
    }, Error, &apos;Expected exception when creating a CloudEvent without mandatory arguments with strict flag enabled&apos;)
  }
})

/** @test {CloudEvent} */
test(&apos;create two CloudEvent instances with all arguments (mandatory and optional arguments) and ensure they are different objects&apos;, (t) =&gt; {
  t.plan(21)
  const { CloudEvent } = require(&apos;../src/&apos;)
  t.ok(CloudEvent)

  // create an instance with an undefined mandatory argument (handled by defaults), but with strict flag disabled: expected success ...
  // note that null values are not handled by default values, only undefined values ...
  const ceFull1 = new CloudEvent(&apos;1/full&apos;,
    ceNamespace,
    ceServerUrl,
    ceCommonData,
    ceCommonOptions
  )
  t.ok(ceFull1)
  t.ok(CloudEvent.isValidEvent(ceFull1))
  t.ok(CloudEvent.isValidEvent(ceFull1, { strict: false }))
  t.strictSame(CloudEvent.validateEvent(ceFull1), [])
  t.strictSame(CloudEvent.validateEvent(ceFull1).length, 0)
  // the same but using normal instance methods, to ensure they works good ...
  t.ok(ceFull1.isValid())
  t.ok(ceFull1.isValid({ strict: false }))
  t.strictSame(ceFull1.validate(), [])
  t.strictSame(ceFull1.validate().length, 0)

  // create another instance with all fields equals: expected success ...
  const ceFull1Clone = new CloudEvent(&apos;1/full&apos;, // should be &apos;2/full/no-strict&apos; ...
    ceNamespace,
    ceServerUrl,
    ceCommonData,
    ceCommonOptions
  )
  t.ok(ceFull1Clone)
  t.ok(CloudEvent.isValidEvent(ceFull1Clone))
  t.ok(CloudEvent.isValidEvent(ceFull1Clone, { strict: false }))
  t.strictSame(CloudEvent.validateEvent(ceFull1Clone), [])
  t.strictSame(CloudEvent.validateEvent(ceFull1Clone).length, 0)
  // the same but using normal instance methods, to ensure they works good ...
  t.ok(ceFull1Clone.isValid())
  t.ok(ceFull1Clone.isValid({ strict: false }))
  t.strictSame(ceFull1Clone.validate(), [])
  t.strictSame(ceFull1Clone.validate().length, 0)

  // then ensure they are different objects ...
  assert(ceFull1 !== ceFull1Clone) // they must be different object references
  t.same(ceFull1, ceFull1Clone)
  t.strictSame(ceFull1, ceFull1Clone)
})

/** @test {CloudEvent} */
test(&apos;create CloudEvent instances with different kind of data attribute, and ensure the validation is right&apos;, (t) =&gt; {
  t.plan(81)
  const { CloudEvent } = require(&apos;../src/&apos;)
  t.ok(CloudEvent)

  {
    // create an instance with undefined data attribute, but with strict flag disabled: expected success ...
    // note that null values are not handled by default values, only undefined values ...
    const ceFullDataUndefined = new CloudEvent(&apos;1/full/undefined-data/no-strict&apos;,
      ceNamespace,
      ceServerUrl,
      undefined, // data
      ceCommonOptions
    )
    assert(ceFullDataUndefined !== null)
    t.ok(ceFullDataUndefined)
    t.ok(CloudEvent.isValidEvent(ceFullDataUndefined))
    t.ok(CloudEvent.isValidEvent(ceFullDataUndefined, { strict: false }))
    t.strictSame(CloudEvent.validateEvent(ceFullDataUndefined), [])
    t.strictSame(CloudEvent.validateEvent(ceFullDataUndefined, { strict: false }).length, 0)
    // the same but using normal instance methods, to ensure they works good ...
    t.ok(ceFullDataUndefined.isValid())
    t.ok(ceFullDataUndefined.isValid({ strict: false }))
    t.strictSame(ceFullDataUndefined.validate(), [])
    t.strictSame(ceFullDataUndefined.validate({ strict: false }).length, 0)
    // the same but with strict mode enabled ...
    const ceFullDataUndefinedStrict = new CloudEvent(&apos;1/full/undefined-data/strict&apos;,
      ceNamespace,
      ceServerUrl,
      undefined, // data
      ceCommonOptionsStrict
    )
    assert(ceFullDataUndefinedStrict !== null)
    t.ok(ceFullDataUndefinedStrict)
    t.ok(CloudEvent.isValidEvent(ceFullDataUndefinedStrict))
    t.ok(CloudEvent.isValidEvent(ceFullDataUndefinedStrict, { strict: true }))
    t.strictSame(CloudEvent.validateEvent(ceFullDataUndefinedStrict), [])
    t.strictSame(CloudEvent.validateEvent(ceFullDataUndefinedStrict, { strict: true }).length, 0)
    // the same but using normal instance methods, to ensure they works good ...
    t.ok(ceFullDataUndefinedStrict.isValid())
    t.ok(ceFullDataUndefinedStrict.isValid({ strict: true }))
    t.strictSame(ceFullDataUndefinedStrict.validate(), [])
    t.strictSame(ceFullDataUndefinedStrict.validate({ strict: true }).length, 0)
  }

  {
    // create an instance with null data attribute, but with strict flag disabled: expected success ...
    // note that null values are not handled by default values, only undefined values ...
    const ceFullDataNull = new CloudEvent(&apos;1/full/null-data/no-strict&apos;,
      ceNamespace,
      ceServerUrl,
      null, // data
      ceCommonOptions
    )
    assert(ceFullDataNull !== null)
    t.ok(ceFullDataNull)
    t.ok(CloudEvent.isValidEvent(ceFullDataNull))
    t.ok(CloudEvent.isValidEvent(ceFullDataNull, { strict: false }))
    t.strictSame(CloudEvent.validateEvent(ceFullDataNull), [])
    t.strictSame(CloudEvent.validateEvent(ceFullDataNull, { strict: false }).length, 0)
    // the same but using normal instance methods, to ensure they works good ...
    t.ok(ceFullDataNull.isValid())
    t.ok(ceFullDataNull.isValid({ strict: false }))
    t.strictSame(ceFullDataNull.validate(), [])
    t.strictSame(ceFullDataNull.validate({ strict: false }).length, 0)
    // the same but with strict mode enabled ...
    const ceFullDataNullStrict = new CloudEvent(&apos;1/full/null-data/strict&apos;,
      ceNamespace,
      ceServerUrl,
      null, // data
      ceCommonOptionsStrict
    )
    assert(ceFullDataNullStrict !== null)
    t.ok(ceFullDataNullStrict)
    t.ok(CloudEvent.isValidEvent(ceFullDataNullStrict))
    t.ok(CloudEvent.isValidEvent(ceFullDataNullStrict, { strict: true }))
    t.strictSame(CloudEvent.validateEvent(ceFullDataNullStrict), [])
    t.strictSame(CloudEvent.validateEvent(ceFullDataNullStrict, { strict: true }).length, 0)
    // the same but using normal instance methods, to ensure they works good ...
    t.ok(ceFullDataNullStrict.isValid())
    t.ok(ceFullDataNullStrict.isValid({ strict: true }))
    t.strictSame(ceFullDataNullStrict.validate(), [])
    t.strictSame(ceFullDataNullStrict.validate({ strict: true }).length, 0)
  }

  {
    // create an instance with a string data attribute, but with strict flag disabled: expected success ...
    const ceFullDataString = new CloudEvent(&apos;1/full/string-data/no-strict&apos;,
      ceNamespace,
      ceServerUrl,
      &apos;data as a string, bad here&apos;, // data
      ceCommonOptions
    )
    assert(ceFullDataString !== null)
    t.ok(ceFullDataString)
    // data type errors handled only in strict mode currently ...
    t.ok(CloudEvent.isValidEvent(ceFullDataString))
    t.ok(CloudEvent.isValidEvent(ceFullDataString, { strict: false })) // good the same
    t.ok(!CloudEvent.isValidEvent(ceFullDataString, { strict: true })) // bad here (right)
    t.strictSame(CloudEvent.validateEvent(ceFullDataString), [])
    t.strictSame(CloudEvent.validateEvent(ceFullDataString, { strict: false }).length, 0) // good the same
    t.strictSame(CloudEvent.validateEvent(ceFullDataString, { strict: true }).length, 1) // bad here (right)
    // the same but using normal instance methods, to ensure they works good ...
    t.ok(ceFullDataString.isValid())
    t.ok(ceFullDataString.isValid({ strict: false }))
    t.ok(!ceFullDataString.isValid({ strict: true }))
    t.strictSame(ceFullDataString.validate(), [])
    t.strictSame(ceFullDataString.validate({ strict: false }).length, 0)
    t.strictSame(ceFullDataString.validate({ strict: true }).length, 1)
    // the same but with strict mode enabled ...
    const ceFullDataStringStrict = new CloudEvent(&apos;1/full/string-data/strict&apos;,
      ceNamespace,
      ceServerUrl,
      &apos;data as a string, bad here&apos;, // data
      ceCommonOptionsStrict
    )
    assert(ceFullDataStringStrict !== null)
    t.ok(ceFullDataStringStrict)
    // data type errors handled only in strict mode currently ...
    // note that in the following lines even if I force &apos;strict: false&apos; he won&apos;t be used because already set in the object instance ...
    t.ok(!CloudEvent.isValidEvent(ceFullDataStringStrict))
    t.ok(!CloudEvent.isValidEvent(ceFullDataStringStrict, { strict: true }))
    t.ok(!CloudEvent.isValidEvent(ceFullDataStringStrict, { strict: false }))
    t.strictSame(CloudEvent.validateEvent(ceFullDataStringStrict).length, 1)
    t.strictSame(CloudEvent.validateEvent(ceFullDataStringStrict, { strict: true }).length, 1)
    t.strictSame(CloudEvent.validateEvent(ceFullDataStringStrict, { strict: false }).length, 1)
    // the same but using normal instance methods, to ensure they works good ...
    t.ok(!ceFullDataStringStrict.isValid())
    t.ok(!ceFullDataStringStrict.isValid({ strict: true }))
    t.ok(!ceFullDataStringStrict.isValid({ strict: false }))
    t.strictSame(ceFullDataStringStrict.validate().length, 1)
    t.strictSame(ceFullDataStringStrict.validate({ strict: true }).length, 1)
    t.strictSame(ceFullDataStringStrict.validate({ strict: false }).length, 1)
  }

  {
    // create an instance with a sample Map data attribute, but with strict flag disabled: expected success ...
    // note that null values are not handled by default values, only undefined values ...
    const ceFullDataMap = new CloudEvent(&apos;1/full/map-data/no-strict&apos;,
      ceNamespace,
      ceServerUrl,
      ceMapData, // data
      ceCommonOptions
    )
    assert(ceFullDataMap !== null)
    t.ok(ceFullDataMap)
    t.ok(CloudEvent.isValidEvent(ceFullDataMap))
    t.ok(CloudEvent.isValidEvent(ceFullDataMap, { strict: false }))
    t.strictSame(CloudEvent.validateEvent(ceFullDataMap), []) // data type errors handled only in strict mode currently ...
    t.strictSame(CloudEvent.validateEvent(ceFullDataMap, { strict: false }).length, 0) // data type errors handled only in strict mode currently ...
    // the same but using normal instance methods, to ensure they works good ...
    t.ok(ceFullDataMap.isValid())
    t.ok(ceFullDataMap.isValid({ strict: false }))
    t.strictSame(ceFullDataMap.validate(), []) // data type errors handled only in strict mode currently ...
    t.strictSame(ceFullDataMap.validate({ strict: false }).length, 0) // data type errors handled only in strict mode currently ...
    // the same but with strict mode enabled ...
    const ceFullDataMapStrict = new CloudEvent(&apos;1/full/map-data/strict&apos;,
      ceNamespace,
      ceServerUrl,
      ceMapData, // data
      ceCommonOptionsStrict
    )
    assert(ceFullDataMapStrict !== null)
    t.ok(ceFullDataMapStrict)
    t.ok(CloudEvent.isValidEvent(ceFullDataMapStrict))
    t.ok(CloudEvent.isValidEvent(ceFullDataMapStrict, { strict: true }))
    t.strictSame(CloudEvent.validateEvent(ceFullDataMapStrict).length, 0) // data type errors handled only in strict mode currently ...
    t.strictSame(CloudEvent.validateEvent(ceFullDataMapStrict, { strict: true }).length, 0) // data type errors handled only in strict mode currently ...
    // the same but using normal instance methods, to ensure they works good ...
    t.ok(ceFullDataMapStrict.isValid())
    t.ok(ceFullDataMapStrict.isValid({ strict: true }))
    t.strictSame(ceFullDataMapStrict.validate().length, 0) // data type errors handled only in strict mode currently ...
    t.strictSame(ceFullDataMapStrict.validate({ strict: true }).length, 0) // data type errors handled only in strict mode currently ...
  }
})

/** @test {CloudEvent} */
test(&apos;ensure a CloudEvent/subclass instance is seen as a CloudEvent instance, but not other objects&apos;, (t) =&gt; {
  t.plan(36)

  const { CloudEvent, CloudEventValidator: V } = require(&apos;../src/&apos;) // get references via destructuring
  t.ok(CloudEvent)

  /** create some classes, for better reuse in following tests */
  class NotCESubclass {
  }
  class CESubclass extends CloudEvent {
  }

  {
    // check that an undefined object is not seen as a CloudEvent
    const ceObject = undefined
    t.strictEqual(ceObject, undefined)
    t.strictEqual(ceObject instanceof CloudEvent, false)
    t.ok(!V.isClass(ceObject, CloudEvent))
    t.throws(function () {
      const isCloudEvent = !CloudEvent.isCloudEvent(ceObject)
      assert(isCloudEvent === undefined) // never executed
    }, Error, `Expected exception when calling &apos;CloudEvent.isCloudEvent&apos; with an undefined or null argument`)
  }

  {
    // check that a null object is not seen as a CloudEvent
    const ceObject = null
    t.strictEqual(typeof ceObject, &apos;object&apos;)
    t.strictEqual(ceObject, null)
    t.strictEqual(ceObject instanceof CloudEvent, false)
    t.ok(!V.isClass(ceObject, CloudEvent))
    t.throws(function () {
      const isCloudEvent = !CloudEvent.isCloudEvent(ceObject)
      assert(isCloudEvent === null) // never executed
    }, Error, `Expected exception when calling &apos;CloudEvent.isCloudEvent&apos; with an undefined or null argument`)
  }

  {
    // check that a generic object is not seen as a CloudEvent
    const ceObject = {}
    t.strictEqual(typeof ceObject, &apos;object&apos;)
    t.strictEqual(ceObject instanceof CloudEvent, false)
    t.ok(!V.isClass(ceObject, CloudEvent))
    t.ok(!CloudEvent.isCloudEvent(ceObject))
    t.ok(V.isStringNotEmpty(ceObject.toString()))
  }

  {
    // check that even an empty instance belongs to the right base class
    const ceEmpty = new CloudEvent()
    t.strictEqual(typeof ceEmpty, &apos;object&apos;)
    t.strictEqual(ceEmpty instanceof CloudEvent, true)
    t.ok(!V.isClass(ceEmpty, NotCESubclass))
    t.ok(V.isClass(ceEmpty, CloudEvent))
    t.ok(!V.isClass(ceEmpty, CESubclass))
    t.ok(CloudEvent.isCloudEvent(ceEmpty))
    t.ok(V.isStringNotEmpty(ceEmpty.toString()))

    // check that a subclass instance is seen as a CloudEvent
    const ceEmptySubclass = new CESubclass()
    t.strictEqual(typeof ceEmptySubclass, &apos;object&apos;)
    t.strictEqual(ceEmptySubclass instanceof CloudEvent, true)
    t.ok(!V.isClass(ceEmptySubclass, NotCESubclass))
    t.ok(V.isClass(ceEmptySubclass, CloudEvent))
    t.ok(V.isClass(ceEmptySubclass, CESubclass))
    t.ok(CloudEvent.isCloudEvent(ceEmptySubclass))
    t.ok(V.isStringNotEmpty(ceEmptySubclass.toString()))

    // check that a class instance outside CloudEvent class hierarchy is not seen as a CloudEvent
    const ceEmptyNoSubclass = new NotCESubclass()
    t.strictEqual(typeof ceEmptyNoSubclass, &apos;object&apos;)
    t.strictEqual(ceEmptyNoSubclass instanceof CloudEvent, false)
    t.ok(V.isClass(ceEmptyNoSubclass, NotCESubclass))
    t.ok(!V.isClass(ceEmptyNoSubclass, CloudEvent))
    t.ok(!V.isClass(ceEmptyNoSubclass, CESubclass))
    t.ok(!CloudEvent.isCloudEvent(ceEmptyNoSubclass))
    t.ok(V.isStringNotEmpty(ceEmptyNoSubclass.toString()))
  }
})

/** @test {CloudEvent} */
test(&apos;ensure CloudEvent and objects are merged in the right way&apos;, (t) =&gt; {
  t.plan(14)

  const { CloudEvent, CloudEventValidator: V, CloudEventTransformer: T } = require(&apos;../src/&apos;) // get references via destructuring
  t.ok(V.isFunction(CloudEvent))
  t.ok(V.isFunction(V))
  t.ok(V.isFunction(T))
  t.ok(V.isFunction(T.mergeObjects))

  {
    const base = new CloudEvent()
    const obj = T.mergeObjects(base)
    t.ok(V.isObject(obj))
    t.strictSame(Object.getPrototypeOf(obj), Object.getPrototypeOf(base))
  }
  {
    const base = new CloudEvent(&apos;1&apos;, // id
      ceNamespace,
      ceServerUrl,
      {} // data (empty) // optional, but useful the same in this sample usage
    )
    t.ok(base)
    t.ok(base.isValid({ strict: false })) // strict false here because base is missing some attribute, for the test
    t.ok(!base.isStrict)
    const obj = T.mergeObjects(base, { data: ceCommonData }, ceCommonOptions, { extensions: { strict: true } })
    // console.log(`DEBUG - merged details: ${T.dumpObject(obj, &apos;obj&apos;)}`)
    t.ok(obj)
    t.ok(V.isObject(obj))
    t.strictSame(Object.getPrototypeOf(obj), Object.getPrototypeOf(base))
    t.ok(obj.isValid({ strict: true }))
    t.ok(obj.isStrict)
  }
})
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>

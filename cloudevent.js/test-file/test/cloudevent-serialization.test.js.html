<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">test/cloudevent-serialization.test.js | cloudevent</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="JavaScript/Node.js implementation of the CloudEvents standard format"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="cloudevent"><meta property="twitter:description" content="JavaScript/Node.js implementation of the CloudEvents standard format"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  <a href="test.html" data-ice="testLink">Test</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/smartiniOnGitHub/cloudevent.js"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/cloudevent.js~CloudEvent.html">CloudEvent</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/jsonbatch.js~JSONBatch.html">JSONBatch</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/transformer.js~Transformer.html">Transformer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/validator.js~Validator.html">Validator</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">test/cloudevent-serialization.test.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">/*
 * Copyright 2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
&apos;use strict&apos;

const assert = require(&apos;assert&apos;).strict
const test = require(&apos;tap&apos;).test

/** @test {CloudEvent} */
test(&apos;ensure serialization functions exists (check only the static method here)&apos;, (t) =&gt; {
  t.plan(9)

  {
    const { CloudEvent } = require(&apos;../src/&apos;) // get references via destructuring
    t.ok(CloudEvent)
    // optional, using some standard Node.js assert statements, as a sample
    assert(CloudEvent !== null)
    assert.strictEqual(typeof CloudEvent, &apos;function&apos;)
    assert(new CloudEvent() instanceof CloudEvent)
    assert.strictEqual(CloudEvent.mediaType(), &apos;application/cloudevents+json&apos;)
    t.ok(CloudEvent)
    t.strictEqual(typeof CloudEvent, &apos;function&apos;)
    t.strictEqual(new CloudEvent() instanceof CloudEvent, true)
    t.strictEqual(CloudEvent.mediaType(), &apos;application/cloudevents+json&apos;)

    const ceSerialize = CloudEvent.serializeEvent
    assert(ceSerialize !== null)
    assert(typeof ceSerialize === &apos;function&apos;)
    t.ok(ceSerialize)
    t.strictEqual(typeof ceSerialize, &apos;function&apos;)

    const ceDeserialize = CloudEvent.deserializeEvent
    assert(ceDeserialize !== null)
    assert(typeof ceDeserialize === &apos;function&apos;)
    t.ok(ceDeserialize)
    t.strictEqual(typeof ceDeserialize, &apos;function&apos;)
  }
})

// import some common test data
const {
  commonEventTime,
  ceCommonOptions,
  ceCommonOptionsStrict,
  ceCommonExtensions,
  ceNamespace,
  ceServerUrl,
  ceCommonData
} = require(&apos;./common-test-data&apos;)

/** sample data as an xml string */
const ceDataAsXmlString = &apos;&lt;data &quot;hello&quot;=&quot;world&quot; &quot;year&quot;=&quot;2020&quot; /&gt;&apos;
/** sample data as a json string */
const ceDataAsJSONString = JSON.stringify(ceCommonData)
/** create a sample string big (more than 64 KB) */
const ceBigStringLength = 100000
const ceBigString = getRandomString(ceBigStringLength) // a random string with n chars

// sample function to calculate a random string, given the length, to use in tests here
function getRandomString (length) {
  let str = Math.random().toString(36).substr(2)
  while (str.length &lt; length) {
    str += Math.random().toString(36).substr(2)
  }
  return str.substr(0, length)
}

/** @test {CloudEvent} */
test(&apos;serialize some CloudEvent instances to JSON, and ensure they are right&apos;, (t) =&gt; {
  t.plan(68)

  const { CloudEvent, CloudEventTransformer: T } = require(&apos;../src/&apos;)
  // t.ok(CloudEvent)

  {
    // create an instance with a sample data attribute, but with strict flag disabled: expected success ...
    // note that null values are not handled by default values, only undefined values ...
    const ceFull = new CloudEvent(&apos;1/full/sample-data/no-strict&apos;,
      ceNamespace,
      ceServerUrl,
      ceCommonData, // data
      ceCommonOptions,
      ceCommonExtensions
    )
    assert(ceFull !== null)
    t.ok(CloudEvent.isCloudEvent(ceFull))
    t.ok(ceFull)
    t.ok(!ceFull.isStrict)
    t.ok(ceFull.isValid())
    t.ok(ceFull.validate().length === 0)
    t.ok(ceFull.validate({ strict: false }).length === 0)
    t.ok(ceFull.validate({ strict: true }).length === 0)
    t.ok(CloudEvent.isValidEvent(ceFull))
    t.ok(CloudEvent.validateEvent(ceFull).length === 0)
    t.ok(CloudEvent.validateEvent(ceFull, { strict: false }).length === 0)
    t.ok(CloudEvent.validateEvent(ceFull, { strict: true }).length === 0)
    t.strictEqual(ceFull.datacontenttype, CloudEvent.datacontenttypeDefault())
    t.ok(CloudEvent.isDatacontenttypeJSONEvent(ceFull))

    t.throws(function () {
      const ceFullSerialized = CloudEvent.serializeEvent(undefined)
      assert(ceFullSerialized === null) // never executed
    }, Error, &apos;Expected exception when serializing an undefined / null CloudEvent instance&apos;)
    t.throws(function () {
      const ceFullSerialized = CloudEvent.serializeEvent(null)
      assert(ceFullSerialized === null) // never executed
    }, Error, &apos;Expected exception when serializing an undefined / null CloudEvent instance&apos;)

    const ceFullSerializedStatic = CloudEvent.serializeEvent(ceFull)
    t.ok(ceFullSerializedStatic)
    const ceFullSerialized = ceFull.serialize()
    t.ok(ceFullSerialized)
    assert(ceFullSerializedStatic === ceFullSerialized)
    t.strictSame(ceFullSerializedStatic, ceFullSerialized)
    const ceSerialize = CloudEvent.serializeEvent
    assert(ceSerialize !== null)
    t.ok(ceSerialize)
    const ceFullSerializedFunction = ceSerialize(ceFull)
    t.ok(ceFullSerializedFunction)
    t.strictSame(ceFullSerializedFunction, ceFullSerializedStatic)
    t.strictSame(ceFullSerializedFunction, ceFullSerialized)

    const ceFullSerializedComparison = `{&quot;id&quot;:&quot;1/full/sample-data/no-strict&quot;,&quot;type&quot;:&quot;com.github.smartiniOnGitHub.cloudeventjs.testevent&quot;,&quot;source&quot;:&quot;/test&quot;,&quot;data&quot;:{&quot;hello&quot;:&quot;world&quot;,&quot;year&quot;:2020},&quot;specversion&quot;:&quot;1.0&quot;,&quot;datacontenttype&quot;:&quot;application/json&quot;,&quot;dataschema&quot;:&quot;http://my-schema.localhost.localdomain&quot;,&quot;time&quot;:&quot;${T.timestampToString(commonEventTime)}&quot;,&quot;subject&quot;:&quot;subject&quot;,&quot;exampleextension&quot;:&quot;value&quot;}`
    t.strictSame(ceFullSerialized, ceFullSerializedComparison)
    // deserialization using standard function JSON.parse, so built instance is not a real CloudEvent instance
    const ceFullDeserialized = JSON.parse(ceFullSerialized) // note that some fields (like dates) will be different when deserialized in this way ...
    ceFullDeserialized.time = commonEventTime // quick fix for the Date/timestamp attribute in the deserialized object
    ceFullDeserialized.data_base64 = undefined // quick fix for this not so common attribute in the deserialized object
    t.same(ceFull, ceFullDeserialized)
    t.ok(!CloudEvent.isCloudEvent(ceFullDeserialized))
    t.ok(!ceFullDeserialized.isStrict) // ok here, but doesn&apos;t mattter because is not a real CloudEvent instance

    const ceFullSerializedOnlyValidFalse = ceSerialize(ceFull, { onlyValid: false })
    t.ok(ceFullSerializedOnlyValidFalse)
    const ceFullSerializedOnlyValidTrue = ceSerialize(ceFull, { onlyValid: true })
    t.ok(ceFullSerializedOnlyValidTrue)

    {
      const ceFullBad = new CloudEvent(null,
        ceNamespace,
        ceServerUrl,
        ceCommonData, // data
        ceCommonOptions,
        ceCommonExtensions
      )
      assert(ceFullBad !== null)
      t.ok(ceFullBad)
      t.ok(!ceFullBad.isValid())
      const ceFullBadSerializedOnlyValidFalse = ceSerialize(ceFullBad, { onlyValid: false })
      t.ok(ceFullBadSerializedOnlyValidFalse)
      t.throws(function () {
        const ceFullBadSerializedOnlyValidTrue = ceSerialize(ceFullBad, { onlyValid: true })
        assert(ceFullBadSerializedOnlyValidTrue === null) // never executed
      }, Error, &apos;Expected exception when serializing a bad CloudEvent instance&apos;)
    }

    // test to ensure that old style extensions are not serialized
    const ceFullSerializedStaticWithoutExtensionsProperty = CloudEvent.serializeEvent({ ...ceFull, extensions: { exampleexttoskip: &apos;valueToSkip&apos; } })
    t.ok(ceFullSerializedStaticWithoutExtensionsProperty)
    t.strictSame(ceFullSerializedStaticWithoutExtensionsProperty.search(&apos;exampleexttoskip&apos;), -1)
  }

  {
    // the same but with strict mode enabled ...
    const ceFullStrict = new CloudEvent(&apos;1/full/sample-data/strict&apos;,
      ceNamespace,
      ceServerUrl,
      ceCommonData, // data
      ceCommonOptionsStrict,
      ceCommonExtensions
    )
    assert(ceFullStrict !== null)
    t.ok(CloudEvent.isCloudEvent(ceFullStrict))
    t.ok(ceFullStrict)
    t.ok(ceFullStrict.isStrict)
    t.ok(ceFullStrict.isValid())
    t.ok(ceFullStrict.validate().length === 0)
    t.ok(ceFullStrict.validate({ strict: true }).length === 0)
    t.ok(ceFullStrict.validate({ strict: false }).length === 0)
    t.ok(CloudEvent.isValidEvent(ceFullStrict))
    t.ok(CloudEvent.validateEvent(ceFullStrict).length === 0)
    t.ok(CloudEvent.validateEvent(ceFullStrict, { strict: true }).length === 0)
    t.ok(CloudEvent.validateEvent(ceFullStrict, { strict: false }).length === 0)
    t.strictEqual(ceFullStrict.datacontenttype, CloudEvent.datacontenttypeDefault())
    t.ok(CloudEvent.isDatacontenttypeJSONEvent(ceFullStrict))

    t.throws(function () {
      const ceFullSerialized = CloudEvent.serializeEvent(undefined)
      assert(ceFullSerialized === null) // never executed
    }, Error, &apos;Expected exception when serializing an undefined / null CloudEvent instance&apos;)
    t.throws(function () {
      const ceFullSerialized = CloudEvent.serializeEvent(null)
      assert(ceFullSerialized === null) // never executed
    }, Error, &apos;Expected exception when serializing an undefined / null CloudEvent instance&apos;)

    const ceFullStrictSerializedStatic = CloudEvent.serializeEvent(ceFullStrict)
    t.ok(ceFullStrictSerializedStatic)
    const ceFullStrictSerialized = ceFullStrict.serialize()
    t.ok(ceFullStrictSerialized)
    assert(ceFullStrictSerializedStatic === ceFullStrictSerialized)
    t.strictSame(ceFullStrictSerializedStatic, ceFullStrictSerialized)
    const ceSerialize = CloudEvent.serializeEvent
    assert(ceSerialize !== null)
    t.ok(ceSerialize)
    const ceFullStrictSerializedFunction = ceSerialize(ceFullStrict)
    t.ok(ceFullStrictSerializedFunction)
    t.strictSame(ceFullStrictSerializedFunction, ceFullStrictSerializedStatic)
    t.strictSame(ceFullStrictSerializedFunction, ceFullStrictSerialized)

    const ceFullStrictSerializedComparison = `{&quot;id&quot;:&quot;1/full/sample-data/strict&quot;,&quot;type&quot;:&quot;com.github.smartiniOnGitHub.cloudeventjs.testevent&quot;,&quot;source&quot;:&quot;/test&quot;,&quot;data&quot;:{&quot;hello&quot;:&quot;world&quot;,&quot;year&quot;:2020},&quot;specversion&quot;:&quot;1.0&quot;,&quot;datacontenttype&quot;:&quot;application/json&quot;,&quot;dataschema&quot;:&quot;http://my-schema.localhost.localdomain&quot;,&quot;time&quot;:&quot;${T.timestampToString(commonEventTime)}&quot;,&quot;subject&quot;:&quot;subject&quot;,&quot;strictvalidation&quot;:true,&quot;exampleextension&quot;:&quot;value&quot;}`
    t.strictSame(ceFullStrictSerialized, ceFullStrictSerializedComparison)
    // deserialization using standard function JSON.parse, so built instance is not a real CloudEvent instance
    const ceFullStrictDeserialized = JSON.parse(ceFullStrictSerialized) // note that some fields (like dates) will be different when deserialized in this way ...
    ceFullStrictDeserialized.time = commonEventTime // quick fix for the Date/timestamp attribute in the deserialized object
    ceFullStrictDeserialized.data_base64 = undefined // quick fix for this not so common attribute in the deserialized object
    t.same(ceFullStrict, ceFullStrictDeserialized)
    t.ok(!CloudEvent.isCloudEvent(ceFullStrictDeserialized))
    t.ok(!ceFullStrictDeserialized.isStrict) // wrong here, but doesn&apos;t mattter because is not a real CloudEvent instance

    const ceFullStrictSerializedOnlyValidFalse = ceSerialize(ceFullStrict, { onlyValid: false })
    t.ok(ceFullStrictSerializedOnlyValidFalse)
    const ceFullStrictSerializedOnlyValidTrue = ceSerialize(ceFullStrict, { onlyValid: true })
    t.ok(ceFullStrictSerializedOnlyValidTrue)

    {
      const ceFullStrictBad = new CloudEvent(&apos;1/full/sample-data/strict&apos;,
        ceNamespace,
        ceServerUrl,
        ceCommonData, // data
        ceCommonOptionsStrict,
        ceCommonExtensions
      )
      assert(ceFullStrictBad !== null)
      t.ok(ceFullStrictBad)
      ceFullStrictBad.id = null // remove some mandatory attribute now, to let serialization fail
      t.ok(!ceFullStrictBad.isValid())
      const ceFullStrictBadSerializedOnlyValidFalse = ceSerialize(ceFullStrictBad, { onlyValid: false })
      t.ok(ceFullStrictBadSerializedOnlyValidFalse)
      t.throws(function () {
        const ceFullStrictBadSerializedOnlyValidTrue = ceSerialize(ceFullStrictBad, { onlyValid: true })
        assert(ceFullStrictBadSerializedOnlyValidTrue === null) // never executed
      }, Error, &apos;Expected exception when serializing a bad CloudEvent instance&apos;)
    }

    // test to ensure that old style extensions are not serialized
    const ceFullStrictSerializedStaticWithoutExtensionsProperty = CloudEvent.serializeEvent({ ...ceFullStrict, extensions: { exampleexttoskip: &apos;valueToSkip&apos; } })
    t.ok(ceFullStrictSerializedStaticWithoutExtensionsProperty)
    t.strictSame(ceFullStrictSerializedStaticWithoutExtensionsProperty.search(&apos;exampleexttoskip&apos;), -1)
  }
})

/** @test {CloudEvent} */
test(&apos;serialize a CloudEvent instance with a non default contenttype and empty serialization options, expect error&apos;, (t) =&gt; {
  t.plan(34)

  const { CloudEvent } = require(&apos;../src/&apos;)
  t.ok(CloudEvent)

  {
    // create an instance with non default contenttype (other options default): expected success ...
    // when I try to serialize it without specifying serialization options, expect to have an error raised ...
    const ceFullOtherContentType = new CloudEvent(&apos;1/non-default-contenttype/sample-data/no-strict&apos;,
      ceNamespace,
      ceServerUrl,
      ceCommonData, // data
      {
        ...ceCommonOptions,
        datacontenttype: &apos;application/xml&apos;
      },
      ceCommonExtensions
    )
    assert(ceFullOtherContentType !== null)
    t.ok(ceFullOtherContentType)
    t.ok(ceFullOtherContentType.isValid())
    t.ok(!ceFullOtherContentType.isStrict)
    t.throws(function () {
      const ceFullOtherContentTypeSerialized = ceFullOtherContentType.serialize()
      assert(ceFullOtherContentTypeSerialized === null) // never executed
    }, Error, &apos;Expected exception when serializing the current CloudEvent instance&apos;)
    t.throws(function () {
      const ceFullOtherContentTypeSerialized = CloudEvent.serializeEvent(ceFullOtherContentType, {
        encoder: &apos;encoderToXmlSample&apos;
      })
      assert(ceFullOtherContentTypeSerialized === null) // never executed
    }, Error, &apos;Expected exception when serializing the current CloudEvent instance&apos;)
    t.throws(function () {
      const ceFullOtherContentTypeSerialized = CloudEvent.serializeEvent(ceFullOtherContentType, {
        encodedData: true
      })
      assert(ceFullOtherContentTypeSerialized === null) // never executed
    }, Error, &apos;Expected exception when serializing the current CloudEvent instance&apos;)
    t.throws(function () {
      const flag = CloudEvent.isStrictEvent(undefined)
      assert(flag === false) // never executed
    }, Error, &apos;Expected exception when trying to get the strict mode for an undefined/null CloudEvent instance&apos;)
    t.throws(function () {
      const flag = CloudEvent.isStrictEvent(null)
      assert(flag === false) // never executed
    }, Error, &apos;Expected exception when trying to get the strict mode for an undefined/null CloudEvent instance&apos;)
    t.throws(function () {
      const flag = CloudEvent.isStrictEvent({})
      assert(flag === false) // never executed
    }, Error, &apos;Expected exception when trying to get the strict mode for for not a CloudEvent instance&apos;)

    {
      const ce = ceFullOtherContentType
      CloudEvent.setStrictExtensionInEvent(ce, false)
      const flag = CloudEvent.isStrictEvent(ce)
      t.strictSame(flag, false)
    }
    {
      const ce = ceFullOtherContentType
      CloudEvent.setStrictExtensionInEvent(ce, true)
      const flag = CloudEvent.isStrictEvent(ce)
      t.strictSame(flag, true)
    }

    {
      const ceFullOtherContentTypeBad = new CloudEvent(null,
        ceNamespace,
        ceServerUrl,
        ceCommonData, // data
        {
          ...ceCommonOptions,
          datacontenttype: &apos;application/xml&apos;
        },
        ceCommonExtensions
      )
      assert(ceFullOtherContentTypeBad !== null)
      t.ok(ceFullOtherContentTypeBad)
      t.ok(!ceFullOtherContentTypeBad.isValid())
      const ceFullBadSerializedOnlyValidFalse = CloudEvent.serializeEvent(ceFullOtherContentTypeBad, {
        encodedData: ceDataAsXmlString,
        onlyValid: false
      })
      t.ok(ceFullBadSerializedOnlyValidFalse)
      t.throws(function () {
        const ceFullBadSerializedOnlyValidTrue = CloudEvent.serializeEvent(ceFullOtherContentTypeBad, {
          encodedData: ceDataAsXmlString,
          onlyValid: true
        })
        assert(ceFullBadSerializedOnlyValidTrue === null) // never executed
      }, Error, &apos;Expected exception when serializing a bad CloudEvent instance&apos;)
    }
  }

  {
    // the same but with strict mode enabled ...
    // expect success even if content type is not default and data is not a string,
    // anyway use encoder/decoder to let serialization/deserialization work in this case (strict) ...
    const ceFullOtherContentTypeStrict = new CloudEvent(&apos;1/non-default-contenttype/sample-data/strict&apos;,
      ceNamespace,
      ceServerUrl,
      ceCommonData, // data
      {
        ...ceCommonOptionsStrict,
        datacontenttype: &apos;application/xml&apos;
      },
      ceCommonExtensions
    )
    assert(ceFullOtherContentTypeStrict !== null)
    t.ok(ceFullOtherContentTypeStrict)
    t.ok(ceFullOtherContentTypeStrict.isValid())
    t.ok(ceFullOtherContentTypeStrict.isStrict)
    t.throws(function () {
      const ceFullOtherContentTypeStrictSerialized = ceFullOtherContentTypeStrict.serialize()
      assert(ceFullOtherContentTypeStrictSerialized === null) // never executed
    }, Error, &apos;Expected exception when serializing the current CloudEvent instance&apos;)
    t.throws(function () {
      const ceFullOtherContentTypeStrictSerialized = ceFullOtherContentTypeStrict.serialize({
        encoder: null,
        encodedData: null
      })
      assert(ceFullOtherContentTypeStrictSerialized === null) // never executed
    }, Error, &apos;Expected exception when serializing the current CloudEvent instance&apos;)
    t.throws(function () {
      const ceFullOtherContentTypeStrictSerialized = CloudEvent.serializeEvent(ceFullOtherContentTypeStrict, { onlyValid: true })
      assert(ceFullOtherContentTypeStrictSerialized === null) // never executed
    }, Error, &apos;Expected exception when serializing the current CloudEvent instance&apos;)
    t.throws(function () {
      const ceFullOtherContentTypeStrictSerialized = CloudEvent.serializeEvent(ceFullOtherContentTypeStrict, {
        encoder: null,
        encodedData: null,
        onlyValid: true
      })
      assert(ceFullOtherContentTypeStrictSerialized === null) // never executed
    }, Error, &apos;Expected exception when serializing the current CloudEvent instance&apos;)
    t.throws(function () {
      const ceFullOtherContentTypeSerialized = CloudEvent.serializeEvent(ceFullOtherContentTypeStrict, {
        encoder: &apos;encoderToXmlSample&apos;
      })
      assert(ceFullOtherContentTypeSerialized === null) // never executed
    }, Error, &apos;Expected exception when serializing the current CloudEvent instance&apos;)
    t.throws(function () {
      const ceFullOtherContentTypeSerialized = CloudEvent.serializeEvent(ceFullOtherContentTypeStrict, {
        encodedData: true
      })
      assert(ceFullOtherContentTypeSerialized === null) // never executed
    }, Error, &apos;Expected exception when serializing the current CloudEvent instance&apos;)
    t.throws(function () {
      const flag = CloudEvent.isStrictEvent(undefined)
      assert(flag === false) // never executed
    }, Error, &apos;Expected exception when trying to get the strict mode for an undefined/null CloudEvent instance&apos;)
    t.throws(function () {
      const flag = CloudEvent.isStrictEvent(null)
      assert(flag === false) // never executed
    }, Error, &apos;Expected exception when trying to get the strict mode for an undefined/null CloudEvent instance&apos;)
    t.throws(function () {
      const flag = CloudEvent.isStrictEvent({})
      assert(flag === false) // never executed
    }, Error, &apos;Expected exception when trying to get the strict mode for for not a CloudEvent instance&apos;)

    {
      const ce = ceFullOtherContentTypeStrict
      CloudEvent.setStrictExtensionInEvent(ce, false)
      const flag = CloudEvent.isStrictEvent(ce)
      t.strictSame(flag, false)
    }
    {
      const ce = ceFullOtherContentTypeStrict
      CloudEvent.setStrictExtensionInEvent(ce, true)
      const flag = CloudEvent.isStrictEvent(ce)
      t.strictSame(flag, true)
    }

    {
      const ceFullOtherContentTypeStrictBad = new CloudEvent(&apos;1/non-default-contenttype/sample-data/strict&apos;,
        ceNamespace,
        ceServerUrl,
        ceCommonData, // data
        {
          ...ceCommonOptionsStrict,
          datacontenttype: &apos;application/xml&apos;
        },
        ceCommonExtensions
      )
      assert(ceFullOtherContentTypeStrictBad !== null)
      t.ok(ceFullOtherContentTypeStrictBad)
      ceFullOtherContentTypeStrictBad.id = null // remove some mandatory attribute now, to let serialization fail
      t.ok(!ceFullOtherContentTypeStrictBad.isValid())
      const ceFullStrictBadSerializedOnlyValidFalse = CloudEvent.serializeEvent(ceFullOtherContentTypeStrictBad, {
        encodedData: ceDataAsXmlString,
        onlyValid: false
      })
      t.ok(ceFullStrictBadSerializedOnlyValidFalse)
      t.throws(function () {
        const ceFullStrictBadSerializedOnlyValidTrue = CloudEvent.serializeEvent(ceFullOtherContentTypeStrictBad, {
          encodedData: ceDataAsXmlString,
          onlyValid: true
        })
        assert(ceFullStrictBadSerializedOnlyValidTrue === null) // never executed
      }, Error, &apos;Expected exception when serializing a bad CloudEvent instance&apos;)
    }
  }
})

// sample encoding function, to use in tests here
function encoderToXmlSample (data) {
  // return ceDataAsXmlString
  // return data.toString()
  return &apos;&lt;data encoder=&quot;sample&quot; /&gt;&apos;
}

/** @test {CloudEvent} */
test(&apos;serialize a CloudEvent instance with a non default contenttype and right serialization options, expect success&apos;, (t) =&gt; {
  t.plan(28)

  const { CloudEvent, CloudEventValidator: V } = require(&apos;../src/&apos;)
  t.ok(CloudEvent)
  t.ok(encoderToXmlSample)
  t.ok(V.isFunction(encoderToXmlSample))
  t.ok(!V.ensureIsFunction(encoderToXmlSample, &apos;encoderToXmlSample&apos;)) // no error returned

  {
    // create an instance with non default contenttype (other options default): expected success ...
    // when I try to serialize specifying right serialization options, expect success ...
    const ceFullOtherContentType = new CloudEvent(&apos;1/non-default-contenttype/sample-data/no-strict&apos;,
      ceNamespace,
      ceServerUrl,
      ceCommonData, // data
      {
        ...ceCommonOptions,
        datacontenttype: &apos;application/xml&apos;
      },
      ceCommonExtensions
    )
    assert(ceFullOtherContentType !== null)
    t.ok(ceFullOtherContentType)
    t.ok(ceFullOtherContentType.isValid())
    // test different combinations of serialization options
    // note that if given, encoder function has priority over encoded data
    const cceFullOtherContentTypeSerialized1 = ceFullOtherContentType.serialize({
      encoder: encoderToXmlSample
    })
    t.ok(cceFullOtherContentTypeSerialized1)
    t.ok(CloudEvent.isValidEvent(ceFullOtherContentType))
    const cceFullOtherContentTypeSerialized2 = ceFullOtherContentType.serialize({
      encodedData: ceDataAsXmlString
    })
    t.ok(cceFullOtherContentTypeSerialized2)
    t.ok(CloudEvent.isValidEvent(ceFullOtherContentType))
    const fixedEncodedData = &apos;&lt;data &quot;fixed&quot;=&quot;encoded&quot; /&gt;&apos;
    const cceFullOtherContentTypeSerialized3 = ceFullOtherContentType.serialize({
      encoder: encoderToXmlSample,
      // encodedData: undefined
      // encodedData: null
      // encodedData: ceDataAsXmlString
      encodedData: fixedEncodedData
    })
    t.ok(cceFullOtherContentTypeSerialized3)
    t.ok(CloudEvent.isValidEvent(ceFullOtherContentType))
    const cceFullOtherContentTypeSerialized4 = CloudEvent.serializeEvent(ceFullOtherContentType, {
      encoder: encoderToXmlSample,
      encodedData: fixedEncodedData,
      onlyValid: false
    })
    t.ok(cceFullOtherContentTypeSerialized4)
    t.ok(CloudEvent.isValidEvent(ceFullOtherContentType))
    const cceFullOtherContentTypeSerialized5 = CloudEvent.serializeEvent(ceFullOtherContentType, {
      encoder: encoderToXmlSample,
      encodedData: fixedEncodedData,
      onlyValid: true
    })
    t.ok(cceFullOtherContentTypeSerialized5)
    t.ok(CloudEvent.isValidEvent(ceFullOtherContentType))
  }

  {
    // the same but with strict mode enabled ...
    // expect success even if content type is not default and data is not a string,
    // anyway use encoder/decoder to let serialization/deserialization work in this case (strict) ...
    const ceFullOtherContentTypeStrict = new CloudEvent(&apos;1/non-default-contenttype/sample-data/strict&apos;,
      ceNamespace,
      ceServerUrl,
      ceCommonData, // data
      {
        ...ceCommonOptionsStrict,
        datacontenttype: &apos;application/xml&apos;
      },
      ceCommonExtensions
    )
    assert(ceFullOtherContentTypeStrict !== null)
    t.ok(ceFullOtherContentTypeStrict)
    t.ok(ceFullOtherContentTypeStrict.isValid())
    // test different combinations of serialization options
    // note that if given, encoder function has priority over encoded data
    const ceFullOtherContentTypeStrictSerialized1 = ceFullOtherContentTypeStrict.serialize({
      encoder: encoderToXmlSample
    })
    t.ok(ceFullOtherContentTypeStrictSerialized1)
    t.ok(CloudEvent.isValidEvent(ceFullOtherContentTypeStrict))
    const ceFullOtherContentTypeStrictSerialized2 = ceFullOtherContentTypeStrict.serialize({
      encodedData: ceDataAsXmlString
    })
    t.ok(ceFullOtherContentTypeStrictSerialized2)
    t.ok(CloudEvent.isValidEvent(ceFullOtherContentTypeStrict))
    const fixedEncodedData = &apos;&lt;data &quot;fixed&quot;=&quot;encoded&quot; /&gt;&apos;
    const ceFullOtherContentTypeStrictSerialized3 = ceFullOtherContentTypeStrict.serialize({
      encoder: encoderToXmlSample,
      // encodedData: undefined
      // encodedData: null
      // encodedData: ceDataAsXmlString
      encodedData: fixedEncodedData
    })
    t.ok(ceFullOtherContentTypeStrictSerialized3)
    t.ok(CloudEvent.isValidEvent(ceFullOtherContentTypeStrict))
    const ceFullOtherContentTypeStrictSerialized4 = CloudEvent.serializeEvent(ceFullOtherContentTypeStrict, {
      encoder: encoderToXmlSample,
      encodedData: fixedEncodedData,
      onlyValid: false
    })
    t.ok(ceFullOtherContentTypeStrictSerialized4)
    t.ok(CloudEvent.isValidEvent(ceFullOtherContentTypeStrict))
    const ceFullOtherContentTypeStrictSerialized5 = CloudEvent.serializeEvent(ceFullOtherContentTypeStrict, {
      encoder: encoderToXmlSample,
      encodedData: fixedEncodedData,
      onlyValid: true
    })
    // note that onlyValid here is a check on transformed data ...
    t.ok(ceFullOtherContentTypeStrictSerialized5)
    t.ok(V.isStringNotEmpty(ceFullOtherContentTypeStrictSerialized5))
  }
})

// sample encoding function to JSON, to use in tests here
function encoderToJSON (data) {
  // return ceDataAsJSONString
  return JSON.stringify(data)
}

/** @test {CloudEvent} */
test(&apos;serialize a CloudEvent instance with a non default contenttype (but in the JSON-like family) and right serialization options, expect success&apos;, (t) =&gt; {
  t.plan(54)

  const { CloudEvent, CloudEventValidator: V } = require(&apos;../src/&apos;)
  t.ok(CloudEvent)
  t.ok(encoderToJSON)
  t.ok(V.isFunction(encoderToJSON))
  t.ok(!V.ensureIsFunction(encoderToJSON, &apos;encoderToJSON&apos;)) // no error returned

  {
    // create an instance with non default contenttype (other options default): expected success ...
    const ceFullOtherContentTypeJSON = new CloudEvent(&apos;1/non-default-contenttype-but-json/sample-data/no-strict&apos;,
      ceNamespace,
      ceServerUrl,
      ceCommonData, // data
      {
        ...ceCommonOptions,
        datacontenttype: &apos;text/json&apos;
      },
      ceCommonExtensions
    )
    assert(ceFullOtherContentTypeJSON !== null)
    t.ok(ceFullOtherContentTypeJSON)
    t.ok(ceFullOtherContentTypeJSON.isValid())
    t.ok(!ceFullOtherContentTypeJSON.isStrict)
    t.notStrictEqual(ceFullOtherContentTypeJSON.datacontenttype, CloudEvent.datacontenttypeDefault())
    t.ok(CloudEvent.isDatacontenttypeJSONEvent(ceFullOtherContentTypeJSON))

    // improve coverage on that method
    t.throws(function () {
      const dct = CloudEvent.isDatacontenttypeJSONEvent(undefined)
      assert(dct === false) // never executed
    }, Error, &apos;Expected exception when trying to get the data content type for an undefined/null CloudEvent instance&apos;)
    t.throws(function () {
      const dct = CloudEvent.isDatacontenttypeJSONEvent(null)
      assert(dct === false) // never executed
    }, Error, &apos;Expected exception when trying to get the data content type for an undefined/null CloudEvent instance&apos;)
    t.throws(function () {
      const dct = CloudEvent.isDatacontenttypeJSONEvent({})
      assert(dct === false) // never executed
    }, Error, &apos;Expected exception when trying to get the data content type for for not a CloudEvent instance&apos;)
    {
      const ce = ceFullOtherContentTypeJSON
      CloudEvent.setStrictExtensionInEvent(ce, false)
      const dct = CloudEvent.isDatacontenttypeJSONEvent(ce)
      t.strictSame(dct, true)
      t.strictSame(ce.isDatacontenttypeJSON, true)
    }
    {
      const ce = ceFullOtherContentTypeJSON
      CloudEvent.setStrictExtensionInEvent(ce, true)
      const dct = CloudEvent.isDatacontenttypeJSONEvent(ce)
      t.strictSame(dct, true)
      t.strictSame(ce.isDatacontenttypeJSON, true)
    }

    // when I try to serialize it without specifying serialization options, expect to have an error raised ...
    t.throws(function () {
      const ceFullOtherContentTypeSerialized = ceFullOtherContentTypeJSON.serialize()
      assert(ceFullOtherContentTypeSerialized === null) // never executed
    }, Error, &apos;Expected exception when serializing the current CloudEvent instance&apos;)
    t.throws(function () {
      const ceFullOtherContentTypeSerialized = CloudEvent.serializeEvent(ceFullOtherContentTypeJSON, {
        encoder: &apos;encoderToJSON&apos;
      })
      assert(ceFullOtherContentTypeSerialized === null) // never executed
    }, Error, &apos;Expected exception when serializing the current CloudEvent instance&apos;)
    t.throws(function () {
      const ceFullOtherContentTypeSerialized = CloudEvent.serializeEvent(ceFullOtherContentTypeJSON, {
        encodedData: true
      })
      assert(ceFullOtherContentTypeSerialized === null) // never executed
    }, Error, &apos;Expected exception when serializing the current CloudEvent instance&apos;)

    // when I try to serialize specifying right serialization options, expect success ...
    // test different combinations of serialization options
    // note that if given, encoder function has priority over encoded data
    const cceFullOtherContentTypeSerialized1 = ceFullOtherContentTypeJSON.serialize({
      encoder: encoderToJSON
    })
    t.ok(cceFullOtherContentTypeSerialized1)
    t.ok(CloudEvent.isValidEvent(ceFullOtherContentTypeJSON))
    const cceFullOtherContentTypeSerialized2 = ceFullOtherContentTypeJSON.serialize({
      encodedData: ceDataAsJSONString
    })
    t.ok(cceFullOtherContentTypeSerialized2)
    t.ok(CloudEvent.isValidEvent(ceFullOtherContentTypeJSON))
    const fixedEncodedData = { fixed: &apos;encoded&apos; }
    const cceFullOtherContentTypeSerialized3 = ceFullOtherContentTypeJSON.serialize({
      encoder: encoderToJSON,
      // encodedData: undefined
      // encodedData: null
      // encodedData: ceDataAsJSONString
      encodedData: fixedEncodedData
    })
    t.ok(cceFullOtherContentTypeSerialized3)
    t.ok(CloudEvent.isValidEvent(ceFullOtherContentTypeJSON))
    const cceFullOtherContentTypeSerialized4 = CloudEvent.serializeEvent(ceFullOtherContentTypeJSON, {
      encoder: encoderToJSON,
      encodedData: fixedEncodedData,
      onlyValid: false
    })
    t.ok(cceFullOtherContentTypeSerialized4)
    t.ok(CloudEvent.isValidEvent(ceFullOtherContentTypeJSON))
    const cceFullOtherContentTypeSerialized5 = CloudEvent.serializeEvent(ceFullOtherContentTypeJSON, {
      encoder: encoderToJSON,
      encodedData: fixedEncodedData,
      onlyValid: true
    })
    t.ok(cceFullOtherContentTypeSerialized5)
    t.ok(CloudEvent.isValidEvent(ceFullOtherContentTypeJSON))

    // the same for deserializtion ...
  }

  {
    // create an instance with non default contenttype (other options default): expected success ...
    const ceFullOtherContentTypeJSONStrict = new CloudEvent(&apos;1/non-default-contenttype-but-json/sample-data/strict&apos;,
      ceNamespace,
      ceServerUrl,
      ceCommonData, // data
      {
        ...ceCommonOptionsStrict,
        datacontenttype: &apos;text/json&apos;
      },
      ceCommonExtensions
    )
    assert(ceFullOtherContentTypeJSONStrict !== null)
    t.ok(ceFullOtherContentTypeJSONStrict)
    t.ok(ceFullOtherContentTypeJSONStrict.isValid())
    t.ok(ceFullOtherContentTypeJSONStrict.isStrict)
    t.notStrictEqual(ceFullOtherContentTypeJSONStrict.datacontenttype, CloudEvent.datacontenttypeDefault())
    t.ok(CloudEvent.isDatacontenttypeJSONEvent(ceFullOtherContentTypeJSONStrict))

    // improve coverage on that method
    t.throws(function () {
      const dct = CloudEvent.isDatacontenttypeJSONEvent(undefined)
      assert(dct === false) // never executed
    }, Error, &apos;Expected exception when trying to get the data content type for an undefined/null CloudEvent instance&apos;)
    t.throws(function () {
      const dct = CloudEvent.isDatacontenttypeJSONEvent(null)
      assert(dct === false) // never executed
    }, Error, &apos;Expected exception when trying to get the data content type for an undefined/null CloudEvent instance&apos;)
    t.throws(function () {
      const dct = CloudEvent.isDatacontenttypeJSONEvent({})
      assert(dct === false) // never executed
    }, Error, &apos;Expected exception when trying to get the data content type for for not a CloudEvent instance&apos;)
    {
      const ce = ceFullOtherContentTypeJSONStrict
      CloudEvent.setStrictExtensionInEvent(ce, false)
      const dct = CloudEvent.isDatacontenttypeJSONEvent(ce)
      t.strictSame(dct, true)
      t.strictSame(ce.isDatacontenttypeJSON, true)
    }
    {
      const ce = ceFullOtherContentTypeJSONStrict
      CloudEvent.setStrictExtensionInEvent(ce, true)
      const dct = CloudEvent.isDatacontenttypeJSONEvent(ce)
      t.strictSame(dct, true)
      t.strictSame(ce.isDatacontenttypeJSON, true)
    }

    // when I try to serialize it without specifying serialization options, expect to have an error raised ...
    t.throws(function () {
      const ceFullOtherContentTypeSerialized = ceFullOtherContentTypeJSONStrict.serialize()
      assert(ceFullOtherContentTypeSerialized === null) // never executed
    }, Error, &apos;Expected exception when serializing the current CloudEvent instance&apos;)
    t.throws(function () {
      const ceFullOtherContentTypeSerialized = CloudEvent.serializeEvent(ceFullOtherContentTypeJSONStrict, {
        encoder: &apos;encoderToJSON&apos;
      })
      assert(ceFullOtherContentTypeSerialized === null) // never executed
    }, Error, &apos;Expected exception when serializing the current CloudEvent instance&apos;)
    t.throws(function () {
      const ceFullOtherContentTypeSerialized = CloudEvent.serializeEvent(ceFullOtherContentTypeJSONStrict, {
        encodedData: true
      })
      assert(ceFullOtherContentTypeSerialized === null) // never executed
    }, Error, &apos;Expected exception when serializing the current CloudEvent instance&apos;)

    // when I try to serialize specifying right serialization options, expect success ...
    // test different combinations of serialization options
    // note that if given, encoder function has priority over encoded data
    const cceFullOtherContentTypeSerialized1 = ceFullOtherContentTypeJSONStrict.serialize({
      encoder: encoderToJSON
    })
    t.ok(cceFullOtherContentTypeSerialized1)
    t.ok(CloudEvent.isValidEvent(ceFullOtherContentTypeJSONStrict))
    const cceFullOtherContentTypeSerialized2 = ceFullOtherContentTypeJSONStrict.serialize({
      encodedData: ceDataAsJSONString
    })
    t.ok(cceFullOtherContentTypeSerialized2)
    t.ok(CloudEvent.isValidEvent(ceFullOtherContentTypeJSONStrict))
    const fixedEncodedData = { fixed: &apos;encoded&apos; }
    const cceFullOtherContentTypeSerialized3 = ceFullOtherContentTypeJSONStrict.serialize({
      encoder: encoderToJSON,
      // encodedData: undefined
      // encodedData: null
      // encodedData: ceDataAsJSONString
      encodedData: fixedEncodedData
    })
    t.ok(cceFullOtherContentTypeSerialized3)
    t.ok(CloudEvent.isValidEvent(ceFullOtherContentTypeJSONStrict))
    const cceFullOtherContentTypeSerialized4 = CloudEvent.serializeEvent(ceFullOtherContentTypeJSONStrict, {
      encoder: encoderToJSON,
      encodedData: fixedEncodedData,
      onlyValid: false
    })
    t.ok(cceFullOtherContentTypeSerialized4)
    t.ok(CloudEvent.isValidEvent(ceFullOtherContentTypeJSONStrict))
    const cceFullOtherContentTypeSerialized5 = CloudEvent.serializeEvent(ceFullOtherContentTypeJSONStrict, {
      encoder: encoderToJSON,
      encodedData: fixedEncodedData,
      onlyValid: true
    })
    t.ok(cceFullOtherContentTypeSerialized5)
    t.ok(CloudEvent.isValidEvent(ceFullOtherContentTypeJSONStrict))

    // the same for deserializtion ...
  }
})

/** @test {CloudEvent} */
test(&apos;ensure the JSON Schema for a CloudEvent (static and for a normal instance) is available&apos;, (t) =&gt; {
  t.plan(6)

  const { CloudEvent } = require(&apos;../src/&apos;)
  t.ok(CloudEvent)

  // get JSON Schema from a static method
  const jsonSchemaStatic = CloudEvent.getJSONSchema()
  assert(jsonSchemaStatic !== null)
  t.ok(jsonSchemaStatic)
  t.strictEqual(typeof jsonSchemaStatic, &apos;object&apos;)

  // create a sample CloudEvent instance ...
  const ceFullStrict = new CloudEvent(&apos;1/full/sample-data/strict&apos;,
    ceNamespace,
    ceServerUrl,
    ceCommonData, // data
    ceCommonOptionsStrict,
    ceCommonExtensions
  )
  assert(ceFullStrict !== null)
  t.ok(ceFullStrict)
  // get JSON Schema from that instance
  const jsonSchema = ceFullStrict.schema
  assert(jsonSchema !== null)
  t.ok(jsonSchema)
  t.strictEqual(typeof jsonSchema, &apos;object&apos;)
})

/** create some common data with nested attributes, for better reuse in tests */
const ceCommonNestedData = {
  ...ceCommonData,
  nested1: {
    level1attribute: &apos;level1attributeValue&apos;,
    nested2: {
      level2attribute: &apos;level2attributeValue&apos;,
      nested3: {
        level3attribute: &apos;level3attributeValue&apos;
      }
    }
  }
}

const { CloudEventTransformer: T } = require(&apos;../src/&apos;)
const ceNestedFullSerializedJson = `{&quot;id&quot;:&quot;1/full/sample-data-nested/no-strict&quot;,&quot;type&quot;:&quot;com.github.smartiniOnGitHub.cloudeventjs.testevent&quot;,&quot;source&quot;:&quot;/test&quot;,&quot;data&quot;:{&quot;hello&quot;:&quot;world&quot;,&quot;year&quot;:2020,&quot;nested1&quot;:{&quot;level1attribute&quot;:&quot;level1attributeValue&quot;,&quot;nested2&quot;:{&quot;level2attribute&quot;:&quot;level2attributeValue&quot;,&quot;nested3&quot;:{&quot;level3attribute&quot;:&quot;level3attributeValue&quot;}}}},&quot;specversion&quot;:&quot;1.0&quot;,&quot;datacontenttype&quot;:&quot;application/json&quot;,&quot;dataschema&quot;:&quot;http://my-schema.localhost.localdomain&quot;,&quot;time&quot;:&quot;${T.timestampToString(commonEventTime)}&quot;,&quot;subject&quot;:&quot;subject&quot;,&quot;exampleextension&quot;:&quot;value&quot;}`
const ceNestedFullStrictSerializedJson = `{&quot;id&quot;:&quot;1/full/sample-data-nested/strict&quot;,&quot;type&quot;:&quot;com.github.smartiniOnGitHub.cloudeventjs.testevent&quot;,&quot;source&quot;:&quot;/test&quot;,&quot;data&quot;:{&quot;hello&quot;:&quot;world&quot;,&quot;year&quot;:2020,&quot;nested1&quot;:{&quot;level1attribute&quot;:&quot;level1attributeValue&quot;,&quot;nested2&quot;:{&quot;level2attribute&quot;:&quot;level2attributeValue&quot;,&quot;nested3&quot;:{&quot;level3attribute&quot;:&quot;level3attributeValue&quot;}}}},&quot;specversion&quot;:&quot;1.0&quot;,&quot;datacontenttype&quot;:&quot;application/json&quot;,&quot;dataschema&quot;:&quot;http://my-schema.localhost.localdomain&quot;,&quot;time&quot;:&quot;${T.timestampToString(commonEventTime)}&quot;,&quot;subject&quot;:&quot;subject&quot;,&quot;strictvalidation&quot;:true,&quot;exampleextension&quot;:&quot;value&quot;}`
const ceFullOtherContentTypeSerializedJson = `{&quot;id&quot;:&quot;1/full/sample-data-nested/no-strict&quot;,&quot;type&quot;:&quot;com.github.smartiniOnGitHub.cloudeventjs.testevent&quot;,&quot;source&quot;:&quot;/test&quot;,&quot;data&quot;:&quot;&lt;data &apos;hello&apos;=&apos;world&apos; &apos;year&apos;=&apos;2020&apos; /&gt;&quot;,&quot;specversion&quot;:&quot;1.0&quot;,&quot;datacontenttype&quot;:&quot;application/xml&quot;,&quot;time&quot;:&quot;${T.timestampToString(commonEventTime)}&quot;,&quot;exampleextension&quot;:&quot;value&quot;,&quot;dataschema&quot;:&quot;http://my-schema.localhost.localdomain&quot;}`
const ceFullOtherContentTypeStrictSerializedJson = `{&quot;id&quot;:&quot;1/full/sample-data-nested/strict&quot;,&quot;type&quot;:&quot;com.github.smartiniOnGitHub.cloudeventjs.testevent&quot;,&quot;source&quot;:&quot;/test&quot;,&quot;data&quot;:&quot;&lt;data &apos;hello&apos;=&apos;world&apos; &apos;year&apos;=&apos;2020&apos; /&gt;&quot;,&quot;specversion&quot;:&quot;1.0&quot;,&quot;datacontenttype&quot;:&quot;application/xml&quot;,&quot;time&quot;:&quot;${T.timestampToString(commonEventTime)}&quot;,&quot;exampleextension&quot;:&quot;value&quot;,&quot;strictvalidation&quot;:true,&quot;dataschema&quot;:&quot;http://my-schema.localhost.localdomain&quot;}`
const ceFullOtherContentTypeSerializedBadJson = `{&quot;data&quot;:&quot;&lt;data &apos;hello&apos;=&apos;world&apos; &apos;year&apos;=&apos;2020&apos; /&gt;&quot;,&quot;datacontenttype&quot;:&quot;application/xml&quot;,&quot;time&quot;:&quot;${T.timestampToString(commonEventTime)}&quot;,&quot;exampleextension&quot;:&quot;value&quot;}`
const ceFullOtherContentTypeStrictSerializedBadJson = `{&quot;data&quot;:&quot;&lt;data &apos;hello&apos;=&apos;world&apos; &apos;year&apos;=&apos;2020&apos; /&gt;&quot;,&quot;datacontenttype&quot;:&quot;application/xml&quot;,&quot;time&quot;:&quot;${T.timestampToString(commonEventTime)}&quot;,&quot;exampleextension&quot;:&quot;value&quot;,&quot;strictvalidation&quot;:true}`

/** @test {CloudEvent} */
test(&apos;serialize some CloudEvent instances to JSON with nested data, and ensure they are right&apos;, (t) =&gt; {
  t.plan(52)

  const { CloudEvent } = require(&apos;../src/&apos;)
  // t.ok(CloudEvent)

  {
    const ceFull = new CloudEvent(&apos;1/full/sample-data-nested/no-strict&apos;,
      ceNamespace,
      ceServerUrl,
      ceCommonNestedData, // data
      ceCommonOptions,
      ceCommonExtensions
    )
    assert(ceFull !== null)
    t.ok(ceFull)
    t.ok(ceFull.isValid())
    t.ok(ceFull.validate().length === 0)
    t.ok(ceFull.validate({ strict: false }).length === 0)
    t.ok(ceFull.validate({ strict: true }).length === 0)
    t.ok(CloudEvent.isValidEvent(ceFull))
    t.ok(CloudEvent.validateEvent(ceFull).length === 0)
    t.ok(CloudEvent.validateEvent(ceFull, { strict: false }).length === 0)
    t.ok(CloudEvent.validateEvent(ceFull, { strict: true }).length === 0)

    const ceFullSerializedStatic = CloudEvent.serializeEvent(ceFull)
    t.ok(ceFullSerializedStatic)
    const ceFullSerialized = ceFull.serialize()
    t.ok(ceFullSerialized)
    assert(ceFullSerializedStatic === ceFullSerialized)
    t.strictSame(ceFullSerializedStatic, ceFullSerialized)
    const ceSerialize = CloudEvent.serializeEvent
    assert(ceSerialize !== null)
    t.ok(ceSerialize)
    const ceFullSerializedFunction = ceSerialize(ceFull)
    t.ok(ceFullSerializedFunction)
    t.strictSame(ceFullSerializedFunction, ceFullSerializedStatic)
    t.strictSame(ceFullSerializedFunction, ceFullSerialized)

    const ceFullSerializedOnlyValidFalse = ceSerialize(ceFull, { onlyValid: false })
    t.ok(ceFullSerializedOnlyValidFalse)
    const ceFullSerializedOnlyValidTrue = ceSerialize(ceFull, { onlyValid: true })
    t.ok(ceFullSerializedOnlyValidTrue)

    const ceFullSerializedComparison = ceNestedFullSerializedJson
    t.strictSame(ceFullSerialized, ceFullSerializedComparison)
    const ceFullDeserialized = JSON.parse(ceFullSerialized) // note that some fields (like dates) will be different when deserialized in this way ...
    ceFullDeserialized.time = commonEventTime // quick fix for the Date/timestamp attribute in the deserialized object
    ceFullDeserialized.data_base64 = undefined // quick fix for this not so common attribute in the deserialized object
    t.same(ceFull, ceFullDeserialized)

    // ensure payload data is a copy of event data
    let dataShallowClone = ceFull.payload
    // then ensure they are different object (references) ...
    assert(dataShallowClone !== null)
    assert(dataShallowClone !== ceFull.data) // they must be different object references
    assert(dataShallowClone !== ceFull.payload) // they must be different object references, at any invocation
    t.notEqual(dataShallowClone, ceFull.data)
    t.notStrictEqual(dataShallowClone, ceFull.data)
    t.notEqual(dataShallowClone, ceFull.payload)
    dataShallowClone = &apos;changed: true&apos; // reassign to test that data won&apos;t be affected by that change
    t.notEqual(dataShallowClone, ceFull.data)
    t.strictNotSame(dataShallowClone, ceFull.data)
    t.notEqual(dataShallowClone, ceFull.payload)
  }

  {
    // the same but with strict mode enabled ...
    const ceFullStrict = new CloudEvent(&apos;1/full/sample-data-nested/strict&apos;,
      ceNamespace,
      ceServerUrl,
      ceCommonNestedData, // data
      ceCommonOptionsStrict,
      ceCommonExtensions
    )
    assert(ceFullStrict !== null)
    t.ok(ceFullStrict)
    t.ok(ceFullStrict.isValid())
    t.ok(ceFullStrict.validate().length === 0)
    t.ok(ceFullStrict.validate({ strict: true }).length === 0)
    t.ok(ceFullStrict.validate({ strict: false }).length === 0)
    t.ok(CloudEvent.isValidEvent(ceFullStrict))
    t.ok(CloudEvent.validateEvent(ceFullStrict).length === 0)
    t.ok(CloudEvent.validateEvent(ceFullStrict, { strict: true }).length === 0)
    t.ok(CloudEvent.validateEvent(ceFullStrict, { strict: false }).length === 0)

    const ceFullStrictSerializedStatic = CloudEvent.serializeEvent(ceFullStrict)
    t.ok(ceFullStrictSerializedStatic)
    const ceFullStrictSerialized = ceFullStrict.serialize()
    t.ok(ceFullStrictSerialized)
    assert(ceFullStrictSerializedStatic === ceFullStrictSerialized)
    t.strictSame(ceFullStrictSerializedStatic, ceFullStrictSerialized)
    const ceSerialize = CloudEvent.serializeEvent
    assert(ceSerialize !== null)
    t.ok(ceSerialize)
    const ceFullStrictSerializedFunction = ceSerialize(ceFullStrict)
    t.ok(ceFullStrictSerializedFunction)
    t.strictSame(ceFullStrictSerializedFunction, ceFullStrictSerializedStatic)
    t.strictSame(ceFullStrictSerializedFunction, ceFullStrictSerialized)

    const ceFullStrictSerializedOnlyValidFalse = ceSerialize(ceFullStrict, { onlyValid: false })
    t.ok(ceFullStrictSerializedOnlyValidFalse)
    const ceFullStrictSerializedOnlyValidTrue = ceSerialize(ceFullStrict, { onlyValid: true })
    t.ok(ceFullStrictSerializedOnlyValidTrue)

    const ceFullStrictSerializedComparison = ceNestedFullStrictSerializedJson
    t.strictSame(ceFullStrictSerialized, ceFullStrictSerializedComparison)
    const ceFullStrictDeserialized = JSON.parse(ceFullStrictSerialized) // note that some fields (like dates) will be different when deserialized in this way ...
    ceFullStrictDeserialized.time = commonEventTime // quick fix for the Date/timestamp attribute in the deserialized object
    ceFullStrictDeserialized.data_base64 = undefined // quick fix for this not so common attribute in the deserialized object
    t.same(ceFullStrict, ceFullStrictDeserialized)

    // ensure payload data is a copy of event data
    let dataShallowCloneStrict = ceFullStrict.payload
    // then ensure they are different object (references) ...
    assert(dataShallowCloneStrict !== null)
    assert(dataShallowCloneStrict !== ceFullStrict.data) // they must be different object references
    assert(dataShallowCloneStrict !== ceFullStrict.payload) // they must be different object references, at any invocation
    t.notEqual(dataShallowCloneStrict, ceFullStrict.data)
    t.notStrictEqual(dataShallowCloneStrict, ceFullStrict.data)
    t.notEqual(dataShallowCloneStrict, ceFullStrict.payload)
    dataShallowCloneStrict = &apos;changed: true&apos; // reassign to test that data won&apos;t be affected by that change
    t.notEqual(dataShallowCloneStrict, ceFullStrict.data)
    t.strictNotSame(dataShallowCloneStrict, ceFullStrict.data)
    t.notEqual(dataShallowCloneStrict, ceFullStrict.payload)
  }
})

/** @test {CloudEvent} */
test(&apos;deserialize generic strings (not JSON representation for an Object) into a CloudEvent instance, expected Errors&apos;, (t) =&gt; {
  t.plan(10)

  const { CloudEvent } = require(&apos;../src/&apos;) // get references via destructuring
  t.ok(CloudEvent)

  t.throws(function () {
    const deserialized = CloudEvent.deserializeEvent()
    assert(deserialized === null) // never executed
  }, Error, &apos;Expected exception when deserializing an undefined reference&apos;)
  t.throws(function () {
    const deserialized = CloudEvent.deserializeEvent(undefined)
    assert(deserialized === null) // never executed
  }, Error, &apos;Expected exception when deserializing an undefined reference&apos;)
  t.throws(function () {
    const deserialized = CloudEvent.deserializeEvent(null)
    assert(deserialized === null) // never executed
  }, Error, &apos;Expected exception when deserializing a null reference&apos;)
  t.throws(function () {
    const deserialized = CloudEvent.deserializeEvent(&apos;&apos;)
    assert(deserialized === null) // never executed
  }, Error, &apos;Expected exception when deserializing an empty string&apos;)
  t.throws(function () {
    const deserialized = CloudEvent.deserializeEvent(&apos;sample string&apos;)
    assert(deserialized === null) // never executed
  }, Error, &apos;Expected exception when deserializing a string not representing an object (in JSON)&apos;)
  t.throws(function () {
    const deserialized = CloudEvent.deserializeEvent(&apos;{ sample string, not a valid json }&apos;)
    assert(deserialized === null) // never executed
  }, Error, &apos;Expected exception when deserializing a string not representing an object (in JSON)&apos;)
  t.throws(function () {
    const deserialized = CloudEvent.deserializeEvent(&apos;[ &quot;sample array/list&quot;, &quot;of&quot;, &quot;values&quot; ]&apos;)
    assert(deserialized === null) // never executed
  }, Error, &apos;Expected exception when deserializing a string representing an array (in JSON)&apos;)
  t.throws(function () {
    const deserialized = CloudEvent.deserializeEvent(&apos;{ sample string, not a valid json }&apos;, { onlyValid: false })
    assert(deserialized === null) // never executed
  }, Error, &apos;Expected exception when deserializing a string not representing an object (in JSON)&apos;)
  t.throws(function () {
    const deserialized = CloudEvent.deserializeEvent(&apos;{ sample string, not a valid json }&apos;, { onlyValid: true })
    assert(deserialized === null) // never executed
  }, Error, &apos;Expected exception when deserializing a string not representing an object (in JSON)&apos;)
})

/** @test {CloudEvent} */
test(&apos;deserialize some CloudEvent instances from JSON, and ensure built instances are right&apos;, (t) =&gt; {
  t.plan(56)

  const { CloudEvent, CloudEventValidator: V } = require(&apos;../src/&apos;) // get references via destructuring

  {
    const serialized = ceNestedFullSerializedJson
    // console.log(`DEBUG - serialized cloudEvent details: serialized = &apos;${serialized}&apos;`)
    t.ok(serialized)
    t.ok(V.isString(serialized))

    const ceDeserialized = CloudEvent.deserializeEvent(serialized)
    assert(ceDeserialized !== null)
    // console.log(`DEBUG - cloudEvent type: ${typeof ceDeserialized}`)
    // console.log(`DEBUG - cloudEvent details: ceDeserialized = ${JSON.stringify(ceDeserialized)}`)
    // console.log(`DEBUG - cloudEvent details: ${T.dumpObject(ceDeserialized, &apos;ceDeserialized&apos;)}`)
    // console.log(`DEBUG - cloudEvent validation: ${ceDeserialized.validate()}`)
    // console.log(`DEBUG - cloudEvent validation (strict): ${ceDeserialized.validate({ strict: true })}`)
    t.ok(ceDeserialized)
    t.ok(V.isClass(ceDeserialized, CloudEvent))
    t.ok(ceDeserialized.isValid())
    t.ok(ceDeserialized.validate().length === 0)
    t.ok(ceDeserialized.validate({ strict: false }).length === 0)
    t.ok(ceDeserialized.validate({ strict: true }).length === 0)
    t.ok(CloudEvent.isValidEvent(ceDeserialized))
    t.ok(CloudEvent.validateEvent(ceDeserialized).length === 0)
    t.ok(CloudEvent.validateEvent(ceDeserialized, { strict: false }).length === 0)
    t.ok(CloudEvent.validateEvent(ceDeserialized, { strict: true }).length === 0)
    t.ok(CloudEvent.isCloudEvent(ceDeserialized))

    // inspect content of deserialized CloudEvent, at least on some attributes
    t.ok(ceDeserialized.time)
    t.ok(V.isDate(ceDeserialized.time))
    t.ok(V.isDateValid(ceDeserialized.time))
    t.ok(V.isDatePast(ceDeserialized.time))
    t.strictSame(ceDeserialized.time.getTime(), commonEventTime.getTime())
    t.notStrictEqual(ceDeserialized.time, commonEventTime)
    t.notEqual(ceDeserialized.time, commonEventTime)
    // console.log(`DEBUG - cloudEvent data: ${T.dumpObject(ceDeserialized.data, &apos;ceDeserialized.data&apos;)}`)
    // console.log(`DEBUG - cloudEvent payload: ${T.dumpObject(ceDeserialized.payload, &apos;ceDeserialized.payload&apos;)}`)
    t.ok(ceDeserialized.data)
    t.ok(V.isObject(ceDeserialized.data))
    t.ok(ceDeserialized.payload)
    t.ok(V.isObject(ceDeserialized.payload))
    // then ensure the value of both are the same ...
    t.strictSame(ceDeserialized.data, ceDeserialized.payload)
    // then ensure they are different object (references) ...
    t.notStrictEqual(ceDeserialized.data, ceDeserialized.payload)
    t.notEqual(ceDeserialized.data, ceDeserialized.payload)
    t.ok(!ceDeserialized.isStrict)
  }

  {
    // the same but with strict mode enabled ...
    const serialized = ceNestedFullStrictSerializedJson
    // console.log(`DEBUG - serialized cloudEvent details: serialized = &apos;${serialized}&apos;`)
    t.ok(serialized)
    t.ok(V.isString(serialized))

    const ceDeserialized = CloudEvent.deserializeEvent(serialized)
    assert(ceDeserialized !== null)
    // console.log(`DEBUG - cloudEvent type: ${typeof ceDeserialized}`)
    // console.log(`DEBUG - cloudEvent details: ceDeserialized = ${JSON.stringify(ceDeserialized)}`)
    // console.log(`DEBUG - cloudEvent details: ${T.dumpObject(ceDeserialized, &apos;ceDeserialized&apos;)}`)
    // console.log(`DEBUG - cloudEvent validation: ${ceDeserialized.validate()}`)
    // console.log(`DEBUG - cloudEvent validation (strict): ${ceDeserialized.validate({ strict: true })}`)
    t.ok(ceDeserialized)
    t.ok(V.isClass(ceDeserialized, CloudEvent))
    t.ok(ceDeserialized.isValid())
    t.ok(ceDeserialized.validate().length === 0)
    t.ok(ceDeserialized.validate({ strict: false }).length === 0)
    t.ok(ceDeserialized.validate({ strict: true }).length === 0)
    t.ok(CloudEvent.isValidEvent(ceDeserialized))
    t.ok(CloudEvent.validateEvent(ceDeserialized).length === 0)
    t.ok(CloudEvent.validateEvent(ceDeserialized, { strict: false }).length === 0)
    t.ok(CloudEvent.validateEvent(ceDeserialized, { strict: true }).length === 0)
    t.ok(CloudEvent.isCloudEvent(ceDeserialized))

    // inspect content of deserialized CloudEvent, at least on some attributes
    t.ok(ceDeserialized.time)
    t.ok(V.isDate(ceDeserialized.time))
    t.ok(V.isDateValid(ceDeserialized.time))
    t.ok(V.isDatePast(ceDeserialized.time))
    t.strictSame(ceDeserialized.time.getTime(), commonEventTime.getTime())
    t.notStrictEqual(ceDeserialized.time, commonEventTime)
    t.notEqual(ceDeserialized.time, commonEventTime)
    // console.log(`DEBUG - cloudEvent data: ${T.dumpObject(ceDeserialized.data, &apos;ceDeserialized.data&apos;)}`)
    // console.log(`DEBUG - cloudEvent payload: ${T.dumpObject(ceDeserialized.payload, &apos;ceDeserialized.payload&apos;)}`)
    t.ok(ceDeserialized.data)
    t.ok(V.isObject(ceDeserialized.data))
    t.ok(ceDeserialized.payload)
    t.ok(V.isObject(ceDeserialized.payload))
    // then ensure the value of both are the same ...
    t.strictSame(ceDeserialized.data, ceDeserialized.payload)
    // then ensure they are different object (references) ...
    t.notStrictEqual(ceDeserialized.data, ceDeserialized.payload)
    t.notEqual(ceDeserialized.data, ceDeserialized.payload)
    t.ok(ceDeserialized.isStrict)
  }
})

/** @test {CloudEvent} */
test(&apos;deserialize a CloudEvent instance with a non default contenttype and empty/wrong deserialization options, expect error&apos;, (t) =&gt; {
  t.plan(18)

  const { CloudEvent, CloudEventValidator: V } = require(&apos;../src/&apos;) // get references via destructuring

  {
    const serialized = ceFullOtherContentTypeSerializedJson
    // console.log(`DEBUG - serialized cloudEvent details: serialized = &apos;${serialized}&apos;`)
    t.ok(serialized)
    t.ok(V.isString(serialized))

    t.throws(function () {
      const ceFullOtherContentTypeDeserialized = CloudEvent.deserializeEvent(serialized)
      assert(ceFullOtherContentTypeDeserialized === null) // never executed
    }, Error, &apos;Expected exception when deserializing the current CloudEvent instance&apos;)
    t.throws(function () {
      const ceFullOtherContentTypeDeserialized = CloudEvent.deserializeEvent(serialized, {
        decoder: &apos;decoderFromXmlSample&apos; // bad decoder function
      })
      assert(ceFullOtherContentTypeDeserialized === null) // never executed
    }, Error, &apos;Expected exception when deserializing the current CloudEvent instance&apos;)
    t.throws(function () {
      const ceFullOtherContentTypeDeserialized = CloudEvent.deserializeEvent(serialized, {
        decodedData: true // bad decoded data
      })
      assert(ceFullOtherContentTypeDeserialized === null) // never executed
    }, Error, &apos;Expected exception when deserializing the current CloudEvent instance&apos;)
    t.throws(function () {
      const ceFullOtherContentTypeDeserialized = CloudEvent.deserializeEvent(serialized, {
        decodedData: ceDataAsXmlString,
        onlyValid: false
      })
      assert(ceFullOtherContentTypeDeserialized === null) // bad assertion
    }, Error, &apos;Expected exception due to a bad assertion&apos;)
    t.throws(function () {
      const ceFullOtherContentTypeDeserialized = CloudEvent.deserializeEvent(serialized, {
        decodedData: ceDataAsXmlString,
        onlyValid: true
      })
      assert(ceFullOtherContentTypeDeserialized === null) // bad assertion
    }, Error, &apos;Expected exception due to a bad assertion&apos;)
    t.throws(function () {
      const ceFullOtherContentTypeDeserialized = CloudEvent.deserializeEvent(ceFullOtherContentTypeSerializedBadJson, {
        decodedData: ceDataAsXmlString,
        onlyValid: false
      })
      assert(ceFullOtherContentTypeDeserialized === null) // never executed
    }, Error, &apos;Expected exception when deserializing the current CloudEvent instance&apos;)
    t.throws(function () {
      const ceFullOtherContentTypeDeserialized = CloudEvent.deserializeEvent(ceFullOtherContentTypeSerializedBadJson, {
        decodedData: ceDataAsXmlString,
        onlyValid: true
      })
      assert(ceFullOtherContentTypeDeserialized === null) // never executed
    }, Error, &apos;Expected exception when deserializing the current CloudEvent instance&apos;)
  }

  {
    // the same but with strict mode enabled ...
    const serialized = ceFullOtherContentTypeStrictSerializedJson
    // console.log(`DEBUG - serialized cloudEvent details: serialized = &apos;${serialized}&apos;`)
    t.ok(serialized)
    t.ok(V.isString(serialized))

    t.throws(function () {
      const ceFullOtherContentTypeDeserialized = CloudEvent.deserializeEvent(serialized, {
        decoder: null,
        decodedData: null
      })
      assert(ceFullOtherContentTypeDeserialized === null) // never executed
    }, Error, &apos;Expected exception when deserializing the current CloudEvent instance&apos;)
    t.throws(function () {
      const ceFullOtherContentTypeDeserialized = CloudEvent.deserializeEvent(serialized, {
        decoder: &apos;decoderFromXmlSample&apos; // bad decoder function
      })
      assert(ceFullOtherContentTypeDeserialized === null) // never executed
    }, Error, &apos;Expected exception when deserializing the current CloudEvent instance&apos;)
    t.throws(function () {
      const ceFullOtherContentTypeDeserialized = CloudEvent.deserializeEvent(serialized, {
        decodedData: true // bad decoder data
      })
      assert(ceFullOtherContentTypeDeserialized === null) // never executed
    }, Error, &apos;Expected exception when deserializing the current CloudEvent instance&apos;)
    t.throws(function () {
      const ceFullOtherContentTypeDeserialized = CloudEvent.deserializeEvent(serialized, {
        decodedData: ceDataAsXmlString,
        onlyValid: false
      })
      assert(ceFullOtherContentTypeDeserialized === null) // bad assertion
    }, Error, &apos;Expected exception due to a bad assertion&apos;)
    t.throws(function () {
      const ceFullOtherContentTypeDeserialized = CloudEvent.deserializeEvent(serialized, {
        decodedData: ceDataAsXmlString,
        onlyValid: true
      })
      assert(ceFullOtherContentTypeDeserialized === null) // bad assertion
    }, Error, &apos;Expected exception due to a bad assertion&apos;)
    t.throws(function () {
      const ceFullOtherContentTypeDeserialized = CloudEvent.deserializeEvent(ceFullOtherContentTypeStrictSerializedBadJson, {
        decodedData: ceDataAsXmlString,
        onlyValid: false
      })
      assert(ceFullOtherContentTypeDeserialized === null) // never executed
    }, Error, &apos;Expected exception when deserializing the current CloudEvent instance&apos;)
    t.throws(function () {
      const ceFullOtherContentTypeDeserialized = CloudEvent.deserializeEvent(ceFullOtherContentTypeStrictSerializedBadJson, {
        decodedData: ceDataAsXmlString,
        onlyValid: true
      })
      assert(ceFullOtherContentTypeDeserialized === null) // never executed
    }, Error, &apos;Expected exception when deserializing the current CloudEvent instance&apos;)
  }
})

// sample decoding function, to use in tests here
function decoderFromXmlSample (data) {
  // return ceCommonData
  // return data.toString()
  return &apos;&lt;data &quot;decoded&quot;=&quot;Sample&quot; /&gt;&apos;
}

/** @test {CloudEvent} */
test(&apos;deserialize a CloudEvent instance with a non default contenttype and right deserialization options, expect success&apos;, (t) =&gt; {
  t.plan(18)

  const { CloudEvent, CloudEventValidator: V } = require(&apos;../src/&apos;) // get references via destructuring
  t.ok(V)
  t.ok(decoderFromXmlSample)
  t.ok(V.isFunction(decoderFromXmlSample))
  t.ok(!V.ensureIsFunction(decoderFromXmlSample, &apos;decoderFromXmlSample&apos;)) // no error returned

  {
    const serialized = ceFullOtherContentTypeSerializedJson
    // console.log(`DEBUG - serialized cloudEvent details: serialized = &apos;${serialized}&apos;`)
    t.ok(serialized)
    t.ok(V.isString(serialized))

    // test different combinations of deserialization options
    // note that if given, decoder function has priority over decoded data
    const ceFullOtherContentTypeDeserialized1 = CloudEvent.deserializeEvent(serialized, {
      decoder: decoderFromXmlSample
    })
    t.ok(ceFullOtherContentTypeDeserialized1)
    const fixedDecodedData = &apos;&lt;data &quot;fixed&quot;=&quot;decoded&quot; /&gt;&apos;
    const ceFullOtherContentTypeDeserialized2 = CloudEvent.deserializeEvent(serialized, {
      decodedData: fixedDecodedData
    })
    t.ok(ceFullOtherContentTypeDeserialized2)
    const ceFullOtherContentTypeDeserialized3 = CloudEvent.deserializeEvent(serialized, {
      decoder: decoderFromXmlSample,
      // decodedData: undefined
      // decodedData: null
      // decodedData: ceCommonData
      decodedData: fixedDecodedData
    })
    t.ok(ceFullOtherContentTypeDeserialized3)
    const ceFullOtherContentTypeDeserialized4 = CloudEvent.deserializeEvent(serialized, {
      decoder: decoderFromXmlSample,
      decodedData: fixedDecodedData,
      onlyValid: false
    })
    t.ok(ceFullOtherContentTypeDeserialized4)
    const ceFullOtherContentTypeDeserialized5 = CloudEvent.deserializeEvent(serialized, {
      decoder: decoderFromXmlSample,
      decodedData: fixedDecodedData,
      onlyValid: true
    })
    t.ok(ceFullOtherContentTypeDeserialized5)
  }

  {
    // the same but with strict mode enabled ...
    const serialized = ceFullOtherContentTypeStrictSerializedJson
    // console.log(`DEBUG - serialized cloudEvent details: serialized = &apos;${serialized}&apos;`)
    t.ok(serialized)
    t.ok(V.isString(serialized))

    // test different combinations of deserialization options
    // note that if given, decoder function has priority over decoded data
    const ceFullOtherContentTypeDeserialized1 = CloudEvent.deserializeEvent(serialized, {
      decoder: decoderFromXmlSample
    })
    t.ok(ceFullOtherContentTypeDeserialized1)
    const fixedDecodedData = &apos;&lt;data &quot;fixed&quot;=&quot;decoded&quot; /&gt;&apos;
    const ceFullOtherContentTypeDeserialized2 = CloudEvent.deserializeEvent(serialized, {
      decodedData: fixedDecodedData
    })
    t.ok(ceFullOtherContentTypeDeserialized2)
    const ceFullOtherContentTypeDeserialized3 = CloudEvent.deserializeEvent(serialized, {
      decoder: decoderFromXmlSample,
      // decodedData: undefined
      // decodedData: null
      // decodedData: ceCommonData
      decodedData: fixedDecodedData
    })
    t.ok(ceFullOtherContentTypeDeserialized3)
    const ceFullOtherContentTypeDeserialized4 = CloudEvent.deserializeEvent(serialized, {
      decoder: decoderFromXmlSample,
      decodedData: fixedDecodedData,
      onlyValid: false
    })
    t.ok(ceFullOtherContentTypeDeserialized4)
    const ceFullOtherContentTypeDeserialized5 = CloudEvent.deserializeEvent(serialized, {
      decoder: decoderFromXmlSample,
      decodedData: fixedDecodedData,
      onlyValid: true
    })
    t.ok(ceFullOtherContentTypeDeserialized5)
  }
})

/** @test {CloudEvent} */
test(&apos;serialize and deserialize a big CloudEvent instance (more than 64 KB)&apos;, (t) =&gt; {
  t.plan(55)

  const { CloudEvent } = require(&apos;../src/&apos;) // get references via destructuring
  t.ok(CloudEvent)

  t.ok(ceBigString)
  t.strictSame(ceBigString.length, ceBigStringLength)

  {
    const ceFull = new CloudEvent(&apos;1/full/sample-data-nested/no-strict&apos;,
      ceNamespace,
      ceServerUrl,
      { random: ceBigString }, // data
      ceCommonOptions,
      ceCommonExtensions
    )
    assert(ceFull !== null)
    t.ok(ceFull)
    t.ok(ceFull.isValid())
    t.ok(ceFull.validate().length === 0)
    t.ok(ceFull.validate({ strict: false }).length === 0)
    t.ok(ceFull.validate({ strict: true }).length === 0)
    t.ok(CloudEvent.isValidEvent(ceFull))
    t.ok(CloudEvent.validateEvent(ceFull).length === 0)
    t.ok(CloudEvent.validateEvent(ceFull, { strict: false }).length === 0)
    t.ok(CloudEvent.validateEvent(ceFull, { strict: true }).length === 0)

    // with defaults
    const ceFullSerializedStatic = CloudEvent.serializeEvent(ceFull)
    t.ok(ceFullSerializedStatic)
    const ceFullDeserializedStatic = CloudEvent.deserializeEvent(ceFullSerializedStatic)
    t.ok(ceFullDeserializedStatic)
    const ceFullSerialized = ceFull.serialize()
    t.ok(ceFullSerialized)
    const ceFullDeserialized = CloudEvent.deserializeEvent(ceFullSerialized)
    t.ok(ceFullDeserialized)
    assert(ceFullSerializedStatic === ceFullSerialized)
    t.strictSame(ceFullSerializedStatic, ceFullSerialized)

    // set some flags
    const ceFullSerializedOnlyValidFalse = CloudEvent.serializeEvent(ceFull, { onlyValid: false, onlyIfLessThan64KB: false })
    t.ok(ceFullSerializedOnlyValidFalse)
    const ceFullDeserializedOnlyValidFalse = CloudEvent.deserializeEvent(ceFullSerializedOnlyValidFalse)
    t.ok(ceFullDeserializedOnlyValidFalse)
    const ceFullSerializedOnlyValidTrue = CloudEvent.serializeEvent(ceFull, { onlyValid: true, onlyIfLessThan64KB: false })
    t.ok(ceFullSerializedOnlyValidTrue)
    const ceFullDeserializedOnlyValidTrue = CloudEvent.deserializeEvent(ceFullSerializedOnlyValidTrue)
    t.ok(ceFullDeserializedOnlyValidTrue)
    t.strictSame(ceFullSerializedOnlyValidFalse, ceFullSerializedOnlyValidTrue)

    // enable the flag to return the serialized string only if it&apos;s less than 64 KB, expected errors here
    t.throws(function () {
      const serialized = CloudEvent.serializeEvent(ceFull, { onlyValid: false, onlyIfLessThan64KB: true })
      assert(serialized === null) // never executed
    }, Error, &apos;Expected exception when serializing a Cloudevent bigger than 64 KB (with the flag to forbid it enabled)&apos;)
    t.throws(function () {
      const serialized = CloudEvent.serializeEvent(ceFull, { onlyValid: true, onlyIfLessThan64KB: true })
      assert(serialized === null) // never executed
    }, Error, &apos;Expected exception when serializing a Cloudevent bigger than 64 KB (with the flag to forbid it enabled)&apos;)
    // deserialize instances just serialized, but now with the flag enabled, so expect errors here
    t.throws(function () {
      const deserialized = CloudEvent.deserializeEvent(ceFullSerializedOnlyValidFalse, { onlyValid: false, onlyIfLessThan64KB: true })
      assert(deserialized === null) // never executed
    }, Error, &apos;Expected exception when deserializing a Cloudevent bigger than 64 KB (with the flag to forbid it enabled)&apos;)
    t.throws(function () {
      const deserialized = CloudEvent.deserializeEvent(ceFullSerializedOnlyValidTrue, { onlyValid: true, onlyIfLessThan64KB: true })
      assert(deserialized === null) // never executed
    }, Error, &apos;Expected exception when deserializing a Cloudevent bigger than 64 KB (with the flag to forbid it enabled)&apos;)
  }

  {
    const ceFullBadBig = new CloudEvent(null,
      ceNamespace,
      ceServerUrl,
      { random: ceBigString }, // data
      ceCommonOptions,
      ceCommonExtensions
    )
    assert(ceFullBadBig !== null)
    t.ok(ceFullBadBig)
    const serialized = CloudEvent.serializeEvent(ceFullBadBig, { onlyValid: false, onlyIfLessThan64KB: false })
    t.throws(function () {
      const deserialized = CloudEvent.deserializeEvent(serialized, { onlyValid: true })
      assert(deserialized === null) // never executed
    }, Error, &apos;Expected exception when deserializing a not valid big Cloudevent, with related flag enabled&apos;)
    t.throws(function () {
      const deserialized = CloudEvent.deserializeEvent(serialized, { onlyValid: false, onlyIfLessThan64KB: true })
      assert(deserialized === null) // never executed
    }, Error, &apos;Expected exception when deserializing a not valid big Cloudevent, with related flag enabled&apos;)
  }

  {
    // the same but with strict mode enabled ...
    const ceFullStrict = new CloudEvent(&apos;1/full/sample-data-nested/strict&apos;,
      ceNamespace,
      ceServerUrl,
      { random: ceBigString }, // data
      ceCommonOptionsStrict,
      ceCommonExtensions
    )
    assert(ceFullStrict !== null)
    t.ok(ceFullStrict)
    t.ok(ceFullStrict.isValid())
    t.ok(ceFullStrict.validate().length === 0)
    t.ok(ceFullStrict.validate({ strict: false }).length === 0)
    t.ok(ceFullStrict.validate({ strict: true }).length === 0)
    t.ok(CloudEvent.isValidEvent(ceFullStrict))
    t.ok(CloudEvent.validateEvent(ceFullStrict).length === 0)
    t.ok(CloudEvent.validateEvent(ceFullStrict, { strict: false }).length === 0)
    t.ok(CloudEvent.validateEvent(ceFullStrict, { strict: true }).length === 0)

    // with defaults
    const ceFullSerializedStatic = CloudEvent.serializeEvent(ceFullStrict)
    t.ok(ceFullSerializedStatic)
    const ceFullDeserializedStatic = CloudEvent.deserializeEvent(ceFullSerializedStatic)
    t.ok(ceFullDeserializedStatic)
    const ceFullSerialized = ceFullStrict.serialize()
    t.ok(ceFullSerialized)
    const ceFullDeserialized = CloudEvent.deserializeEvent(ceFullSerialized)
    t.ok(ceFullDeserialized)
    assert(ceFullSerializedStatic === ceFullSerialized)
    t.strictSame(ceFullSerializedStatic, ceFullSerialized)

    // set some flags
    const ceFullSerializedOnlyValidFalse = CloudEvent.serializeEvent(ceFullStrict, { onlyValid: false, onlyIfLessThan64KB: false })
    t.ok(ceFullSerializedOnlyValidFalse)
    const ceFullDeserializedOnlyValidFalse = CloudEvent.deserializeEvent(ceFullSerializedOnlyValidFalse)
    t.ok(ceFullDeserializedOnlyValidFalse)
    const ceFullSerializedOnlyValidTrue = CloudEvent.serializeEvent(ceFullStrict, { onlyValid: true, onlyIfLessThan64KB: false })
    t.ok(ceFullSerializedOnlyValidTrue)
    const ceFullDeserializedOnlyValidTrue = CloudEvent.deserializeEvent(ceFullSerializedOnlyValidTrue)
    t.ok(ceFullDeserializedOnlyValidTrue)
    t.strictSame(ceFullSerializedOnlyValidFalse, ceFullSerializedOnlyValidTrue)

    // enable the flag to return the serialized string only if it&apos;s less than 64 KB, expected errors here
    t.throws(function () {
      const serialized = CloudEvent.serializeEvent(ceFullStrict, { onlyValid: false, onlyIfLessThan64KB: true })
      assert(serialized === null) // never executed
    }, Error, &apos;Expected exception when serializing a Cloudevent bigger than 64 KB (with the flag to forbid it enabled)&apos;)
    t.throws(function () {
      const serialized = CloudEvent.serializeEvent(ceFullStrict, { onlyValid: true, onlyIfLessThan64KB: true })
      assert(serialized === null) // never executed
    }, Error, &apos;Expected exception when serializing a Cloudevent bigger than 64 KB (with the flag to forbid it enabled)&apos;)
    // deserialize instances just serialized, but now with the flag enabled, so expect errors here
    t.throws(function () {
      const deserialized = CloudEvent.deserializeEvent(ceFullSerializedOnlyValidFalse, { onlyValid: false, onlyIfLessThan64KB: true })
      assert(deserialized === null) // never executed
    }, Error, &apos;Expected exception when deserializing a Cloudevent bigger than 64 KB (with the flag to forbid it enabled)&apos;)
    t.throws(function () {
      const deserialized = CloudEvent.deserializeEvent(ceFullSerializedOnlyValidTrue, { onlyValid: true, onlyIfLessThan64KB: true })
      assert(deserialized === null) // never executed
    }, Error, &apos;Expected exception when deserializing a Cloudevent bigger than 64 KB (with the flag to forbid it enabled)&apos;)
  }

  {
    // the same but with strict mode enabled ...
    const ceFullBadBigStrict = new CloudEvent(&apos;1/full/sample-data/strict&apos;,
      ceNamespace,
      ceServerUrl,
      { random: ceBigString }, // data
      ceCommonOptionsStrict,
      ceCommonExtensions
    )
    assert(ceFullBadBigStrict !== null)
    t.ok(ceFullBadBigStrict)
    const serialized = CloudEvent.serializeEvent(ceFullBadBigStrict, { onlyValid: false, onlyIfLessThan64KB: false })
    ceFullBadBigStrict.id = null // remove some mandatory attribute now, to let deserialization fail
    t.throws(function () {
      const deserialized = CloudEvent.deserializeEvent(serialized, { onlyValid: true })
      assert(deserialized === null) // never executed
    }, Error, &apos;Expected exception when deserializing a not valid big Cloudevent, with related flag enabled&apos;)
    t.throws(function () {
      const deserialized = CloudEvent.deserializeEvent(serialized, { onlyValid: false, onlyIfLessThan64KB: true })
      assert(deserialized === null) // never executed
    }, Error, &apos;Expected exception when deserializing a not valid big Cloudevent, with related flag enabled&apos;)
  }
})

// sample encoding function, to use in tests here
function encoderBigSample () {
  return `&lt;data encoder=&quot;${ceBigString}&quot; /&gt;`
}

// sample decoding function, to use in tests here
function decoderBigSample () {
  return `&lt;data decoded=&quot;${ceBigString}&quot; /&gt;`
}

/** @test {CloudEvent} */
test(&apos;serialize and deserialize a big CloudEvent instance with a non default contenttype (more than 64 KB)&apos;, (t) =&gt; {
  t.plan(54)

  const { CloudEvent } = require(&apos;../src/&apos;) // get references via destructuring
  t.ok(CloudEvent)

  t.ok(ceBigString)
  t.strictSame(ceBigString.length, ceBigStringLength)

  {
    // create an instance with non default contenttype (other options default): expected success ...
    // when I try to serialize specifying right serialization options, expect success ...
    const ceFullOtherContentType = new CloudEvent(&apos;1/non-default-contenttype/sample-data/no-strict&apos;,
      ceNamespace,
      ceServerUrl,
      { random: ceBigString }, // data
      {
        ...ceCommonOptions,
        datacontenttype: &apos;application/xml&apos;
      },
      ceCommonExtensions
    )
    assert(ceFullOtherContentType !== null)
    t.ok(ceFullOtherContentType)
    t.ok(ceFullOtherContentType.isValid())
    // test different combinations of serialization options
    // note that if given, encoder function has priority over encoded data
    const cceFullOtherContentTypeSerialized1 = ceFullOtherContentType.serialize({
      encoder: encoderBigSample
    })
    t.ok(cceFullOtherContentTypeSerialized1)
    t.ok(CloudEvent.isValidEvent(ceFullOtherContentType))
    const cceFullOtherContentTypeSerialized2 = ceFullOtherContentType.serialize({
      encodedData: `&lt;data &quot;random&quot;=&quot;${ceBigString}&quot; /&gt;`
    })
    t.ok(cceFullOtherContentTypeSerialized2)
    t.ok(CloudEvent.isValidEvent(ceFullOtherContentType))
    const fixedEncodedData = `&lt;data &quot;fixed&quot;=&quot;${ceBigString}&quot; /&gt;`
    const cceFullOtherContentTypeSerialized3 = ceFullOtherContentType.serialize({
      encoder: encoderBigSample,
      encodedData: fixedEncodedData
    })
    t.ok(cceFullOtherContentTypeSerialized3)
    t.ok(CloudEvent.isValidEvent(ceFullOtherContentType))
    const cceFullOtherContentTypeSerialized4 = CloudEvent.serializeEvent(ceFullOtherContentType, {
      encoder: encoderBigSample,
      encodedData: fixedEncodedData,
      onlyValid: false
    })
    t.ok(cceFullOtherContentTypeSerialized4)
    t.ok(CloudEvent.isValidEvent(ceFullOtherContentType))
    const cceFullOtherContentTypeSerialized5 = CloudEvent.serializeEvent(ceFullOtherContentType, {
      encoder: encoderBigSample,
      encodedData: fixedEncodedData,
      onlyValid: true
    })
    t.ok(cceFullOtherContentTypeSerialized5)
    t.ok(CloudEvent.isValidEvent(ceFullOtherContentType))

    // set some flags
    const ceFullSerializedOnlyValidFalse = CloudEvent.serializeEvent(ceFullOtherContentType, {
      encoder: encoderBigSample, onlyValid: false, onlyIfLessThan64KB: false
    })
    t.ok(ceFullSerializedOnlyValidFalse)
    const ceFullDeserializedOnlyValidFalse = CloudEvent.deserializeEvent(ceFullSerializedOnlyValidFalse, {
      decoder: decoderBigSample
    })
    t.ok(ceFullDeserializedOnlyValidFalse)
    const ceFullSerializedOnlyValidTrue = CloudEvent.serializeEvent(ceFullOtherContentType, {
      encoder: encoderBigSample, onlyValid: true, onlyIfLessThan64KB: false
    })
    t.ok(ceFullSerializedOnlyValidTrue)
    const ceFullDeserializedOnlyValidTrue = CloudEvent.deserializeEvent(ceFullSerializedOnlyValidTrue, {
      decoder: decoderBigSample
    })
    t.ok(ceFullDeserializedOnlyValidTrue)
    t.strictSame(ceFullSerializedOnlyValidFalse, ceFullSerializedOnlyValidTrue)

    // enable the flag to return the serialized string only if it&apos;s less than 64 KB, expected errors here
    t.throws(function () {
      const serialized = CloudEvent.serializeEvent(ceFullOtherContentType, {
        encoder: encoderBigSample, onlyValid: false, onlyIfLessThan64KB: true
      })
      assert(serialized === null) // never executed
    }, Error, &apos;Expected exception when serializing a Cloudevent bigger than 64 KB (with the flag to forbid it enabled)&apos;)
    t.throws(function () {
      const serialized = CloudEvent.serializeEvent(ceFullOtherContentType, {
        encoder: encoderBigSample, onlyValid: true, onlyIfLessThan64KB: true
      })
      assert(serialized === null) // never executed
    }, Error, &apos;Expected exception when serializing a Cloudevent bigger than 64 KB (with the flag to forbid it enabled)&apos;)
    // deserialize instances just serialized, but now with the flag enabled, so expect errors here
    t.throws(function () {
      const deserialized = CloudEvent.deserializeEvent(ceFullSerializedOnlyValidFalse, {
        decoder: decoderBigSample, onlyValid: false, onlyIfLessThan64KB: true
      })
      assert(deserialized === null) // never executed
    }, Error, &apos;Expected exception when deserializing a Cloudevent bigger than 64 KB (with the flag to forbid it enabled)&apos;)
    t.throws(function () {
      const deserialized = CloudEvent.deserializeEvent(ceFullSerializedOnlyValidTrue, {
        decoder: decoderBigSample, onlyValid: true, onlyIfLessThan64KB: true
      })
      assert(deserialized === null) // never executed
    }, Error, &apos;Expected exception when deserializing a Cloudevent bigger than 64 KB (with the flag to forbid it enabled)&apos;)
  }

  {
    // bad because no id
    const ceFullBadBig = new CloudEvent(null,
      ceNamespace,
      ceServerUrl,
      { random: ceBigString }, // data
      {
        ...ceCommonOptions,
        datacontenttype: &apos;application/xml&apos;
      },
      ceCommonExtensions
    )
    assert(ceFullBadBig !== null)
    t.ok(ceFullBadBig)
    t.ok(!ceFullBadBig.isValid())
    const serialized = CloudEvent.serializeEvent(ceFullBadBig, {
      encoder: encoderBigSample, onlyValid: false, onlyIfLessThan64KB: false
    })
    t.throws(function () {
      const deserialized = CloudEvent.deserializeEvent(serialized, {
        decoder: decoderBigSample, onlyValid: true
      })
      assert(deserialized === null) // never executed
    }, Error, &apos;Expected exception when deserializing a not valid big Cloudevent, with related flag enabled&apos;)
    t.throws(function () {
      const deserialized = CloudEvent.deserializeEvent(serialized, {
        decoder: decoderBigSample, onlyValid: false, onlyIfLessThan64KB: true
      })
      assert(deserialized === null) // never executed
    }, Error, &apos;Expected exception when deserializing a not valid big Cloudevent, with related flag enabled&apos;)
  }

  {
    // the same but with strict mode enabled ...
    // bad because bad data type
    const ceFullOtherContentTypeBadStrict = new CloudEvent(&apos;1/non-default-contenttype/bad-data/strict&apos;,
      ceNamespace,
      ceServerUrl,
      1234567890, // data
      // Symbol(&apos;test-no-object-nor-string&apos;), // data
      {
        ...ceCommonOptionsStrict,
        datacontenttype: &apos;application/xml&apos;
      },
      ceCommonExtensions
    )
    assert(ceFullOtherContentTypeBadStrict !== null)
    t.ok(ceFullOtherContentTypeBadStrict)
    t.ok(!ceFullOtherContentTypeBadStrict.isValid())

    const ceFullOtherContentTypeStrict = new CloudEvent(&apos;1/non-default-contenttype/sample-data/strict&apos;,
      ceNamespace,
      ceServerUrl,
      ceBigString, // data
      {
        ...ceCommonOptionsStrict,
        datacontenttype: &apos;application/xml&apos;
      },
      ceCommonExtensions
    )
    assert(ceFullOtherContentTypeStrict !== null)
    t.ok(ceFullOtherContentTypeStrict)
    t.ok(ceFullOtherContentTypeStrict.isValid())
    // test different combinations of serialization options
    // note that if given, encoder function has priority over encoded data
    const cceFullOtherContentTypeSerialized1 = ceFullOtherContentTypeStrict.serialize({
      encoder: encoderBigSample
    })
    t.ok(cceFullOtherContentTypeSerialized1)
    t.ok(CloudEvent.isValidEvent(ceFullOtherContentTypeStrict))
    const cceFullOtherContentTypeSerialized2 = ceFullOtherContentTypeStrict.serialize({
      encodedData: `&lt;data &quot;random&quot;=&quot;${ceBigString}&quot; /&gt;`
    })
    t.ok(cceFullOtherContentTypeSerialized2)
    t.ok(CloudEvent.isValidEvent(ceFullOtherContentTypeStrict))
    const fixedEncodedData = `&lt;data &quot;fixed&quot;=&quot;${ceBigString}&quot; /&gt;`
    const cceFullOtherContentTypeSerialized3 = ceFullOtherContentTypeStrict.serialize({
      encoder: encoderBigSample,
      encodedData: fixedEncodedData
    })
    t.ok(cceFullOtherContentTypeSerialized3)
    t.ok(CloudEvent.isValidEvent(ceFullOtherContentTypeStrict))
    const cceFullOtherContentTypeSerialized4 = CloudEvent.serializeEvent(ceFullOtherContentTypeStrict, {
      encoder: encoderBigSample,
      encodedData: fixedEncodedData,
      onlyValid: false
    })
    t.ok(cceFullOtherContentTypeSerialized4)
    t.ok(CloudEvent.isValidEvent(ceFullOtherContentTypeStrict))
    const cceFullOtherContentTypeSerialized5 = CloudEvent.serializeEvent(ceFullOtherContentTypeStrict, {
      encoder: encoderBigSample,
      encodedData: fixedEncodedData,
      onlyValid: true
    })
    t.ok(cceFullOtherContentTypeSerialized5)
    t.ok(CloudEvent.isValidEvent(ceFullOtherContentTypeStrict))

    // set some flags
    const ceFullSerializedOnlyValidFalse = CloudEvent.serializeEvent(ceFullOtherContentTypeStrict, {
      encoder: encoderBigSample, onlyValid: false, onlyIfLessThan64KB: false
    })
    t.ok(ceFullSerializedOnlyValidFalse)
    const ceFullDeserializedOnlyValidFalse = CloudEvent.deserializeEvent(ceFullSerializedOnlyValidFalse, {
      decoder: decoderBigSample
    })
    t.ok(ceFullDeserializedOnlyValidFalse)
    const ceFullSerializedOnlyValidTrue = CloudEvent.serializeEvent(ceFullOtherContentTypeStrict, {
      encoder: encoderBigSample, onlyValid: true, onlyIfLessThan64KB: false
    })
    t.ok(ceFullSerializedOnlyValidTrue)
    const ceFullDeserializedOnlyValidTrue = CloudEvent.deserializeEvent(ceFullSerializedOnlyValidTrue, {
      decoder: decoderBigSample
    })
    t.ok(ceFullDeserializedOnlyValidTrue)
    t.strictSame(ceFullSerializedOnlyValidFalse, ceFullSerializedOnlyValidTrue)

    // enable the flag to return the serialized string only if it&apos;s less than 64 KB, expected errors here
    t.throws(function () {
      const serialized = CloudEvent.serializeEvent(ceFullOtherContentTypeStrict, {
        encoder: encoderBigSample, onlyValid: false, onlyIfLessThan64KB: true
      })
      assert(serialized === null) // never executed
    }, Error, &apos;Expected exception when serializing a Cloudevent bigger than 64 KB (with the flag to forbid it enabled)&apos;)
    t.throws(function () {
      const serialized = CloudEvent.serializeEvent(ceFullOtherContentTypeStrict, {
        encoder: encoderBigSample, onlyValid: true, onlyIfLessThan64KB: true
      })
      assert(serialized === null) // never executed
    }, Error, &apos;Expected exception when serializing a Cloudevent bigger than 64 KB (with the flag to forbid it enabled)&apos;)
    // deserialize instances just serialized, but now with the flag enabled, so expect errors here
    t.throws(function () {
      const deserialized = CloudEvent.deserializeEvent(ceFullSerializedOnlyValidFalse, {
        decoder: decoderBigSample, onlyValid: false, onlyIfLessThan64KB: true
      })
      assert(deserialized === null) // never executed
    }, Error, &apos;Expected exception when deserializing a Cloudevent bigger than 64 KB (with the flag to forbid it enabled)&apos;)
    t.throws(function () {
      const deserialized = CloudEvent.deserializeEvent(ceFullSerializedOnlyValidTrue, {
        decoder: decoderBigSample, onlyValid: true, onlyIfLessThan64KB: true
      })
      assert(deserialized === null) // never executed
    }, Error, &apos;Expected exception when deserializing a Cloudevent bigger than 64 KB (with the flag to forbid it enabled)&apos;)
  }

  {
    const ceFullBadBigStrict = new CloudEvent(&apos;1/full/sample-data/strict&apos;,
      ceNamespace,
      ceServerUrl,
      { random: ceBigString }, // data
      {
        ...ceCommonOptionsStrict,
        datacontenttype: &apos;application/xml&apos;
      },
      ceCommonExtensions
    )
    assert(ceFullBadBigStrict !== null)
    t.ok(ceFullBadBigStrict)
    const serialized = CloudEvent.serializeEvent(ceFullBadBigStrict, {
      encoder: encoderBigSample, onlyValid: false, onlyIfLessThan64KB: false
    })
    ceFullBadBigStrict.id = null // remove some mandatory attribute now, to let deserialization fail
    t.throws(function () {
      const deserialized = CloudEvent.deserializeEvent(serialized, {
        decoder: decoderBigSample, onlyValid: true
      })
      assert(deserialized === null) // never executed
    }, Error, &apos;Expected exception when deserializing a not valid big Cloudevent, with related flag enabled&apos;)
    t.throws(function () {
      const deserialized = CloudEvent.deserializeEvent(serialized, {
        decoder: decoderBigSample, onlyValid: false, onlyIfLessThan64KB: true
      })
      assert(deserialized === null) // never executed
    }, Error, &apos;Expected exception when deserializing a not valid big Cloudevent, with related flag enabled&apos;)
  }
})

/** @test {CloudEvent} */
test(&apos;create and deserialize some CloudEvent instances with data encoded in base64, and ensure they are right&apos;, (t) =&gt; {
  t.plan(100)

  const { CloudEvent, CloudEventValidator: V, CloudEventTransformer: T } = require(&apos;../src/&apos;)
  // t.ok(CloudEvent)

  const ceDataAsString = &apos;Hello World, 2020&apos;
  const ceDataEncoded = &apos;SGVsbG8gV29ybGQsIDIwMjA=&apos;
  const ceOptionsWithDataInBase64 = { ...ceCommonOptions, datainbase64: ceDataEncoded }

  {
    const ceFull = new CloudEvent(&apos;1/full/sample-data-nested/no-strict&apos;,
      ceNamespace,
      ceServerUrl,
      null, // data
      ceOptionsWithDataInBase64,
      ceCommonExtensions
    )
    // console.log(`DEBUG - cloudEvent details: ${T.dumpObject(ceFull, &apos;ceFull&apos;)}`)
    t.ok(ceFull)
    t.ok(CloudEvent.isValidEvent(ceFull, { strict: false }))
    t.ok(CloudEvent.isValidEvent(ceFull, { strict: true }))
    t.strictSame(CloudEvent.validateEvent(ceFull, { strict: false }).length, 0)
    t.strictSame(CloudEvent.validateEvent(ceFull, { strict: true }).length, 0)
    t.strictSame(T.stringFromBase64(ceDataEncoded), ceDataAsString)
    t.strictSame(T.stringToBase64(T.stringFromBase64(ceDataEncoded)), ceDataEncoded)
    t.strictSame(T.stringToBase64(ceDataAsString), ceDataEncoded)
    t.strictSame(T.stringFromBase64(T.stringToBase64(ceDataAsString)), ceDataAsString)

    const ceFullSerializedStatic = CloudEvent.serializeEvent(ceFull)
    // console.log(`DEBUG - cloudEvent details: ${T.dumpObject(ceFullSerializedStatic, &apos;ceFullSerializedStatic&apos;)}`)
    t.ok(ceFullSerializedStatic)
    const ceFullSerialized = ceFull.serialize()
    t.ok(ceFullSerialized)
    t.strictSame(ceFullSerializedStatic, ceFullSerialized)
    const ceSerialize = CloudEvent.serializeEvent
    t.ok(ceSerialize)
    const ceFullSerializedFunction = ceSerialize(ceFull)
    t.ok(ceFullSerializedFunction)
    t.strictSame(ceFullSerializedFunction, ceFullSerializedStatic)
    t.strictSame(ceFullSerializedFunction, ceFullSerialized)
    const ceFullSerializedOnlyValidFalse = ceSerialize(ceFull, { onlyValid: false })
    t.ok(ceFullSerializedOnlyValidFalse)
    const ceFullSerializedOnlyValidTrue = ceSerialize(ceFull, { onlyValid: true })
    t.ok(ceFullSerializedOnlyValidTrue)

    const ceDeserialized = CloudEvent.deserializeEvent(ceFullSerializedStatic)
    // console.log(`DEBUG - cloudEvent details: ${T.dumpObject(ceDeserialized, &apos;ceDeserialized&apos;)}`)
    // console.log(`DEBUG - cloudEvent validation: ${ceDeserialized.validate()}`)
    // console.log(`DEBUG - cloudEvent validation (strict): ${ceDeserialized.validate({ strict: true })}`)
    t.ok(ceDeserialized)
    t.ok(V.isClass(ceDeserialized, CloudEvent))
    t.ok(ceDeserialized.isValid())
    t.ok(ceDeserialized.validate().length === 0)
    t.ok(ceDeserialized.validate({ strict: false }).length === 0)
    t.ok(ceDeserialized.validate({ strict: true }).length === 0)
    t.ok(CloudEvent.isValidEvent(ceDeserialized))
    t.ok(CloudEvent.validateEvent(ceDeserialized).length === 0)
    t.ok(CloudEvent.validateEvent(ceDeserialized, { strict: false }).length === 0)
    t.ok(CloudEvent.validateEvent(ceDeserialized, { strict: true }).length === 0)
    t.ok(CloudEvent.isCloudEvent(ceDeserialized))

    // inspect content of deserialized CloudEvent, at least on some attributes
    t.ok(ceDeserialized.time)
    t.ok(V.isDate(ceDeserialized.time))
    t.ok(V.isDateValid(ceDeserialized.time))
    t.ok(V.isDatePast(ceDeserialized.time))
    t.strictSame(ceDeserialized.time.getTime(), commonEventTime.getTime())
    t.notStrictEqual(ceDeserialized.time, commonEventTime)
    t.notEqual(ceDeserialized.time, commonEventTime)
    // console.log(`DEBUG - cloudEvent data: ${T.dumpObject(ceDeserialized.data, &apos;ceDeserialized.data&apos;)}`)
    // console.log(`DEBUG - cloudEvent data_base64: ${T.dumpObject(ceDeserialized.data_base64, &apos;ceDeserialized.data_base64&apos;)}`)
    // console.log(`DEBUG - cloudEvent payload: ${T.dumpObject(ceDeserialized.payload, &apos;ceDeserialized.payload&apos;)}`)
    t.ok(ceDeserialized.data_base64)
    t.ok(V.isString(ceDeserialized.data_base64))
    t.ok(ceDeserialized.payload)
    t.ok(V.isString(ceDeserialized.payload))
    // then ensure the value of both are the same ...
    t.notStrictSame(ceDeserialized.payload, ceDeserialized.data)
    t.strictSame(ceDeserialized.payload, T.stringFromBase64(ceDeserialized.data_base64))
    // and that they are the same of initial value ...
    t.strictSame(ceDeserialized.data, ceFull.data)
    t.notStrictSame(ceDeserialized.data, ceDataEncoded)
    // then ensure they are different object (references) ...
    // not needed here because is a string, and payload returns a copy of it, so comparison here will be equals ...

    {
      const serialized = ceFullSerializedStatic
      // console.log(`DEBUG - serialized cloudEvent details: serialized = &apos;${serialized}&apos;`)
      t.ok(serialized)
      t.ok(V.isString(serialized))
      // some checks on serialized instance
      const ceFullDeserializedJSON = JSON.parse(ceFullSerializedStatic) // note that some fields (like dates) will be different when deserialized in this way ...
      ceFullDeserializedJSON.time = commonEventTime // quick fix for the Date/timestamp attribute in the deserialized object
      // console.log(`DEBUG - original cloudEvent: data = &apos;${ceFull.data}&apos;, data_base64 = &apos;${ceFull.data_base64}&apos;`)
      // console.log(`DEBUG - deserialized cloudEvent: data = &apos;${ceFullDeserializedJSON.data}&apos;, data_base64 = &apos;${ceFullDeserializedJSON.data_base64}&apos;`)
      // next tests are so because here deserialization is done with standard JSON, and not with ce specific method ...
      t.notStrictSame(ceFullDeserializedJSON, ceFull)
      t.strictSame(ceFullDeserializedJSON.data, ceFull.data)
      t.strictSame(ceFullDeserializedJSON.data_base64, ceFull.data_base64)
    }
    {
      // test with not supported data (not a string representation)
      const serialized = ceFullSerializedStatic.replace(ceDataEncoded, &apos;{}&apos;)
      // console.log(`DEBUG - serialized cloudEvent details: serialized = &apos;${serialized}&apos;`)
      // some checks on serialized instance, but using deserialization methods
      t.throws(function () {
        const ceDeserialized = CloudEvent.deserializeEvent(serialized)
        assert(ceDeserialized === undefined) // never executed
      }, Error, &apos;Expected exception when creating a CloudEvent with data_base64 set but wrong&apos;)
    }
  }

  {
    // the same but with strict mode enabled ...
    const ceFullStrict = new CloudEvent(&apos;1/full/sample-data-nested/strict&apos;,
      ceNamespace,
      ceServerUrl,
      null, // data
      { ...ceOptionsWithDataInBase64, strict: true },
      ceCommonExtensions
    )
    // console.log(`DEBUG - cloudEvent details: ${T.dumpObject(ceFullStrict, &apos;ceFullStrict&apos;)}`)
    t.ok(ceFullStrict)
    t.ok(CloudEvent.isValidEvent(ceFullStrict, { strict: false }))
    t.ok(CloudEvent.isValidEvent(ceFullStrict, { strict: true }))
    t.strictSame(CloudEvent.validateEvent(ceFullStrict, { strict: false }).length, 0)
    t.strictSame(CloudEvent.validateEvent(ceFullStrict, { strict: true }).length, 0)
    t.strictSame(T.stringFromBase64(ceDataEncoded), ceDataAsString)
    t.strictSame(T.stringToBase64(T.stringFromBase64(ceDataEncoded)), ceDataEncoded)
    t.strictSame(T.stringToBase64(ceDataAsString), ceDataEncoded)
    t.strictSame(T.stringFromBase64(T.stringToBase64(ceDataAsString)), ceDataAsString)

    const ceFullSerializedStatic = CloudEvent.serializeEvent(ceFullStrict)
    // console.log(`DEBUG - cloudEvent details: ${T.dumpObject(ceFullSerializedStatic, &apos;ceFullSerializedStatic&apos;)}`)
    t.ok(ceFullSerializedStatic)
    const ceFullSerialized = ceFullStrict.serialize()
    t.ok(ceFullSerialized)
    t.strictSame(ceFullSerializedStatic, ceFullSerialized)
    const ceSerialize = CloudEvent.serializeEvent
    t.ok(ceSerialize)
    const ceFullSerializedFunction = ceSerialize(ceFullStrict)
    t.ok(ceFullSerializedFunction)
    t.strictSame(ceFullSerializedFunction, ceFullSerializedStatic)
    t.strictSame(ceFullSerializedFunction, ceFullSerialized)
    const ceFullSerializedOnlyValidFalse = ceSerialize(ceFullStrict, { onlyValid: false })
    t.ok(ceFullSerializedOnlyValidFalse)
    const ceFullSerializedOnlyValidTrue = ceSerialize(ceFullStrict, { onlyValid: true })
    t.ok(ceFullSerializedOnlyValidTrue)

    const ceDeserialized = CloudEvent.deserializeEvent(ceFullSerializedStatic)
    // console.log(`DEBUG - cloudEvent details: ${T.dumpObject(ceDeserialized, &apos;ceDeserialized&apos;)}`)
    // console.log(`DEBUG - cloudEvent validation: ${ceDeserialized.validate()}`)
    // console.log(`DEBUG - cloudEvent validation (strict): ${ceDeserialized.validate({ strict: true })}`)
    t.ok(ceDeserialized)
    t.ok(V.isClass(ceDeserialized, CloudEvent))
    t.ok(ceDeserialized.isValid())
    t.ok(ceDeserialized.validate().length === 0)
    t.ok(ceDeserialized.validate({ strict: false }).length === 0)
    t.ok(ceDeserialized.validate({ strict: true }).length === 0)
    t.ok(CloudEvent.isValidEvent(ceDeserialized))
    t.ok(CloudEvent.validateEvent(ceDeserialized).length === 0)
    t.ok(CloudEvent.validateEvent(ceDeserialized, { strict: false }).length === 0)
    t.ok(CloudEvent.validateEvent(ceDeserialized, { strict: true }).length === 0)
    t.ok(CloudEvent.isCloudEvent(ceDeserialized))

    // inspect content of deserialized CloudEvent, at least on some attributes
    t.ok(ceDeserialized.time)
    t.ok(V.isDate(ceDeserialized.time))
    t.ok(V.isDateValid(ceDeserialized.time))
    t.ok(V.isDatePast(ceDeserialized.time))
    t.strictSame(ceDeserialized.time.getTime(), commonEventTime.getTime())
    t.notStrictEqual(ceDeserialized.time, commonEventTime)
    t.notEqual(ceDeserialized.time, commonEventTime)
    // console.log(`DEBUG - cloudEvent data: ${T.dumpObject(ceDeserialized.data, &apos;ceDeserialized.data&apos;)}`)
    // console.log(`DEBUG - cloudEvent data_base64: ${T.dumpObject(ceDeserialized.data_base64, &apos;ceDeserialized.data_base64&apos;)}`)
    // console.log(`DEBUG - cloudEvent payload: ${T.dumpObject(ceDeserialized.payload, &apos;ceDeserialized.payload&apos;)}`)
    t.ok(ceDeserialized.data_base64)
    t.ok(V.isString(ceDeserialized.data_base64))
    t.ok(ceDeserialized.payload)
    t.ok(V.isString(ceDeserialized.payload))
    // then ensure the value of both are the same ...
    t.notStrictSame(ceDeserialized.payload, ceDeserialized.data)
    t.strictSame(ceDeserialized.payload, T.stringFromBase64(ceDeserialized.data_base64))
    // and that they are the same of initial value ...
    t.strictSame(ceDeserialized.data, ceFullStrict.data)
    t.notStrictSame(ceDeserialized.data, ceDataEncoded)
    // then ensure they are different object (references) ...
    // not needed here because is a string, and payload returns a copy of it, so comparison here will be equals ...

    {
      const serialized = ceFullSerializedStatic
      // console.log(`DEBUG - serialized cloudEvent details: serialized = &apos;${serialized}&apos;`)
      t.ok(serialized)
      t.ok(V.isString(serialized))
      // some checks on serialized instance
      const ceFullDeserializedJSON = JSON.parse(ceFullSerializedStatic) // note that some fields (like dates) will be different when deserialized in this way ...
      ceFullDeserializedJSON.time = commonEventTime // quick fix for the Date/timestamp attribute in the deserialized object
      // console.log(`DEBUG - original cloudEvent: data = &apos;${ceFullStrict.data}&apos;, data_base64 = &apos;${ceFullStrict.data_base64}&apos;`)
      // console.log(`DEBUG - deserialized cloudEvent: data = &apos;${ceFullDeserializedJSON.data}&apos;, data_base64 = &apos;${ceFullDeserializedJSON.data_base64}&apos;`)
      // next tests are so because here deserialization is done with standard JSON, and not with ce specific method ...
      t.notStrictSame(ceFullDeserializedJSON, ceFullStrict)
      t.strictSame(ceFullDeserializedJSON.data, ceFullStrict.data)
      t.strictSame(ceFullDeserializedJSON.data_base64, ceFullStrict.data_base64)
    }
    {
      // test with not supported data (not a string representation)
      const serialized = ceFullSerializedStatic.replace(ceDataEncoded, &apos;{}&apos;)
      // console.log(`DEBUG - serialized cloudEvent details: serialized = &apos;${serialized}&apos;`)
      // some checks on serialized instance, but using deserialization methods
      t.throws(function () {
        const ceDeserialized = CloudEvent.deserializeEvent(serialized)
        assert(ceDeserialized === undefined) // never executed
      }, Error, &apos;Expected exception when creating a CloudEvent with data_base64 set but wrong&apos;)
    }
  }
})

// define some events valid in the spec version 0.3
const ceFullSerializedJson03 = `{&quot;id&quot;:&quot;1/full/sample-data/no-strict&quot;,&quot;type&quot;:&quot;com.github.smartiniOnGitHub.cloudeventjs.testevent&quot;,&quot;source&quot;:&quot;/test&quot;,&quot;data&quot;:{&quot;hello&quot;:&quot;world&quot;,&quot;year&quot;:2020},&quot;specversion&quot;:&quot;0.3&quot;,&quot;datacontenttype&quot;:&quot;application/json&quot;,&quot;time&quot;:&quot;${T.timestampToString(commonEventTime)}&quot;,&quot;schemaurl&quot;:&quot;http://my-schema.localhost.localdomain&quot;,&quot;subject&quot;:&quot;subject&quot;,&quot;exampleExtension&quot;:&quot;value&quot;}`
const ceFullStrictSerializedJson03 = `{&quot;id&quot;:&quot;1/full/sample-data/strict&quot;,&quot;type&quot;:&quot;com.github.smartiniOnGitHub.cloudeventjs.testevent&quot;,&quot;source&quot;:&quot;/test&quot;,&quot;data&quot;:{&quot;hello&quot;:&quot;world&quot;,&quot;year&quot;:2020},&quot;specversion&quot;:&quot;0.3&quot;,&quot;datacontenttype&quot;:&quot;application/json&quot;,&quot;time&quot;:&quot;${T.timestampToString(commonEventTime)}&quot;,&quot;schemaurl&quot;:&quot;http://my-schema.localhost.localdomain&quot;,&quot;subject&quot;:&quot;subject&quot;,&quot;com_github_smartiniOnGitHub_cloudevent&quot;:{&quot;strict&quot;:true},&quot;exampleExtension&quot;:&quot;value&quot;}`

/** @test {CloudEvent} */
test(&apos;deserialize some CloudEvent instances (but a previous specversion) from JSON, and ensure errora are raised&apos;, (t) =&gt; {
  t.plan(6)

  const { CloudEvent, CloudEventValidator: V } = require(&apos;../src/&apos;) // get references via destructuring

  {
    const serialized = ceFullSerializedJson03
    // console.log(`DEBUG - serialized cloudEvent details: serialized = &apos;${serialized}&apos;`)
    t.ok(serialized)
    t.ok(V.isString(serialized))

    t.throws(function () {
      const ceDeserialized = CloudEvent.deserializeEvent(serialized)
      assert(ceDeserialized === undefined) // never executed
    }, Error, &apos;Expected exception when creating a CloudEvent from a different specversion&apos;)
  }

  {
    // the same but with strict mode enabled ...
    const serialized = ceFullStrictSerializedJson03
    // console.log(`DEBUG - serialized cloudEvent details: serialized = &apos;${serialized}&apos;`)
    t.ok(serialized)
    t.ok(V.isString(serialized))

    t.throws(function () {
      const ceDeserialized = CloudEvent.deserializeEvent(serialized)
      assert(ceDeserialized === undefined) // never executed
    }, Error, &apos;Expected exception when creating a CloudEvent from a different specversion&apos;)
  }
})
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>

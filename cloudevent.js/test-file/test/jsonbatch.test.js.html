<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">test/jsonbatch.test.js | cloudevent</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="JavaScript/Node.js implementation of the CloudEvents standard format"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="cloudevent"><meta property="twitter:description" content="JavaScript/Node.js implementation of the CloudEvents standard format"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  <a href="test.html" data-ice="testLink">Test</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/smartiniOnGitHub/cloudevent.js"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/cloudevent.js~CloudEvent.html">CloudEvent</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/jsonbatch.js~JSONBatch.html">JSONBatch</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/transformer.js~Transformer.html">Transformer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/validator.js~Validator.html">Validator</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">test/jsonbatch.test.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">/*
 * Copyright 2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
&apos;use strict&apos;

const assert = require(&apos;assert&apos;).strict
const test = require(&apos;tap&apos;).test

// import some common test data
const {
  ceCommonOptions,
  ceCommonOptionsStrict,
  ceCommonExtensions,
  ceNamespace,
  ceServerUrl,
  ceCommonData
} = require(&apos;./common-test-data&apos;)

/** @test {CloudEvent} */
test(&apos;ensure CloudEvent and JSONBatch class (and related Validator and Transformer classes) are exported by the library&apos;, (t) =&gt; {
  t.plan(26)

  const { CloudEvent, JSONBatch, CloudEventValidator: V, CloudEventTransformer: T } = require(&apos;../src/&apos;) // get references via destructuring
  t.ok(CloudEvent)
  t.ok(JSONBatch)
  // optional, using some standard Node.js assert statements, as a sample
  assert(CloudEvent !== null)
  assert.strictEqual(typeof CloudEvent, &apos;function&apos;)
  assert(new CloudEvent() instanceof CloudEvent)
  assert.strictEqual(CloudEvent.mediaType(), &apos;application/cloudevents+json&apos;)
  assert(JSONBatch !== null)
  assert.strictEqual(typeof JSONBatch, &apos;function&apos;)
  assert.strictEqual(JSONBatch.mediaType(), &apos;application/cloudevents-batch+json&apos;)
  t.ok(V)
  t.strictEqual(typeof CloudEvent, &apos;function&apos;)
  t.strictEqual(typeof JSONBatch, &apos;function&apos;)
  t.strictEqual(typeof V, &apos;function&apos;)
  t.strictEqual(typeof T, &apos;function&apos;)
  t.ok(V.isFunction(CloudEvent))
  t.ok(V.isFunction(JSONBatch))
  t.ok(V.isFunction(V))
  t.ok(V.isFunction(T))
  t.strictEqual(typeof CloudEvent, &apos;function&apos;)
  t.strictEqual(new CloudEvent() instanceof CloudEvent, true)
  t.strictEqual(CloudEvent.mediaType(), &apos;application/cloudevents+json&apos;)
  t.strictEqual(typeof JSONBatch, &apos;function&apos;)
  t.strictEqual(JSONBatch.mediaType(), &apos;application/cloudevents-batch+json&apos;)

  t.throws(function () {
    const jsonBatch = new JSONBatch()
    assert(jsonBatch === null) // never executed
  }, Error, &apos;Expected exception when creating a JSONBatch instance&apos;)

  {
    // create an instance with only mandatory arguments (no strict mode, but doesn&apos;t matter in this case): expected success ...
    const ceMinimal = new CloudEvent(&apos;1&apos;, // id
      ceNamespace, // type
      &apos;/&apos;, // source
      {} // data (empty) // optional, but useful the same in this sample usage
    )
    t.ok(ceMinimal)
    // console.log(`DEBUG - cloudEvent details: ceMinimal = ${JSON.stringify(ceMinimal)}`)
    // console.log(`DEBUG - cloudEvent details: ${T.dumpObject(ceMinimal, &apos;ceMinimal&apos;)}`)

    // check that created instances belongs to the right base class
    t.strictEqual(typeof ceMinimal, &apos;object&apos;)
    t.ok(V.isClass(ceMinimal, CloudEvent))
  }

  {
    // create an instance with only mandatory arguments but null data (and strict mode): expected success ...
    const ceMinimalStrict = new CloudEvent(&apos;1-strict&apos;, // id
      ceNamespace, // type
      &apos;/&apos;, // source
      null // data // optional, but useful the same in this sample usage
    )
    t.ok(ceMinimalStrict)

    // check that created instances belongs to the right base class
    t.strictEqual(typeof ceMinimalStrict, &apos;object&apos;)
    t.ok(V.isClass(ceMinimalStrict, CloudEvent))

    t.strictEqual(typeof ceMinimalStrict.data, &apos;object&apos;) // data is wrapped in an object, so even when null it&apos;s an object
    t.ok(CloudEvent.isValidEvent(ceMinimalStrict))

    // set ceMinimalStrict.data to null, to ensure validation is good the same
    ceMinimalStrict.data = null
    t.ok(CloudEvent.isValidEvent(ceMinimalStrict))
  }
})

/** @test {JSONBatch} */
test(&apos;ensure isValid and validate works good on undefined and null arguments, and even on empty and bad ones&apos;, (t) =&gt; {
  t.plan(23)
  const { JSONBatch } = require(&apos;../src/&apos;)
  t.ok(JSONBatch)

  // in following tests to simplify comparison of results, check only the  number of expected errors ...
  {
    // undefined
    const arg = undefined
    t.notOk(arg)
    t.notOk(JSONBatch.isValidBatch())
    t.strictSame(JSONBatch.validateBatch(), [new Error(&apos;JSONBatch undefined or null&apos;)])
    t.strictSame(JSONBatch.validateBatch(arg).length, 1)
    t.strictSame(JSONBatch.validateBatch(arg, { strict: true }).length, 1)
  }
  {
    // null
    const arg = null
    t.notOk(arg)
    t.notOk(JSONBatch.isValidBatch(arg))
    t.strictSame(JSONBatch.validateBatch(arg), [new Error(&apos;JSONBatch undefined or null&apos;)])
    t.strictSame(JSONBatch.validateBatch(arg).length, 1)
    t.strictSame(JSONBatch.validateBatch(arg, { strict: true }).length, 1)
  }
  {
    // empty array
    const arg = []
    t.strictSame(JSONBatch.validateBatch(arg), [])
    t.strictSame(JSONBatch.validateBatch(arg).length, 0)
    t.strictSame(JSONBatch.validateBatch(arg, { strict: true }).length, 0)
  }
  {
    // empty object (not a CloudEvent/subclass instance)
    const arg = {}
    t.strictSame(JSONBatch.validateBatch(arg), [new TypeError(&quot;The argument &apos;batch&apos; must be an array or a CloudEvent instance (or a subclass), instead got a &apos;object&apos;&quot;)])
    t.strictSame(JSONBatch.validateBatch(arg).length, 1)
    t.strictSame(JSONBatch.validateBatch(arg, { strict: true }).length, 1)
  }
  {
    // bad object type
    const arg = &apos;Sample string&apos;
    t.strictSame(JSONBatch.validateBatch(arg).length, 1)
    t.strictSame(JSONBatch.validateBatch(arg, { strict: true }).length, 1)
  }
  {
    // bad object type
    const arg = 1234567890
    t.strictSame(JSONBatch.validateBatch(arg).length, 1)
    t.strictSame(JSONBatch.validateBatch(arg, { strict: true }).length, 1)
  }
  {
    // bad object type
    const arg = new Date()
    t.strictSame(JSONBatch.validateBatch(arg).length, 1)
    t.strictSame(JSONBatch.validateBatch(arg, { strict: true }).length, 1)
  }
})

/** @test {JSONBatch} */
test(&apos;ensure isValid and validate works good on array and related items&apos;, (t) =&gt; {
  t.plan(39)
  const { CloudEvent, JSONBatch, CloudEventValidator: V } = require(&apos;../src/&apos;)
  t.ok(CloudEvent)
  t.ok(JSONBatch)
  t.ok(V)

  const empty = []
  t.ok(empty)
  t.ok(JSONBatch.isJSONBatch(empty))
  t.ok(JSONBatch.isValidBatch(empty))
  t.strictSame(JSONBatch.validateBatch(empty, { strict: false }).length, 0)
  t.strictSame(JSONBatch.validateBatch(empty, { strict: true }).length, 0)
  t.strictSame(JSONBatch.getEvents(empty, { onlyValid: false, strict: false }).length, 0)
  t.strictSame(JSONBatch.getEvents(empty, { onlyValid: true, strict: false }).length, 0)
  t.strictSame(JSONBatch.getEvents(empty, { onlyValid: true, strict: true }).length, 0)
  t.strictSame(JSONBatch.getEvents(empty, { onlyValid: false, strict: true }).length, 0)

  const ceFull = new CloudEvent(&apos;1/full&apos;,
    ceNamespace,
    ceServerUrl,
    // ceCommonData,
    &apos;sample data&apos;, // data as string, to let this ce instance have some strict validation errors
    ceCommonOptions,
    // ceCommonExtensions
    {} // extensions as empty object, to let this ce instance have some strict validation errors
  )
  t.ok(ceFull)
  t.ok(CloudEvent.isValidEvent(ceFull))
  t.ok(CloudEvent.isValidEvent(ceFull, { strict: false }))
  t.notOk(CloudEvent.isValidEvent(ceFull, { strict: true })) // expected errors here
  t.strictSame(CloudEvent.validateEvent(ceFull), [])
  t.strictSame(CloudEvent.validateEvent(ceFull).length, 0)
  t.notOk(JSONBatch.isJSONBatch(ceFull))

  const ceFullStrict = new CloudEvent(&apos;1/full-strict&apos;,
    ceNamespace,
    ceServerUrl,
    ceCommonData,
    ceCommonOptionsStrict,
    ceCommonExtensions
  )
  t.ok(ceFullStrict)
  t.ok(CloudEvent.isValidEvent(ceFull))
  t.ok(CloudEvent.isValidEvent(ceFullStrict, { strict: false }))
  t.ok(CloudEvent.isValidEvent(ceFullStrict, { strict: true }))
  t.strictSame(CloudEvent.validateEvent(ceFullStrict, { strict: false }).length, 0)
  t.strictSame(CloudEvent.validateEvent(ceFullStrict, { strict: true }).length, 0)
  t.notOk(JSONBatch.isJSONBatch(ceFullStrict))

  // define an array containing different CloudEvent instances, and even other objects ...
  const arr = [
    undefined,
    null,
    &apos;string&apos;,
    1234567890,
    false,
    true,
    ceFull,
    new Date(),
    {},
    [],
    ceFullStrict,
    null,
    undefined
  ]
  t.ok(arr)
  t.strictSame(arr.length, 13)
  t.strictSame(arr.filter((i) =&gt; V.isDefinedAndNotNull(i)).length, 9) // number of not null items

  // in following tests to simplify comparison of results, check only the  number of expected errors ...
  t.ok(JSONBatch.isJSONBatch(arr))
  t.notOk(JSONBatch.isValidBatch(arr)) // it has some validation error (on its content)
  t.strictSame(JSONBatch.validateBatch(arr, { strict: false }).length, 7)
  t.strictSame(JSONBatch.validateBatch(arr, { strict: true }).length, 8)
  t.strictSame(JSONBatch.getEvents(arr, { onlyValid: false, strict: false }).length, 2) // no filtering
  t.strictSame(JSONBatch.getEvents(arr, { onlyValid: true, strict: false }).length, 2) // both are valid
  t.strictSame(JSONBatch.getEvents(arr, { onlyValid: true, strict: true }).length, 1) // only one is valid in strict mode
  t.strictSame(JSONBatch.getEvents(arr, { onlyValid: false, strict: true }).length, 2) // strict true with onlyValid false makes no filtering

  // additional test, ensure that all instances returned (only valid), are CloudEvent instances
  const eventsGot = JSONBatch.getEvents(arr, { onlyValid: true, strict: false })
  t.ok(eventsGot.every((i) =&gt; CloudEvent.isCloudEvent(i)))
  // test with other instances returned (filtered in a different way)
  t.ok(JSONBatch.getEvents(arr, { onlyValid: false, strict: false }).every((i) =&gt; CloudEvent.isCloudEvent(i)))
})

/** @test {JSONBatch} */
test(&apos;ensure isValid and validate works good on plain object and even CloudEvent instance and CloudEvent subclasses and not&apos;, (t) =&gt; {
  t.plan(33)
  const { CloudEvent, JSONBatch, CloudEventValidator: V } = require(&apos;../src/&apos;)
  t.ok(CloudEvent)
  t.ok(JSONBatch)

  class NotCESubclass {
  }
  class CESubclass extends CloudEvent {
  }

  const ceFull = new CloudEvent(&apos;1/full&apos;,
    ceNamespace,
    ceServerUrl,
    // ceCommonData,
    &apos;sample data&apos;, // data as string, to let this ce instance have some strict validation errors
    ceCommonOptions,
    // ceCommonExtensions
    {} // extensions as empty object, to let this ce instance have some strict validation errors
  )
  t.ok(ceFull)
  // check that created instances belongs to the right base class
  t.ok(V.isClass(ceFull, CloudEvent))
  t.ok(!V.isClass(ceFull, NotCESubclass))
  t.ok(!V.isClass(ceFull, CESubclass))
  t.ok(!V.ensureIsClass(ceFull, CloudEvent, &apos;ceFull&apos;)) // no error returned
  t.ok(V.ensureIsClass(ceFull, CESubclass, &apos;ceFull&apos;)) // expected error returned
  t.ok(V.isClass(V.ensureIsClass(ceFull, CESubclass, &apos;ceFull&apos;), TypeError)) // expected error returned
  t.ok(V.isClass(V.ensureIsClass(ceFull, NotCESubclass, &apos;ceFull&apos;), TypeError)) // expected error returned
  // in following tests to simplify comparison of results, check only the  number of expected errors ...
  t.strictSame(JSONBatch.validateBatch(ceFull).length, 0)
  t.strictSame(JSONBatch.validateBatch(ceFull, { strict: true }).length, 2)
  t.notOk(JSONBatch.isJSONBatch(ceFull))

  const ceFullSubclass = new CESubclass(&apos;1/full/subclass&apos;,
    ceNamespace,
    ceServerUrl,
    // ceCommonData,
    &apos;sample data&apos;, // data as string, to let this ce instance have some strict validation errors
    ceCommonOptions,
    // ceCommonExtensions
    {} // extensions as empty object, to let this ce instance have some strict validation errors
  )
  t.ok(ceFullSubclass)
  // check that created instances belongs to the right base class
  t.ok(V.isClass(ceFullSubclass, CloudEvent))
  t.ok(!V.isClass(ceFullSubclass, NotCESubclass))
  t.ok(V.isClass(ceFullSubclass, CESubclass))
  t.ok(!V.ensureIsClass(ceFullSubclass, CloudEvent, &apos;ceFullSubclass&apos;)) // no error returned
  t.ok(!V.ensureIsClass(ceFullSubclass, CESubclass, &apos;ceFullSubclass&apos;)) // no error returned
  t.ok(!V.isClass(V.ensureIsClass(ceFullSubclass, CESubclass, &apos;ceFullSubclass&apos;), TypeError)) // no error returned
  t.ok(V.isClass(V.ensureIsClass(ceFullSubclass, NotCESubclass, &apos;ceFullSubclass&apos;), TypeError)) // expected error returned
  // in following tests to simplify comparison of results, check only the  number of expected errors ...
  t.strictSame(JSONBatch.validateBatch(ceFullSubclass).length, 0)
  t.strictSame(JSONBatch.validateBatch(ceFullSubclass, { strict: true }).length, 2)
  t.notOk(JSONBatch.isJSONBatch(ceFullSubclass))

  // try even with a plain object
  const plainObject = { id: &apos;1/plainObject&apos;, data: &apos;sample data&apos; }
  t.strictSame(JSONBatch.validateBatch(plainObject).length, 1)
  t.strictSame(JSONBatch.validateBatch(plainObject, { strict: true }).length, 1)
  t.notOk(JSONBatch.isJSONBatch(plainObject))
  t.throws(function () {
    const ce = [] // CloudEvent instances
    // get values from the generator function
    for (const event of JSONBatch.getEvent(plainObject, { })) {
      assert(event === null) // never executed
      ce.push(event) // never executed
    }
    assert(ce.length === 0) // never executed
  }, Error, &apos;Expected exception when trying to get an event from a bad JSONBatch&apos;)
  t.throws(function () {
    const eventsGot = JSONBatch.getEvents(plainObject)
    assert(eventsGot === null) // never executed
  }, Error, &apos;Expected exception when trying to get events from a bad JSONBatch&apos;)

  // try with some references
  t.throws(function () {
    JSONBatch.isJSONBatch(undefined)
    assert(true) // never executed
  }, Error, &apos;Expected exception when checking for a JSONBatch with bad data&apos;)
  t.throws(function () {
    JSONBatch.isJSONBatch(null)
    assert(true) // never executed
  }, Error, &apos;Expected exception when checking for a JSONBatch with bad data&apos;)
  t.notOk(JSONBatch.isJSONBatch({}))
  t.ok(JSONBatch.isJSONBatch([]))
})
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>

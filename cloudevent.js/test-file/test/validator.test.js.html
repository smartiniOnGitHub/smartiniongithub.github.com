<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">test/validator.test.js | cloudevent</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="JavaScript/Node.js implementation of the CloudEvents standard format"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="cloudevent"><meta property="twitter:description" content="JavaScript/Node.js implementation of the CloudEvents standard format"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  <a href="test.html" data-ice="testLink">Test</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/smartiniOnGitHub/cloudevent.js"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/cloudevent.js~CloudEvent.html">CloudEvent</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/jsonbatch.js~JSONBatch.html">JSONBatch</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/transformer.js~Transformer.html">Transformer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/validator.js~Validator.html">Validator</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">test/validator.test.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">/*
 * Copyright 2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
&apos;use strict&apos;

const assert = require(&apos;assert&apos;).strict
const test = require(&apos;tap&apos;).test

/** @test {Validator} */
test(&apos;ensure the Validator class (direct reference to it) works good&apos;, (t) =&gt; {
  t.plan(5)
  const V = require(&apos;../src/validator&apos;) // direct reference to the library
  t.ok(V)
  t.strictEqual(typeof V, &apos;function&apos;)

  // optional, using some standard Node.js assert statements, as a sample
  assert(V !== null)
  assert.strictEqual(typeof V, &apos;function&apos;)
  // assert(new V() instanceof V) // no more allowed

  t.ok(V.isFunction(V))
  t.ok(V.isFunction(V.isClass))
  t.throws(function () {
    const v = new V()
    assert(v === null) // never executed
  }, Error, &apos;Expected exception when creating a Validator instance&apos;)
})

/** @test {CloudEvent} */
test(&apos;create CloudEvent instances with different class hierarchy, and ensure the validation is right&apos;, (t) =&gt; {
  t.plan(33)

  /** create some classes, for better reuse in following tests */
  const { CloudEvent: CEClass } = require(&apos;../src/&apos;) // get references via destructuring
  class NotCESubclass {
  }
  class CESubclass extends CEClass {
  }

  {
    const { CloudEvent, CloudEventValidator: V, CloudEventTransformer: T } = require(&apos;../src/&apos;) // get references via destructuring
    t.strictEqual(typeof CloudEvent, &apos;function&apos;)
    t.strictEqual(typeof CloudEvent.version, &apos;function&apos;)
    t.strictEqual(typeof V.isClass, &apos;function&apos;)
    t.strictEqual(typeof T.dumpObject, &apos;function&apos;)
    t.ok(V.isFunction(CloudEvent))
    t.ok(V.isFunction(V.isClass))
    t.ok(V.isFunction(T.dumpObject))

    // create an instance with only mandatory arguments (no strict mode, but doesn&apos;t matter in this case): expected success ...
    const ceMinimal = new CEClass(&apos;1&apos;, // id
      &apos;com.github.smartiniOnGitHub.cloudeventjs.testevent&apos;, // type
      &apos;/&apos;, // source
      {} // data (empty) // optional, but useful the same in this sample usage
    )
    t.ok(ceMinimal)
    // console.log(`DEBUG - cloudEvent details: ceMinimal = ${JSON.stringify(ceMinimal)}`)
    // console.log(`DEBUG - cloudEvent details: ${T.dumpObject(ceMinimal, &apos;ceMinimal&apos;)}`)

    // check that created instances belongs to the right base class
    t.ok(V.isClass(ceMinimal, CloudEvent))
    t.ok(V.isClass(ceMinimal, CEClass))
    t.ok(!V.isClass(ceMinimal, NotCESubclass))
    t.ok(!V.isClass(ceMinimal, CESubclass))
    t.ok(!V.ensureIsClass(ceMinimal, CloudEvent, &apos;ceMinimal&apos;)) // no error returned
    t.ok(!V.ensureIsClass(ceMinimal, CEClass, &apos;ceMinimal&apos;)) // no error returned
    t.ok(V.isClass(V.ensureIsClass(ceMinimal, CESubclass, &apos;ceMinimal&apos;), TypeError)) // expected error returned
    t.ok(V.isClass(V.ensureIsClass(ceMinimal, NotCESubclass, &apos;ceMinimal&apos;), TypeError)) // expected error returned

    // create an instance with only mandatory arguments (no strict mode, but doesn&apos;t matter in this case): expected success ...
    const ceMinimalSubclass = new CESubclass(&apos;1EX&apos;, // id
      &apos;org.github.smartiniOnGitHub.cloudeventjs.testeventEx&apos;, // type
      &apos;/&apos;, // source
      {} // data (empty) // optional, but useful the same in this sample usage
    )
    t.ok(ceMinimalSubclass)
    // console.log(`DEBUG - cloudEvent details: ceMinimalSubclass = ${JSON.stringify(ceMinimalSubclass)}`)
    // console.log(`DEBUG - cloudEvent details: ${T.dumpObject(ceMinimalSubclass, &apos;ceMinimalSubclass&apos;)}`)

    // check that created instances belongs to the right base class
    t.ok(V.isClass(ceMinimalSubclass, CloudEvent))
    t.ok(V.isClass(ceMinimalSubclass, CEClass))
    t.ok(!V.isClass(ceMinimalSubclass, NotCESubclass))
    t.ok(V.isClass(ceMinimalSubclass, CESubclass))
    t.ok(!V.ensureIsClass(ceMinimalSubclass, CloudEvent, &apos;ceMinimal&apos;)) // no error returned
    t.ok(!V.ensureIsClass(ceMinimalSubclass, CEClass, &apos;ceMinimal&apos;)) // no error returned
    t.ok(!V.ensureIsClass(ceMinimalSubclass, CESubclass, &apos;ceMinimal&apos;)) // no error returned
    t.ok(V.isClass(V.ensureIsClass(ceMinimalSubclass, NotCESubclass, &apos;ceMinimal&apos;), TypeError)) // expected error returned
  }

  {
    const { CloudEventValidator: V } = require(&apos;../src/&apos;) // get references via destructuring
    t.strictEqual(typeof V, &apos;function&apos;)
    t.strictEqual(typeof V.isClass, &apos;function&apos;)
    t.ok(V.isFunction(V))
    t.ok(V.isFunction(V.isClass))

    const { CloudEvent, CloudEventValidator } = require(&apos;../src/&apos;) // get references via destructuring
    t.strictEqual(typeof CloudEvent, &apos;function&apos;)
    t.strictEqual(typeof CloudEventValidator, &apos;function&apos;)
    t.ok(V.isFunction(CloudEvent))
    t.ok(V.isFunction(CloudEventValidator))
  }
})

/** @test {Validator} */
test(&apos;ensure some (edge cases for) validation functions are right&apos;, (t) =&gt; {
  t.plan(26)

  const { CloudEventValidator: V } = require(&apos;../src/&apos;) // get references via destructuring
  t.ok(V)

  {
    const arg = undefined
    t.ok(V.isUndefined())
    t.ok(V.isUndefined(arg))
    t.strictSame(V.ensureIsUndefined(), undefined) // no error returned
    t.strictSame(V.ensureIsUndefined(arg, undefined), undefined) // no error returned
    t.strictSame(V.ensureIsUndefined(arg, null), undefined) // no error returned
    t.strictSame(V.ensureIsUndefined(arg, &apos;test&apos;), undefined) // no error returned
    t.strictSame(V.ensureIsUndefined(arg, {}), undefined) // no error returned
    // check what happens with opposite value instead
    const narg = &apos;sample&apos; // sample value
    t.notOk(V.isUndefined(narg))
    t.strictSame(V.ensureIsUndefined(narg) instanceof Error, true) // expected error returned
    t.strictSame(V.ensureIsUndefined(narg, undefined) instanceof Error, true) // expected error returned
    t.strictSame(V.ensureIsUndefined(narg, null) instanceof Error, true) // expected error returned
    t.strictSame(V.ensureIsUndefined(narg, &apos;test&apos;) instanceof Error, true) // expected error returned
    t.strictSame(V.ensureIsUndefined(narg, {}) instanceof Error, true) // expected error returned
  }
  {
    const arg = null
    t.ok(V.isNull(arg))
    t.strictSame(V.ensureIsNull(arg), undefined) // no error returned
    t.strictSame(V.ensureIsNull(arg, undefined), undefined) // no error returned
    t.strictSame(V.ensureIsNull(arg, null), undefined) // no error returned
    t.strictSame(V.ensureIsNull(arg, &apos;test&apos;), undefined) // no error returned
    t.strictSame(V.ensureIsNull(arg, {}), undefined) // no error returned
    // check what happens with opposite value instead
    const narg = &apos;sample&apos; // sample value
    t.notOk(V.isNull(narg))
    t.strictSame(V.ensureIsNull(narg) instanceof Error, true) // expected error returned
    t.strictSame(V.ensureIsNull(narg, undefined) instanceof Error, true) // expected error returned
    t.strictSame(V.ensureIsNull(narg, null) instanceof Error, true) // expected error returned
    t.strictSame(V.ensureIsNull(narg, &apos;test&apos;) instanceof Error, true) // expected error returned
    t.strictSame(V.ensureIsNull(narg, {}) instanceof Error, true) // expected error returned
  }

  // similar tests for all other is / ensure methods ...
})

/** @test {Validator} */
test(&apos;ensure some (less used) validation functions are right&apos;, (t) =&gt; {
  t.plan(136)

  const { CloudEventValidator: V } = require(&apos;../src/&apos;) // get references via destructuring
  t.ok(V)

  {
    const undefinedGood = undefined
    t.ok(V.isUndefined(undefinedGood))
    t.strictSame(V.ensureIsUndefined(undefinedGood, &apos;test&apos;), undefined) // no error returned
    t.ok(V.isUndefinedOrNull(undefinedGood))
    t.strictSame(V.ensureIsUndefinedOrNull(undefinedGood, &apos;test&apos;), undefined) // no error returned
    t.strictSame(V.ensureIsDefinedAndNotNull(undefinedGood, &apos;test&apos;) instanceof Error, true) // expected error returned
    t.ok(!V.isObject(undefinedGood))
    t.ok(!V.isObjectPlain(undefinedGood))
    t.ok(V.ensureIsObject(undefinedGood, &apos;test&apos;)) // expected error returned
    t.ok(V.ensureIsObjectPlain(undefinedGood, &apos;test&apos;)) // expected error returned
    const undefinedBad = &apos;defined&apos;
    t.ok(!V.isUndefined(undefinedBad))
    t.strictSame(V.ensureIsUndefined(undefinedBad, &apos;test&apos;) instanceof Error, true) // expected error returned
    t.ok(!V.isUndefinedOrNull(undefinedBad))
    t.strictSame(V.ensureIsUndefinedOrNull(undefinedBad, &apos;test&apos;) instanceof Error, true) // expected error returned
    t.strictSame(V.ensureIsDefinedAndNotNull(undefinedBad, &apos;test&apos;), undefined) // no error returned
  }

  {
    const nullGood = null
    t.ok(V.isNull(nullGood))
    t.strictSame(V.ensureIsNull(nullGood, &apos;test&apos;), undefined) // no error returned
    t.ok(V.isUndefinedOrNull(nullGood))
    t.strictSame(V.ensureIsUndefinedOrNull(nullGood, &apos;test&apos;), undefined) // no error returned
    t.strictSame(V.ensureIsDefinedAndNotNull(nullGood, &apos;test&apos;) instanceof Error, true) // expected error returned
    t.ok(!V.isObject(nullGood))
    t.ok(!V.isObjectPlain(nullGood))
    t.ok(V.ensureIsObject(nullGood, &apos;test&apos;)) // expected error returned
    t.ok(V.ensureIsObjectPlain(nullGood, &apos;test&apos;)) // expected error returned
    const nullBad = &apos;defined&apos;
    t.ok(!V.isNull(nullBad))
    t.strictSame(V.ensureIsNull(nullBad, &apos;test&apos;) instanceof Error, true) // expected error returned
    t.ok(!V.isUndefinedOrNull(nullBad))
    t.strictSame(V.ensureIsUndefinedOrNull(nullBad, &apos;test&apos;) instanceof Error, true) // expected error returned
    t.strictSame(V.ensureIsDefinedAndNotNull(nullBad, &apos;test&apos;), undefined) // no error returned
  }

  {
    const errorGood = new Error(&apos;Sample error&apos;)
    t.ok(V.isError(errorGood))
    t.strictSame(V.ensureIsError(errorGood, &apos;test&apos;), undefined) // no error returned
    t.ok(V.isObject(errorGood))
    t.ok(!V.isObjectPlain(errorGood))
    t.ok(!V.ensureIsObject(errorGood, &apos;error&apos;)) // no error returned
    t.ok(V.ensureIsObjectPlain(errorGood, &apos;error&apos;)) // expected error returned
    const errorBad = &apos;Error string&apos;
    t.ok(!V.isError(errorBad))
    t.strictSame(V.ensureIsError(errorBad, &apos;test&apos;) instanceof Error, true) // expected error returned
  }

  {
    const dateGood = new Date()
    t.ok(V.isDate(dateGood))
    t.strictSame(V.ensureIsDate(dateGood, &apos;test&apos;), undefined) // no error returned
    t.ok(V.isObject(dateGood))
    t.ok(!V.isObjectPlain(dateGood))
    t.ok(!V.ensureIsObject(dateGood, &apos;date&apos;)) // no error returned
    t.ok(V.ensureIsObjectPlain(dateGood, &apos;date&apos;)) // expected error returned
    const dateBad = Date.now()
    t.ok(!V.isDate(dateBad))
    t.strictSame(V.ensureIsDate(dateBad, &apos;test&apos;) instanceof Error, true) // expected error returned
    t.ok(V.ensureIsObjectOrCollectionOrString(dateGood, &apos;date&apos;)) // expected error returned
    t.ok(V.ensureIsNumber(dateGood, &apos;date&apos;)) // expected error returned
    t.ok(!V.ensureIsNumber(dateGood.getTime(), &apos;number&apos;)) // no error returned
  }

  {
    const relGood = &apos;1.0.0&apos;
    t.ok(V.isVersion(relGood))
    t.strictSame(V.ensureIsVersion(relGood, &apos;test&apos;), undefined) // no error returned
    const relBad = &apos;a.b.c-d&apos;
    t.ok(!V.isVersion(relBad))
    t.strictSame(V.ensureIsVersion(relBad, &apos;test&apos;) instanceof Error, true) // expected error returned
  }

  {
    const objectBad = 1234567890
    t.ok(V.isNumber(objectBad))
    t.ok(!V.isObject(objectBad))
    t.ok(V.ensureIsObjectOrCollection(objectBad, &apos;error&apos;)) // expected error returned
    t.strictSame(V.ensureIsObjectOrCollection(objectBad, &apos;error&apos;) instanceof Error, true) // expected error returned
  }

  {
    const objectGood = { name: &apos;Name&apos;, age: 100, note: null }
    t.ok(V.isObject(objectGood))
    t.ok(!V.isString(objectGood))
    t.ok(!V.ensureIsObjectOrCollection(objectGood, &apos;object&apos;)) // no error returned
    t.strictSame(V.ensureIsObjectOrCollection(objectGood, &apos;object&apos;) instanceof Error, false) // no error returned
    t.ok(!V.ensureIsObjectOrCollectionNotString(objectGood, &apos;object&apos;)) // no error returned
    t.ok(!V.ensureIsObjectOrCollectionOrString(objectGood, &apos;object&apos;)) // no error returned
    t.ok(V.isObject(objectGood))
    t.ok(V.isObjectPlain(objectGood))
    t.ok(!V.ensureIsObject(objectGood, &apos;object&apos;)) // no error returned
    t.ok(!V.ensureIsObjectPlain(objectGood, &apos;object&apos;)) // no error returned
  }

  {
    const objectAsStringGood = &apos;{ name: &quot;Name&quot;, age: 100, note: null }&apos;
    t.ok(!V.isObject(objectAsStringGood))
    t.ok(V.isString(objectAsStringGood))
    t.ok(V.ensureIsObjectOrCollection(objectAsStringGood, &apos;string&apos;)) // expected error returned
    t.strictSame(V.ensureIsObjectOrCollection(objectAsStringGood, &apos;string&apos;) instanceof Error, true) // expected error returned
    t.ok(V.ensureIsObjectOrCollectionNotString(objectAsStringGood, &apos;object&apos;)) // expected error returned
    t.ok(!V.ensureIsObjectOrCollectionOrString(objectAsStringGood, &apos;object&apos;)) // no error returned
    t.ok(!V.isObject(objectAsStringGood))
    t.ok(!V.isObjectPlain(objectAsStringGood))
    t.ok(V.ensureIsObject(objectAsStringGood, &apos;string&apos;)) // expected error returned
    t.ok(V.ensureIsObjectPlain(objectAsStringGood, &apos;string&apos;)) // expected error returned
  }

  {
    const stringBad = 1234567890
    t.ok(!V.isString(stringBad))
    t.ok(!V.isStringNotEmpty(stringBad))
    t.ok(V.ensureIsString(stringBad, &apos;error&apos;)) // expected error returned
    t.strictSame(V.ensureIsString(stringBad, &apos;error&apos;) instanceof Error, true) // expected error returned
    t.ok(V.ensureIsStringNotEmpty(stringBad, &apos;error&apos;)) // expected error returned
    t.strictSame(V.ensureIsStringNotEmpty(stringBad, &apos;error&apos;) instanceof Error, true) // expected error returned
  }

  {
    const functionBad = &apos;1234567890&apos;
    t.ok(V.isString(functionBad))
    t.ok(!V.isFunction(functionBad))
    t.ok(V.ensureIsFunction(functionBad, &apos;error&apos;)) // expected error returned
    t.strictSame(V.ensureIsFunction(functionBad, &apos;error&apos;) instanceof Error, true) // expected error returned
  }

  {
    const arrayGood = []
    t.ok(V.isArray(arrayGood))
    t.strictSame(V.ensureIsArray(arrayGood, &apos;test&apos;), undefined) // no error returned
    t.ok(V.isObject(arrayGood))
    t.ok(!V.isObjectPlain(arrayGood))
    t.ok(!V.ensureIsObject(arrayGood, &apos;array&apos;)) // no error returned
    t.ok(V.ensureIsObjectPlain(arrayGood, &apos;array&apos;)) // expected error returned
    const arrayBad = {}
    t.ok(!V.isArray(arrayBad))
    t.strictSame(V.ensureIsArray(arrayBad, &apos;test&apos;) instanceof Error, true) // expected error returned
    t.ok(V.ensureIsObjectOrCollectionNotArray(arrayGood, &apos;array&apos;)) // expected error returned
    t.strictSame(V.ensureIsObjectOrCollectionNotArray({}, &apos;test&apos;), undefined) // no error returned
  }

  {
    const boolGood = true
    t.ok(V.isBoolean(boolGood))
    t.strictSame(V.ensureIsBoolean(boolGood, &apos;test&apos;), undefined) // no error returned
    const boolBad = &apos;false&apos;
    t.ok(!V.isBoolean(boolBad))
    t.strictSame(V.ensureIsBoolean(boolBad, &apos;test&apos;) instanceof Error, true) // expected error returned
    t.ok(V.ensureIsObjectOrCollectionOrString(boolGood, &apos;boolean&apos;)) // expected error returned
    t.strictSame(V.ensureIsObjectOrCollectionOrString({}, &apos;test&apos;), undefined) // no error returned
  }

  {
    const uriGood = &apos;http://localhost:3000/path/nested?param1=value1&apos;
    t.ok(V.isURI(uriGood))
    t.strictSame(V.ensureIsURI(uriGood, null, &apos;test&apos;), undefined) // no error returned
    const uriBad = &apos;path/nested?param1=value1&apos; // not relative nor absolute uri, so not a real uri string
    t.ok(!V.isURI(uriBad))
    t.strictSame(V.ensureIsURI(uriBad, null, &apos;test&apos;) instanceof Error, true) // expected error returned
  }

  {
    const uriGoodPath = &apos;/path/nested?param1=value1&apos;
    const uriGoodBase = &apos;http://localhost:3000&apos;
    t.ok(V.isURI(uriGoodPath, uriGoodBase))
    t.strictSame(V.ensureIsURI(uriGoodPath, uriGoodBase, &apos;test&apos;), undefined) // no error returned
    const uriBad = &apos;path/nested?param1=value1&apos; // not relative nor absolute uri, so not a real uri string
    t.ok(!V.isURI(uriBad, null))
    t.strictSame(V.ensureIsURI(uriBad, null, &apos;test&apos;) instanceof Error, true) // expected error returned
  }

  {
    const uriGoodPath = &apos;/path/nested?param1=value1&apos;
    const uriBadBase = &apos;httpz:bad&apos;
    t.ok(!V.isURI(uriGoodPath, uriBadBase))
    t.strictSame(V.ensureIsURI(uriGoodPath, uriBadBase, &apos;test&apos;) instanceof Error, true) // expected error returned
  }

  {
    // test getSize with different argument types
    t.ok(V.isUndefined(V.getSize(null)))
    t.strictSame(V.getSize(null), undefined)
    const obj = { name: &apos;Name&apos;, age: 20, note: null }
    t.ok(V.isNumber(V.getSize(obj)))
    t.strictSame(V.getSize(obj), 3) // include even null items in the size
    const arr = [1, 2, 3, null]
    t.ok(V.isNumber(V.getSize(arr)))
    t.strictSame(V.getSize(arr), 4) // include even null items in the size
    const map = new Map([[&apos;key-1&apos;, &apos;value 1&apos;], [&apos;key-2&apos;, &apos;value 2&apos;]])
    t.ok(V.isNumber(V.getSize(map)))
    t.strictSame(V.getSize(map), 2)
    const set = new Set([[&apos;key-1&apos;, &apos;value 1&apos;], [&apos;key-2&apos;, &apos;value 2&apos;]])
    t.ok(V.isNumber(V.getSize(set)))
    t.strictSame(V.getSize(set), 2)
    const str = &apos;12345 67890 &apos;
    t.ok(V.isNumber(V.getSize(str)))
    t.strictSame(V.getSize(str), 12)
    const otherBadNumber = 1234567890
    t.ok(V.isNumber(otherBadNumber))
    t.throws(function () {
      const size = V.getSize(otherBadNumber)
      assert(size !== null) // never executed
    }, Error, &apos;Expected exception when trying to get the size of a bad object&apos;)
    const otherBadBoolean = true
    t.ok(V.isBoolean(otherBadBoolean))
    t.throws(function () {
      const size = V.getSize(otherBadBoolean)
      assert(size !== null) // never executed
    }, Error, &apos;Expected exception when trying to get the size of a bad object&apos;)
  }

  {
    // test getSizeInBytes with different argument types
    t.ok(V.isUndefined(V.getSizeInBytes(null)))
    t.strictSame(V.getSizeInBytes(null), undefined)
    t.throws(function () {
      const size = V.getSizeInBytes({})
      assert(size !== null) // never executed
    }, Error, &apos;Expected exception when trying to get the size in bytes of not a string&apos;)
    const str = &apos;12345 67890 &apos;
    t.ok(V.isNumber(V.getSizeInBytes(str)))
    t.strictSame(V.getSizeInBytes(str), 12)
    t.strictSame(V.getSizeInBytes(str), V.getSize(str))
    t.ok(V.isNumber(V.getSizeInBytes(&apos;&#x3C0;&apos;)))
    t.strictSame(V.getSizeInBytes(&apos;&#x3C0;&apos;), 2)
  }
})

/** @test {Validator} */
test(&apos;ensure some (utility) functions are right&apos;, (t) =&gt; {
  t.plan(28)

  const { CloudEventValidator: V } = require(&apos;../src/&apos;) // get references via destructuring
  t.ok(V)

  {
    const u = undefined
    const n = null
    const s = &apos;Sample string&apos;
    const o = {}

    t.strictSame(V.getArgumentValue(), undefined) // no error returned
    t.strictSame(V.getArgumentValue(u), undefined)
    t.strictSame(V.getArgumentValue(n), null)
    t.strictSame(V.getArgumentValue(s), s)
    t.strictSame(V.getArgumentValue(o), {})

    t.strictSame(V.getArgumentName(), undefined) // no error returned
    t.strictSame(V.getArgumentName(u), undefined)
    t.strictSame(V.getArgumentName(n), undefined)
    t.strictSame(V.getArgumentName(s), &apos;0&apos;) // not the right way to call it
    t.strictSame(V.getArgumentName(o), undefined) // not the right way to call it
    t.strictSame(V.getArgumentName({ u }), &apos;u&apos;)
    t.strictSame(V.getArgumentName({ n }), &apos;n&apos;)
    t.strictSame(V.getArgumentName({ s }), &apos;s&apos;)

    t.strictSame(V.getOrElse(), undefined) // no error returned
    t.strictSame(V.getOrElse(u), undefined)
    t.strictSame(V.getOrElse(u, u), undefined)
    t.strictSame(V.getOrElse(u, n), null)
    t.strictSame(V.getOrElse(n), undefined)
    t.strictSame(V.getOrElse(n, u), undefined)
    t.strictSame(V.getOrElse(n, n), null)
    t.strictSame(V.getOrElse(s), s)
    t.strictSame(V.getOrElse(s, s), s)
    t.strictSame(V.getOrElse(s, o), s)
    t.strictSame(V.getOrElse(u, s), s)
    t.strictSame(V.getOrElse(n, s), s)
    t.strictSame(V.getOrElse(u, o), o)
    t.strictSame(V.getOrElse(n, o), o)
  }
})

/** @test {Validator} */
test(&apos;ensure validation functions on standard properties are right&apos;, (t) =&gt; {
  t.plan(19)

  const { CloudEventValidator: V } = require(&apos;../src/&apos;) // get references via destructuring
  t.ok(V)

  // sample function that tell if the given property name is standard
  function isPropStandard (prop) {
    return prop === &apos;standard&apos;
  }

  t.ok(!V.doesStringIsStandardProperty())
  t.ok(!V.doesStringIsStandardProperty(undefined, undefined))
  t.ok(!V.doesStringIsStandardProperty(null, null))
  t.ok(!V.doesStringIsStandardProperty({}, isPropStandard))
  t.ok(!V.doesStringIsStandardProperty(&apos;non_standard&apos;, isPropStandard))
  t.ok(V.doesStringIsStandardProperty(&apos;standard&apos;, isPropStandard))
  t.ok(!V.doesStringIsStandardProperty(&apos;property&apos;, {}))
  t.ok(!V.doesStringIsStandardProperty(&apos;standard&apos;, {}))

  t.ok(!V.doesObjectContainsStandardProperty())
  t.ok(!V.doesObjectContainsStandardProperty(undefined, undefined))
  t.ok(!V.doesObjectContainsStandardProperty(null, null))
  t.ok(!V.doesObjectContainsStandardProperty({}, isPropStandard))
  t.ok(!V.doesObjectContainsStandardProperty({ non_standard: &apos;value&apos; }, isPropStandard))
  t.ok(V.doesObjectContainsStandardProperty({ standard: &apos;value&apos; }, isPropStandard))
  t.ok(!V.doesObjectContainsStandardProperty({ property: &apos;value&apos; }, {}))
  t.ok(!V.doesObjectContainsStandardProperty({ standard: &apos;value&apos; }, {}))

  t.strictSame(V.ensureObjectDoesNotContainStandardProperty({ property: &apos;value&apos; }, isPropStandard, &apos;test&apos;), undefined) // no error returned
  t.strictSame(V.ensureObjectDoesNotContainStandardProperty({ standard: &apos;value&apos; }, isPropStandard, &apos;test&apos;) instanceof Error, true) // expected error returned
})

/** @test {Validator} */
test(&apos;ensure validation functions to filter bad object instances raise exceptions&apos;, (t) =&gt; {
  t.plan(3)

  const { CloudEventValidator: V } = require(&apos;../src/&apos;) // get references via destructuring
  t.ok(V)

  // sample function that tell if the given property name is standard
  function isPropStandard (prop) {
    return prop === &apos;standard&apos;
  }

  t.throws(function () {
    const objFiltered = V.getObjectFilteredProperties([], isPropStandard)
    assert(objFiltered !== null) // never executed
  }, Error, &apos;Expected exception when trying to filter not a plain object&apos;)
  t.throws(function () {
    const objFiltered = V.getObjectFilteredProperties({}, &apos;isPropStandard&apos;)
    assert(objFiltered !== null) // never executed
  }, Error, &apos;Expected exception when trying to filter a plain object but with a wrong filtering function&apos;)
})

/** @test {Validator} */
test(&apos;ensure validation functions to throw exceptions, works good&apos;, (t) =&gt; {
  t.plan(12)

  const { CloudEventValidator: V } = require(&apos;../src/&apos;) // get references via destructuring
  t.ok(V)

  t.notOk(V.throwOnError()) // no error returned
  t.notOk(V.throwOnError(undefined)) // no error returned
  t.notOk(V.throwOnError(null)) // no error returned
  t.notOk(V.throwOnError({})) // no error returned
  t.throws(function () {
    V.throwOnError(new TypeError(&apos;Sample TypeError&apos;))
    assert(false) // never executed
  }, Error, &apos;Expected exception when trying to throw from an Error&apos;)

  t.throws(function () {
    V.throwOnFalse()
    assert(false) // never executed
  }, Error, &apos;Expected exception when trying to throw from an undefined value&apos;)
  t.throws(function () {
    V.throwOnFalse(undefined)
    assert(false) // never executed
  }, Error, &apos;Expected exception when trying to throw from an undefined value&apos;)
  t.throws(function () {
    V.throwOnFalse(null)
    assert(false) // never executed
  }, Error, &apos;Expected exception when trying to throw from a null value&apos;)
  t.throws(function () {
    V.throwOnFalse({})
    assert(false) // never executed
  }, Error, &apos;Expected exception when trying to throw from a not boolean value&apos;)
  t.notOk(V.throwOnFalse(true)) // no error returned
  t.throws(function () {
    V.throwOnFalse(false)
    assert(false) // never executed
  }, Error, &apos;Expected exception when trying to throw from a false value&apos;)
})
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>

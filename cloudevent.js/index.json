[
  {
    "__docId__": 1,
    "kind": "external",
    "name": "Infinity",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Infinity",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Infinity",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 2,
    "kind": "external",
    "name": "NaN",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~NaN",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 3,
    "kind": "external",
    "name": "undefined",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~undefined",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 4,
    "kind": "external",
    "name": "null",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~null",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 5,
    "kind": "external",
    "name": "Object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 6,
    "kind": "external",
    "name": "object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 7,
    "kind": "external",
    "name": "Function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 8,
    "kind": "external",
    "name": "function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 9,
    "kind": "external",
    "name": "Boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 10,
    "kind": "external",
    "name": "boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 11,
    "kind": "external",
    "name": "Symbol",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Symbol",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 12,
    "kind": "external",
    "name": "Error",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Error",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 13,
    "kind": "external",
    "name": "EvalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/EvalError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~EvalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 14,
    "kind": "external",
    "name": "InternalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/InternalError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~InternalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 15,
    "kind": "external",
    "name": "RangeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RangeError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~RangeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 16,
    "kind": "external",
    "name": "ReferenceError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~ReferenceError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 17,
    "kind": "external",
    "name": "SyntaxError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~SyntaxError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 18,
    "kind": "external",
    "name": "TypeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~TypeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 19,
    "kind": "external",
    "name": "URIError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/URIError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~URIError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 20,
    "kind": "external",
    "name": "Number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 21,
    "kind": "external",
    "name": "number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 22,
    "kind": "external",
    "name": "Date",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Date",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 23,
    "kind": "external",
    "name": "String",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~String",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 24,
    "kind": "external",
    "name": "string",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~string",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 25,
    "kind": "external",
    "name": "RegExp",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~RegExp",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 26,
    "kind": "external",
    "name": "Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 27,
    "kind": "external",
    "name": "Int8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 28,
    "kind": "external",
    "name": "Uint8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 29,
    "kind": "external",
    "name": "Uint8ClampedArray",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint8ClampedArray",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 30,
    "kind": "external",
    "name": "Int16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 31,
    "kind": "external",
    "name": "Uint16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 32,
    "kind": "external",
    "name": "Int32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 33,
    "kind": "external",
    "name": "Uint32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 34,
    "kind": "external",
    "name": "Float32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Float32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 35,
    "kind": "external",
    "name": "Float64Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Float64Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 36,
    "kind": "external",
    "name": "Map",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Map",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 37,
    "kind": "external",
    "name": "Set",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Set",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 38,
    "kind": "external",
    "name": "WeakMap",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~WeakMap",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 39,
    "kind": "external",
    "name": "WeakSet",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~WeakSet",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 40,
    "kind": "external",
    "name": "ArrayBuffer",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~ArrayBuffer",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 41,
    "kind": "external",
    "name": "DataView",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~DataView",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 42,
    "kind": "external",
    "name": "JSON",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~JSON",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 43,
    "kind": "external",
    "name": "Promise",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Promise",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 44,
    "kind": "external",
    "name": "Generator",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Generator",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 45,
    "kind": "external",
    "name": "GeneratorFunction",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/GeneratorFunction",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~GeneratorFunction",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 46,
    "kind": "external",
    "name": "Reflect",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Reflect",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 47,
    "kind": "external",
    "name": "Proxy",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Proxy",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 48,
    "kind": "file",
    "name": "src/cloudevent.js",
    "content": "/*\r\n * Copyright 2018 the original author or authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n'use strict'\r\n\r\n/**\r\n * CloudEvent:\r\n * this module exports some useful definition and utility related to CloudEvents.\r\n */\r\n\r\n/**\r\n * Get a reference to cloudevent Validator class.\r\n *\r\n * @see Validator\r\n */\r\nconst V = require('./validator') // get validator from here\r\n\r\n/**\r\n * Get a reference to cloudevent Transformer class.\r\n *\r\n * @see Transformer\r\n */\r\nconst T = require('./transformer') // get transformer from here\r\n\r\n/**\r\n * CloudEvent implementation.\r\n *\r\n * @see https://github.com/cloudevents/spec/blob/master/json-format.md\r\n */\r\nclass CloudEvent {\r\n  /**\r\n   * Create a new instance of a CloudEvent object.\r\n   * @param {!string} id the ID of the event (unique), mandatory\r\n   * @param {!string} type the type of the event (usually prefixed with a reverse-DNS name), mandatory\r\n   * @param {!uri} source the source uri of the event (use '/' if empty), mandatory\r\n   * @param {?(object|Map|Set|string)} data the real event data\r\n   * @param {object} [options={}] optional attributes of the event; some has default values chosen here:\r\n   *        time (timestamp/date, default now),\r\n   *        datacontentencoding (string) optional in most cases here,\r\n   *        datacontenttype (string, default 'application/json') tell how the data attribute must be encoded,\r\n   *        schemaurl (uri) optional,\r\n   *        subject (string) optional, describes the subject of the event in the context of the event producer (identified by source),\r\n   *        strict (boolean, default false) tell if object instance will be validated in a more strict way\r\n   * @param {object} extensions optional, contains extension properties (recommended in nested objects) but if given any object must contain at least 1 property (key/value)\r\n   * @throws {Error} if strict is true and id or type is undefined or null\r\n   * @throws {Error} if datacontentencoding is defined and data is not a string or if encoding is not 'base64'\r\n   */\r\n  constructor (id, type, source, data, {\r\n    time = new Date(),\r\n    datacontentencoding,\r\n    datacontenttype = CloudEvent.datacontenttypeDefault(),\r\n    schemaurl,\r\n    subject,\r\n    strict = false\r\n  } = {},\r\n  extensions\r\n  ) {\r\n    if (strict === true) {\r\n      if (!id || !type || !source) {\r\n        throw new Error('Unable to create CloudEvent instance, mandatory field missing')\r\n      }\r\n    }\r\n\r\n    /**\r\n     * The event ID.\r\n     * @type {string}\r\n     * @private\r\n     */\r\n    this.id = id\r\n    /**\r\n     * The event type.\r\n     * @type {string}\r\n     * @private\r\n     */\r\n    this.type = type\r\n    /**\r\n     * The source URI of the event.\r\n     * @type {uri}\r\n     * @private\r\n     */\r\n    this.source = source\r\n    /**\r\n     * The real event data.\r\n     * Usually it's an object, but could be even a Map or a Set, or a string.\r\n     * Copy the original object to avoid changing objects that could be shared.\r\n     * @type {(object|Map|Set)}\r\n     * @private\r\n     */\r\n    if (V.isString(data)) {\r\n      // handle an edge case: if the given data is a String, I need to clone in a different way ...\r\n      this.data = data.slice()\r\n    } else if (V.isObjectOrCollectionOrString(data)) {\r\n      // normal case\r\n      this.data = { ...data }\r\n    } else {\r\n      // anything other, assign as is (and let validator complain later if needed)\r\n      this.data = data\r\n    }\r\n\r\n    /**\r\n     * The CloudEvent specification version.\r\n     * @type {string}\r\n     * @private\r\n     */\r\n    this.specversion = this.constructor.version()\r\n    /**\r\n     * The content encoding for the data attribute\r\n     * for when the data field must be encoded as a string.\r\n     * This must be set if the data attribute contains string-encoded binary data,\r\n     * otherwise it must not be set.\r\n     * As (arbitrary) limitation, only 'base64' encoding is supported here.\r\n     * @type {string}\r\n     * @private\r\n     */\r\n    this.datacontentencoding = datacontentencoding\r\n    /**\r\n     * The MIME Type for the encoding of the data attribute, when serialized.\r\n     * @type {string}\r\n     * @private\r\n     */\r\n    this.datacontenttype = datacontenttype\r\n    /**\r\n     * The event timestamp.\r\n     * Copy the original object to avoid changing objects that could be shared.\r\n     * Note that here the object will be transformed into string when serialized.\r\n     * @type {object}\r\n     * @private\r\n     */\r\n    this.time = new Date(time.valueOf())\r\n    /**\r\n     * The URL of schema for the event, if any.\r\n     * @type {uri}\r\n     * @private\r\n     */\r\n    this.schemaurl = schemaurl\r\n    /**\r\n     * The subject of the event in the context of the event producer.\r\n     * @type {string}\r\n     * @private\r\n     */\r\n    this.subject = subject\r\n\r\n    // add strict to extensions, but only when defined\r\n    if (strict === true) {\r\n      this.constructor.setStrictExtensionInEvent(this, strict)\r\n\r\n      const extensionsSize = V.getSize(extensions)\r\n      if (extensionsSize < 1) {\r\n        throw new Error('Unable to create CloudEvent instance, extensions must contain at least 1 property')\r\n      }\r\n      if (V.doesObjectContainsStandardProperty(extensions, CloudEvent.isStandardProperty)) {\r\n        throw new Error('Unable to create CloudEvent instance, extensions contains standard properties')\r\n      }\r\n    }\r\n\r\n    // set extensions\r\n    this.constructor.setExtensionsInEvent(this, extensions)\r\n  }\r\n\r\n  /**\r\n   * Return the version of the CloudEvent Specification implemented here\r\n   *\r\n   * @static\r\n   * @return {string} the value\r\n   */\r\n  static version () {\r\n    return '0.3'\r\n  }\r\n\r\n  /**\r\n   * Return the default data content Type for a CloudEvent\r\n   *\r\n   * @static\r\n   * @return {string} the value\r\n   */\r\n  static datacontenttypeDefault () {\r\n    return 'application/json'\r\n  }\r\n\r\n  /**\r\n   * Return the MIME Type for a CloudEvent\r\n   *\r\n   * @static\r\n   * @return {string} the value\r\n   */\r\n  static mediaType () {\r\n    return 'application/cloudevents+json'\r\n  }\r\n\r\n  /**\r\n   * Tell the data content Type for a CloudEvent,\r\n   * if is a JSON-derived format,\r\n   * so data must be encoded/decoded accordingly.\r\n   *\r\n   * @static\r\n   * @param {!object} event the CloudEvent to validate\r\n   * @return {boolean} true if data content type is JSON-like, otherwise false\r\n   * @throws {TypeError} if event is not a CloudEvent instance or subclass\r\n   * @throws {Error} if event is undefined or null\r\n   */\r\n  static isDatacontenttypeJSONEvent (event) {\r\n    if (!CloudEvent.isCloudEvent(event)) {\r\n      throw new TypeError('The given event is not a CloudEvent instance')\r\n    }\r\n    return (\r\n      (event.datacontenttype === CloudEvent.datacontenttypeDefault()) ||\r\n      (event.datacontenttype.includes('json'))\r\n    )\r\n  }\r\n\r\n  /**\r\n   * Tell if the object has the strict flag enabled.\r\n   *\r\n   * @static\r\n   * @param {!object} event the CloudEvent to validate\r\n   * @return {boolean} true if strict, otherwise false\r\n   * @throws {TypeError} if event is not a CloudEvent instance or subclass\r\n   * @throws {Error} if event is undefined or null\r\n   */\r\n  static isStrictEvent (event) {\r\n    if (!CloudEvent.isCloudEvent(event)) {\r\n      throw new TypeError('The given event is not a CloudEvent instance')\r\n    }\r\n    if (V.isDefinedAndNotNull(event.com_github_smartiniOnGitHub_cloudevent)) {\r\n      return event.com_github_smartiniOnGitHub_cloudevent.strict === true\r\n    } else {\r\n      return false\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set the strict flag into the given extensions object.\r\n   * Should not be used outside CloudEvent constructor.\r\n   *\r\n   * @private\r\n   * @static\r\n   * @param {object} [obj={}] the object with extensions to fill (maybe already populated), that will be enhanced inplace\r\n   * @param {boolean} [strict=false] the flag to set (default false)\r\n   * @throws {TypeError} if obj is not an object, or strict is not a flag\r\n   * @throws {Error} if obj is undefined or null, or strict is undefined or null\r\n   */\r\n  static setStrictExtensionInEvent (obj = {}, strict = false) {\r\n    if (!V.isObject(obj)) {\r\n      throw new TypeError('The given extensions is not an object instance')\r\n    }\r\n    if (!V.isBoolean(strict)) {\r\n      throw new TypeError('The given strict flag is not a boolean instance')\r\n    }\r\n    obj.com_github_smartiniOnGitHub_cloudevent = {}\r\n    obj.com_github_smartiniOnGitHub_cloudevent.strict = strict\r\n  }\r\n\r\n  /**\r\n   * Get the strict flag from the given extensions object.\r\n   * Should not be used outside CloudEvent.\r\n   *\r\n   * @private\r\n   * @static\r\n   * @param {object} [obj={}] the object with extensions to check\r\n   * @return {boolean} the strict flag value, or false if not found\r\n   * @throws {TypeError} if obj is not an object, or strict is not a flag\r\n   * @throws {Error} if obj is undefined or null\r\n   */\r\n  static getStrictExtensionOfEvent (obj = {}) {\r\n    if (!V.isObject(obj)) {\r\n      throw new TypeError('The given extensions is not an object instance')\r\n    }\r\n    const myExtensions = obj.com_github_smartiniOnGitHub_cloudevent || {}\r\n    if (!V.isObjectPlain(myExtensions)) {\r\n      throw new TypeError('The property com_github_smartiniOnGitHub_cloudevent is not an object instance')\r\n    }\r\n    const strict = myExtensions.strict || false\r\n    if (!V.isBoolean(strict)) {\r\n      throw new TypeError('The given strict flag is not a boolean instance')\r\n    }\r\n    return strict\r\n  }\r\n\r\n  /**\r\n   * Set all extensions into the given object.\r\n   * Should not be used outside CloudEvent constructor.\r\n   *\r\n   * @private\r\n   * @static\r\n   * @param {object} [obj={}] the object to fill, that will be enhanced inplace\r\n   * @param {object} [extensions=null] the extensions to fill (maybe already populated)\r\n   * @throws {TypeError} if obj is not an object, or strict is not a flag\r\n   * @throws {Error} if obj is undefined or null, or strict is undefined or null\r\n   */\r\n  static setExtensionsInEvent (obj = {}, extensions = null) {\r\n    if (!V.isObject(obj)) {\r\n      throw new TypeError('The given obj is not an object instance')\r\n    }\r\n    if (!V.isDefinedAndNotNull(extensions)) {\r\n      return\r\n    }\r\n    if (V.isObject(extensions)) {\r\n      const exts = Object.entries(extensions).filter(i => !V.doesStringIsStandardProperty(i[0], CloudEvent.isStandardProperty))\r\n      // add filtered extensions to the given obj\r\n      for (const [key, value] of exts) {\r\n        obj[key] = value\r\n      }\r\n    } else {\r\n      throw new TypeError('Unsupported extensions: not an object or a string')\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get all extensions from the given object.\r\n   * Should not be used outside CloudEvent.\r\n   *\r\n   * @private\r\n   * @static\r\n   * @param {object} [obj={}] the object to check\r\n   * @return {object} an object containins all extensions (non standard properties) found\r\n   * @throws {TypeError} if obj is not an object\r\n   * @throws {Error} if obj is undefined or null\r\n   */\r\n  static getExtensionsOfEvent (obj = {}) {\r\n    const extensions = {}\r\n    if (V.isObject(obj)) {\r\n      const exts = Object.entries(obj).filter(i => !V.doesStringIsStandardProperty(i[0], CloudEvent.isStandardProperty))\r\n      if (exts.length > 0) {\r\n        // add filtered extensions to the given extensions\r\n        for (const [key, value] of exts) {\r\n          extensions[key] = value\r\n        }\r\n      } else {\r\n        // no extensions found, so return a null value\r\n        // (extensions defined but empty are not valid extensions)\r\n        return null\r\n      }\r\n    } else {\r\n      throw new TypeError('Unsupported extensions: not an object or a string')\r\n    }\r\n    return extensions\r\n  }\r\n\r\n  /**\r\n   * Validate the given CloudEvent.\r\n   *\r\n   * @static\r\n   * @param {!object} event the CloudEvent to validate\r\n   * @param {object} [options={}] containing: strict (boolean, default false) to validate it in a more strict way\r\n   * @return {object[]} an array of (non null) validation errors, or at least an empty array\r\n   */\r\n  static validateEvent (event, { strict = false } = {}) {\r\n    if (V.isUndefinedOrNull(event)) {\r\n      return [new Error('CloudEvent undefined or null')]\r\n    }\r\n    if (!CloudEvent.isCloudEvent(event)) {\r\n      return [new TypeError(`The argument must be a CloudEvent (or a subclass), instead got a '${typeof event}'`)]\r\n    }\r\n    const ve = [] // validation errors\r\n\r\n    // standard validation\r\n    // note that some properties are not checked here because I assign a default value, and I check them in strict mode, like:\r\n    // data, time, extensions, datacontenttype ...\r\n    // ve.push(V.ensureIsStringNotEmpty(event.specversion, 'specversion')) // no more a public attribute\r\n    ve.push(V.ensureIsStringNotEmpty(event.id, 'id'))\r\n    ve.push(V.ensureIsStringNotEmpty(event.type, 'type'))\r\n    ve.push(V.ensureIsStringNotEmpty(event.source, 'source'))\r\n    if (V.isDefinedAndNotNull(event.schemaurl)) {\r\n      ve.push(V.ensureIsStringNotEmpty(event.schemaurl, 'schemaurl'))\r\n    }\r\n    if (V.isDefinedAndNotNull(event.subject)) {\r\n      ve.push(V.ensureIsStringNotEmpty(event.subject, 'subject'))\r\n    }\r\n    if (V.isDefinedAndNotNull(event.datacontentencoding)) {\r\n      ve.push(V.ensureIsStringNotEmpty(event.datacontentencoding, 'datacontentencoding'))\r\n    }\r\n\r\n    // additional validation if strict mode enabled, or if enabled in the event ...\r\n    if (strict === true || CloudEvent.isStrictEvent(event) === true) {\r\n      ve.push(V.ensureIsVersion(event.specversion, 'specversion'))\r\n      if (V.isDefinedAndNotNull(event.data)) {\r\n        if (V.isDefinedAndNotNull(event.datacontentencoding)) {\r\n          // ensure data is a string in this case\r\n          ve.push(V.ensureIsString(event.data, 'data'))\r\n        } else if (event.datacontenttype !== CloudEvent.datacontenttypeDefault()) {\r\n          // ensure data is a plain object or collection, or even a string in this case\r\n          // because in serialization/deserialization some validation can occur on the transformed object\r\n          ve.push(V.ensureIsObjectOrCollectionOrString(event.data, 'data'))\r\n        } else {\r\n          // ensure data is a plain object or collection, but not a string in this case\r\n          ve.push(V.ensureIsObjectOrCollectionNotString(event.data, 'data'))\r\n        }\r\n      }\r\n      ve.push(V.ensureIsURI(event.source, null, 'source'))\r\n      ve.push(V.ensureIsDatePast(event.time, 'time'))\r\n      ve.push(V.ensureIsStringNotEmpty(event.datacontenttype, 'datacontenttype'))\r\n      ve.push(V.ensureIsURI(event.schemaurl, null, 'schemaurl'))\r\n      if (V.isDefinedAndNotNull(event.extensions)) {\r\n        // get extensions via its getter\r\n        ve.push(V.ensureIsObjectOrCollectionNotString(event.extensions, 'extensions'))\r\n        // error for extensions defined but empty (without properties), moved in constructor\r\n      }\r\n    }\r\n\r\n    return ve.filter((i) => i)\r\n  }\r\n\r\n  /**\r\n   * Tell the given CloudEvent, if it's valid.\r\n   *\r\n   * See {@link CloudEvent.validateEvent}.\r\n   *\r\n   * @static\r\n   * @param {!object} event the CloudEvent to validate\r\n   * @param {object} [options={}] containing: strict (boolean, default false) to validate it in a more strict way\r\n   * @return {boolean} true if valid, otherwise false\r\n   */\r\n  static isValidEvent (event, { strict = false } = {}) {\r\n    const validationErrors = CloudEvent.validateEvent(event, { strict })\r\n    const size = V.getSize(validationErrors)\r\n    return (size === 0)\r\n  }\r\n\r\n  /**\r\n   * Tell the given CloudEvent, if it's instance of the CloudEvent class or a subclass of it.\r\n   *\r\n   * @static\r\n   * @param {!object} event the CloudEvent to check\r\n   * @return {boolean} true if it's an instance (or a subclass), otherwise false\r\n   * @throws {Error} if event is undefined or null\r\n   */\r\n  static isCloudEvent (event) {\r\n    if (V.isUndefinedOrNull(event)) {\r\n      throw new Error('CloudEvent undefined or null')\r\n    }\r\n    return V.isClass(event, CloudEvent)\r\n  }\r\n\r\n  /**\r\n   * Serialize the given CloudEvent in JSON format.\r\n   * Note that here standard serialization to JSON is used (no additional libraries).\r\n   * Note that the result of encoder function is assigned to encoded data.\r\n   *\r\n   * @static\r\n   * @param {!object} event the CloudEvent to serialize\r\n   * @param {object} [options={}] optional serialization attributes:\r\n   *        encoder (function, no default) a function that takes data and returns encoded data as a string,\r\n   *        encodedData (string, no default) already encoded data (but consistency with the datacontenttype is not checked),\r\n   *        onlyValid (boolean, default false) to serialize only if it's a valid instance,\r\n   *        onlyIfLessThan64KB (boolean, default false) to return the serialized string only if it's less than 64 KB,\r\n   * @return {string} the serialized event, as a string\r\n   * @throws {Error} if event is undefined or null, or an option is undefined/null/wrong\r\n   */\r\n  static serializeEvent (event, {\r\n    encoder, encodedData,\r\n    onlyValid = false, onlyIfLessThan64KB = false\r\n  } = {}) {\r\n    if (V.isUndefinedOrNull(event)) throw new Error('CloudEvent undefined or null')\r\n    if (event.datacontenttype === CloudEvent.datacontenttypeDefault()) {\r\n      if ((onlyValid === false) || (onlyValid === true && CloudEvent.isValidEvent(event) === true)) {\r\n        const ser = JSON.stringify(event, function replacer (key, value) {\r\n          switch (key) {\r\n            case 'data':\r\n              // return data as is, or encoded or nothing (if not supported)\r\n              if (V.isUndefinedOrNull(event.datacontentencoding)) return value\r\n              if (event.datacontentencoding === 'Base64') return T.stringToBase64(this.data)\r\n              else return undefined\r\n            case 'extensions':\r\n              // filtering out top level extensions (if any)\r\n              return undefined\r\n            default:\r\n              return value\r\n          }\r\n        })\r\n        if ((onlyIfLessThan64KB === false) || (onlyIfLessThan64KB === true && V.getSizeInBytes(ser) < 65536)) return ser\r\n        else throw new Error('Unable to return a serialized CloudEvent bigger than 64 KB.')\r\n      } else throw new Error('Unable to serialize a not valid CloudEvent.')\r\n    }\r\n    // else (non defaut datacontenttype)\r\n    if (V.isDefinedAndNotNull(encoder)) {\r\n      if (!V.isFunction(encoder)) throw new Error(`Missing or wrong encoder function: '${encoder}' for the given content type: '${event.datacontenttype}'.`)\r\n      encodedData = encoder(event.payload)\r\n    } else {\r\n      // encoder not defined, check encodedData\r\n      if (!V.isDefinedAndNotNull(encodedData)) throw new Error(`Missing encoder function: use encoder function or already encoded data with the given data content type: '${event.datacontenttype}'.`)\r\n    }\r\n    if (!V.isStringNotEmpty(encodedData)) throw new Error(`Missing or wrong encoded data: '${encodedData}' for the given data content type: '${event.datacontenttype}'.`)\r\n    const newEvent = T.mergeObjects(event, { data: encodedData })\r\n    if ((onlyValid === false) || (onlyValid === true && CloudEvent.isValidEvent(newEvent) === true)) {\r\n      const ser = JSON.stringify(newEvent)\r\n      if ((onlyIfLessThan64KB === false) || (onlyIfLessThan64KB === true && V.getSizeInBytes(ser) < 65536)) return ser\r\n      else throw new Error('Unable to return a serialized CloudEvent bigger than 64 KB.')\r\n    } else throw new Error('Unable to serialize a not valid CloudEvent.')\r\n  }\r\n\r\n  /**\r\n   * Deserialize/parse the given CloudEvent from JSON format.\r\n   * Note that here standard parse from JSON is used (no additional libraries).\r\n   * Note that the result of decoder function is assigned to decoded data.\r\n   *\r\n   * @static\r\n   * @param {!string} ser the serialized CloudEvent to parse/deserialize\r\n   * @param {object} [options={}] optional deserialization attributes:\r\n   *        decoder (function, no default) a function that takes data and returns decoder data as a string,\r\n   *        decodedData (string, no default) already decoded data (but consistency with the datacontenttype is not checked),\r\n   *        onlyValid (boolean, default false) to deserialize only if it's a valid instance,\r\n   *        onlyIfLessThan64KB (boolean, default false) to return the deserialized string only if it's less than 64 KB,\r\n   *        timezoneOffset (number, default 0) to apply a different timezone offset\r\n   * @return {object} the deserialized event as a CloudEvent instance\r\n   * @throws {Error} if ser is undefined or null, or an option is undefined/null/wrong\r\n   * @throws {Error} in case of JSON parsing error\r\n   */\r\n  static deserializeEvent (ser, {\r\n    decoder, decodedData,\r\n    onlyValid = false, onlyIfLessThan64KB = false,\r\n    timezoneOffset = 0\r\n  } = {}) {\r\n    if (V.isUndefinedOrNull(ser)) throw new Error('Serialized CloudEvent undefined or null')\r\n    if (!V.isStringNotEmpty(ser)) throw new Error(`Missing or wrong serialized data: '${ser}' must be a string and not a: '${typeof ser}'.`)\r\n    // deserialize standard attributes, always in JSON format\r\n    const parsed = JSON.parse(ser)\r\n    // ensure it's an object (single), and not a string neither a collection or an array\r\n    if (!V.isObject(parsed) || V.isArray(parsed)) throw new Error(`Wrong deserialized data: '${ser}' must represent an object and not an array or a string or other.`)\r\n\r\n    const strict = CloudEvent.getStrictExtensionOfEvent(parsed)\r\n    const extensions = CloudEvent.getExtensionsOfEvent(parsed)\r\n\r\n    if (V.isDefinedAndNotNull(parsed.datacontentencoding)) {\r\n      if (V.isStringNotEmpty(parsed.data)) {\r\n        // decode the given data\r\n        if (parsed.datacontentencoding === 'Base64') parsed.data = T.stringFromBase64(parsed.data)\r\n      }\r\n    }\r\n\r\n    // fill a new CludEvent instance with parsed data\r\n    const ce = new CloudEvent(parsed.id,\r\n      parsed.type,\r\n      parsed.source,\r\n      parsed.data,\r\n      { // options\r\n        time: T.timestampFromString(parsed.time, timezoneOffset),\r\n        datacontentencoding: parsed.datacontentencoding,\r\n        datacontenttype: parsed.datacontenttype,\r\n        schemaurl: parsed.schemaurl,\r\n        subject: parsed.subject,\r\n        strict: strict\r\n      },\r\n      extensions\r\n    )\r\n    // depending on the datacontenttype, decode the data attribute (the payload)\r\n    if (parsed.datacontenttype === CloudEvent.datacontenttypeDefault()) {\r\n      // return ce, depending on its validation option\r\n      if ((onlyValid === false) || (onlyValid === true && CloudEvent.isValidEvent(ce) === true)) {\r\n        if ((onlyIfLessThan64KB === false) || (onlyIfLessThan64KB === true && V.getSizeInBytes(ser) < 65536)) return ce\r\n        else throw new Error('Unable to return a deserialized CloudEvent bigger than 64 KB.')\r\n      } else throw new Error('Unable to deserialize a not valid CloudEvent.')\r\n    }\r\n    // else (non defaut datacontenttype)\r\n    if (V.isDefinedAndNotNull(decoder)) {\r\n      if (!V.isFunction(decoder)) throw new Error(`Missing or wrong decoder function: '${decoder}' for the given data content type: '${parsed.datacontenttype}'.`)\r\n      decodedData = decoder(parsed.data)\r\n    } else {\r\n      // decoder not defined, so decodedData must be defined\r\n      if (!V.isDefinedAndNotNull(decodedData)) throw new Error(`Missing decoder function: use decoder function or already decoded data with the given data content type: '${parsed.datacontenttype}'.`)\r\n    }\r\n    if (!V.isObjectOrCollectionOrString(decodedData)) throw new Error(`Missing or wrong decoded data: '${decodedData}' for the given data content type: '${parsed.datacontenttype}'.`)\r\n    // overwrite data with decodedData before returning it\r\n    ce.data = decodedData\r\n    // return ce, depending on its validation option\r\n    if ((onlyValid === false) || (onlyValid === true && CloudEvent.isValidEvent(ce) === true)) {\r\n      if ((onlyIfLessThan64KB === false) || (onlyIfLessThan64KB === true && V.getSizeInBytes(ser) < 65536)) return ce\r\n      else throw new Error('Unable to return a deserialized CloudEvent bigger than 64 KB.')\r\n    } else throw new Error('Unable to deserialize a not valid CloudEvent.')\r\n  }\r\n\r\n  /**\r\n   * Tell the given property, if it's a standard CloudEvent property/attribute.\r\n   *\r\n   * @static\r\n   * @param {!string} property the property/attribute to check\r\n   * @return {boolean} true if it's standard otherwise false\r\n   */\r\n  static isStandardProperty (property) {\r\n    return CloudEvent.standardProps.includes(property)\r\n  }\r\n\r\n  /**\r\n   * Tell the given property, if it's an extension CloudEvent property/attribute.\r\n   *\r\n   * @static\r\n   * @param {!string} property the property/attribute to check\r\n   * @return {boolean} true if it's an extension (not standard) otherwise false\r\n   */\r\n  static isExtensionProperty (property) {\r\n    return !CloudEvent.standardProps.includes(property)\r\n  }\r\n\r\n  /**\r\n   * Get the JSON Schema for a CloudEvent.\r\n   * Note that it's not used in standard serialization to JSON,\r\n   * but only in some serialization libraries.\r\n   * Note that schema definitions for data and extensions are right,\r\n   * but I need to keep them commented here and to set the flag\r\n   * additionalProperties to true,\r\n   * or when used both data and extensions will be empty in JSON output.\r\n   * Note that for time I had to keep its schema definition commented\r\n   * or schema validation on object instances would fail (because in the\r\n   * object model I store it as a timestamp/date currently and not as a string).\r\n   *\r\n   * See JSON Schema.\r\n   *\r\n   * @static\r\n   * @return {object} the JSON Schema\r\n   */\r\n  static getJSONSchema () {\r\n    // define a schema for serializing a CloudEvent object to JSON\r\n    // note that properties not in the schema will be ignored\r\n    // (in json output) by some json serialization libraries, if additionalProperties is false\r\n    return {\r\n      title: 'CloudEvent Schema with required fields',\r\n      type: 'object',\r\n      properties: {\r\n        specversion: { type: 'string', minLength: 1 },\r\n        id: { type: 'string', minLength: 1 },\r\n        type: { type: 'string', minLength: 1 },\r\n        source: { type: 'string', format: 'uri-reference' },\r\n        datacontenttype: { type: 'string' },\r\n        // data: { type: ['object', 'string'] },\r\n        // time: { type: 'string', format: 'date-time' },\r\n        schemaurl: { type: 'string', format: 'uri-reference' },\r\n        subject: { type: 'string', minLength: 1 }\r\n      },\r\n      required: [\r\n        'specversion', 'id', 'type', 'source'\r\n      ],\r\n      additionalProperties: true // to handle data, and maybe other (non-standard) properties (extensions)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Serialize the current CloudEvent.\r\n   *\r\n   * See {@link CloudEvent.serializeEvent}.\r\n   *\r\n   * @param {object} [options={}] optional serialization attributes:\r\n   *        encoder (function, default null) a function that takes data and returns encoded data,\r\n   *        encodedData (string, default null) already encoded data (but consistency with the datacontenttype is not checked),\r\n   * @return {string} the serialized event, as a string\r\n   */\r\n  serialize ({ encoder, encodedData } = {}) {\r\n    return this.constructor.serializeEvent(this, { encoder, encodedData })\r\n  }\r\n\r\n  /**\r\n   * Validate the current CloudEvent.\r\n   *\r\n   * See {@link CloudEvent.validateEvent}.\r\n   *\r\n   * @param {object} [options={}] containing: strict (boolean, default false) to validate it in a more strict way\r\n   * @return {object[]} an array of (non null) validation errors, or at least an empty array\r\n   */\r\n  validate ({ strict = false } = {}) {\r\n    return this.constructor.validateEvent(this, { strict })\r\n  }\r\n\r\n  /**\r\n   * Tell the current CloudEvent, if it's valid.\r\n   *\r\n   * See {@link CloudEvent.isValidEvent}.\r\n   *\r\n   * @param {object} [options={}] containing: strict (boolean, default false) to validate it in a more strict way\r\n   * @return {boolean} true if valid, otherwise false\r\n   */\r\n  isValid ({ strict = false } = {}) {\r\n    return this.constructor.isValidEvent(this, { strict })\r\n  }\r\n\r\n  /**\r\n   * Getter method to tell if data content type is a JSON-derived format,\r\n   * so data must be encoded/decoded accordingly.\r\n   *\r\n   * See {@link CloudEvent.isDatacontenttypeJSONEvent}.\r\n   *\r\n   * @type {boolean}\r\n   */\r\n  get isDatacontenttypeJSON () {\r\n    return this.constructor.isDatacontenttypeJSONEvent(this)\r\n  }\r\n\r\n  /**\r\n   * Getter method to tell if the object has the strict flag enabled.\r\n   *\r\n   * See {@link CloudEvent.isStrictEvent}.\r\n   *\r\n   * @type {boolean}\r\n   */\r\n  get isStrict () {\r\n    return this.constructor.isStrictEvent(this)\r\n  }\r\n\r\n  /**\r\n   * Getter method to return JSON Schema for a CloudEvent.\r\n   *\r\n   * See {@link CloudEvent.getJSONSchema}.\r\n   *\r\n   * @type {object}\r\n   */\r\n  get schema () {\r\n    return this.constructor.getJSONSchema()\r\n  }\r\n\r\n  /**\r\n   * Getter method to return a copy of CloudEvent data attribute,\r\n   * or original data payload.\r\n   *\r\n   * See {@link CloudEvent.data}.\r\n   *\r\n   * @type {(object|Map|Set)}\r\n   */\r\n  get payload () {\r\n    if (V.isString(this.data)) {\r\n      // handle an edge case: if data is a String, I need to clone in a different way ...\r\n      return this.data.slice()\r\n    }\r\n    // else\r\n    return { ...this.data }\r\n  }\r\n\r\n  /**\r\n   * Getter method to return a copy of CloudEvent extensions.\r\n   *\r\n   * See {@link CloudEvent.getExtensionsOfEvent}.\r\n   *\r\n   * @type {object}\r\n   */\r\n  get extensions () {\r\n    return this.constructor.getExtensionsOfEvent(this)\r\n  }\r\n\r\n  /**\r\n   * Override the usual toString method,\r\n   * to show a summary (only some info) on current instance.\r\n   * Note that the representation of the 'data' attribute is\r\n   * limited to 1024 chars (arbitrary limit, set here including the trim marker),\r\n   * to avoid too much overhead with instances with a big 'data' attribute.\r\n   *\r\n   * See {@link Object.toString}.\r\n   *\r\n   * @return {string} a string representation for object instance\r\n   */\r\n  toString () {\r\n    const dataDumped = T.dumpObject(this.data, 'data')\r\n    const dataSummary = (dataDumped.length < 1024) ? dataDumped : (dataDumped.substr(0, 1019) + ' ...}')\r\n    return `CloudEvent[specversion: ${this.specversion}, ${T.dumpObject(this.id, 'id')}, ${T.dumpObject(this.type, 'type')}, ${dataSummary}, ...]`\r\n  }\r\n\r\n  /**\r\n   * Gives a string valued property that is used in the creation of the default string description of an object.\r\n   *\r\n   * See {@link Symbol.toStringTag}.\r\n   *\r\n   * @return {string} a string representation of the object type\r\n   */\r\n  get [Symbol.toStringTag] () {\r\n    return 'CloudEvent'\r\n  }\r\n}\r\n\r\n/**\r\n * Utility variable that returns all standard property names, in an array.\r\n *\r\n * @static\r\n */\r\nCloudEvent.standardProps = [\r\n  'specversion',\r\n  'id', 'type', 'source', 'data',\r\n  'time', 'datacontentencoding', 'datacontenttype',\r\n  'schemaurl', 'subject'\r\n]\r\n\r\nmodule.exports = CloudEvent\r\n",
    "static": true,
    "longname": "/Users/martinis/work/prove/cloudevent.js/src/cloudevent.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 49,
    "kind": "class",
    "name": "CloudEvent",
    "memberof": "src/cloudevent.js",
    "static": true,
    "longname": "src/cloudevent.js~CloudEvent",
    "access": "public",
    "export": true,
    "importPath": "cloudevent/src/cloudevent.js",
    "importStyle": "CloudEvent",
    "description": "CloudEvent implementation.",
    "see": [
      "https://github.com/cloudevents/spec/blob/master/json-format.md"
    ],
    "lineNumber": 42,
    "interface": false
  },
  {
    "__docId__": 50,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/cloudevent.js~CloudEvent",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cloudevent.js~CloudEvent#constructor",
    "access": "public",
    "description": "Create a new instance of a CloudEvent object.",
    "lineNumber": 60,
    "params": [
      {
        "nullable": false,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": "the ID of the event (unique), mandatory"
      },
      {
        "nullable": false,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "type",
        "description": "the type of the event (usually prefixed with a reverse-DNS name), mandatory"
      },
      {
        "nullable": false,
        "types": [
          "uri"
        ],
        "spread": false,
        "optional": false,
        "name": "source",
        "description": "the source uri of the event (use '/' if empty), mandatory"
      },
      {
        "nullable": true,
        "types": [
          "object",
          "Map",
          "Set",
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": "the real event data"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{}",
        "defaultRaw": {},
        "name": "options",
        "description": "optional attributes of the event; some has default values chosen here:\n       time (timestamp/date, default now),\n       datacontentencoding (string) optional in most cases here,\n       datacontenttype (string, default 'application/json') tell how the data attribute must be encoded,\n       schemaurl (uri) optional,\n       subject (string) optional, describes the subject of the event in the context of the event producer (identified by source),\n       strict (boolean, default false) tell if object instance will be validated in a more strict way"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "extensions",
        "description": "optional, contains extension properties (recommended in nested objects) but if given any object must contain at least 1 property (key/value)"
      }
    ],
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "if strict is true and id or type is undefined or null"
      },
      {
        "types": [
          "Error"
        ],
        "description": "if datacontentencoding is defined and data is not a string or if encoding is not 'base64'"
      }
    ]
  },
  {
    "__docId__": 51,
    "kind": "member",
    "name": "id",
    "memberof": "src/cloudevent.js~CloudEvent",
    "static": false,
    "longname": "src/cloudevent.js~CloudEvent#id",
    "access": "private",
    "description": "The event ID.",
    "lineNumber": 81,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 52,
    "kind": "member",
    "name": "type",
    "memberof": "src/cloudevent.js~CloudEvent",
    "static": false,
    "longname": "src/cloudevent.js~CloudEvent#type",
    "access": "private",
    "description": "The event type.",
    "lineNumber": 87,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 53,
    "kind": "member",
    "name": "source",
    "memberof": "src/cloudevent.js~CloudEvent",
    "static": false,
    "longname": "src/cloudevent.js~CloudEvent#source",
    "access": "private",
    "description": "The source URI of the event.",
    "lineNumber": 93,
    "type": {
      "nullable": null,
      "types": [
        "uri"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 54,
    "kind": "member",
    "name": "data",
    "memberof": "src/cloudevent.js~CloudEvent",
    "static": false,
    "longname": "src/cloudevent.js~CloudEvent#data",
    "access": "public",
    "description": null,
    "lineNumber": 103,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 57,
    "kind": "member",
    "name": "specversion",
    "memberof": "src/cloudevent.js~CloudEvent",
    "static": false,
    "longname": "src/cloudevent.js~CloudEvent#specversion",
    "access": "private",
    "description": "The CloudEvent specification version.",
    "lineNumber": 117,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 58,
    "kind": "member",
    "name": "datacontentencoding",
    "memberof": "src/cloudevent.js~CloudEvent",
    "static": false,
    "longname": "src/cloudevent.js~CloudEvent#datacontentencoding",
    "access": "private",
    "description": "The content encoding for the data attribute\nfor when the data field must be encoded as a string.\nThis must be set if the data attribute contains string-encoded binary data,\notherwise it must not be set.\nAs (arbitrary) limitation, only 'base64' encoding is supported here.",
    "lineNumber": 127,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 59,
    "kind": "member",
    "name": "datacontenttype",
    "memberof": "src/cloudevent.js~CloudEvent",
    "static": false,
    "longname": "src/cloudevent.js~CloudEvent#datacontenttype",
    "access": "private",
    "description": "The MIME Type for the encoding of the data attribute, when serialized.",
    "lineNumber": 133,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 60,
    "kind": "member",
    "name": "time",
    "memberof": "src/cloudevent.js~CloudEvent",
    "static": false,
    "longname": "src/cloudevent.js~CloudEvent#time",
    "access": "private",
    "description": "The event timestamp.\nCopy the original object to avoid changing objects that could be shared.\nNote that here the object will be transformed into string when serialized.",
    "lineNumber": 141,
    "type": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 61,
    "kind": "member",
    "name": "schemaurl",
    "memberof": "src/cloudevent.js~CloudEvent",
    "static": false,
    "longname": "src/cloudevent.js~CloudEvent#schemaurl",
    "access": "private",
    "description": "The URL of schema for the event, if any.",
    "lineNumber": 147,
    "type": {
      "nullable": null,
      "types": [
        "uri"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 62,
    "kind": "member",
    "name": "subject",
    "memberof": "src/cloudevent.js~CloudEvent",
    "static": false,
    "longname": "src/cloudevent.js~CloudEvent#subject",
    "access": "private",
    "description": "The subject of the event in the context of the event producer.",
    "lineNumber": 153,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 63,
    "kind": "method",
    "name": "version",
    "memberof": "src/cloudevent.js~CloudEvent",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/cloudevent.js~CloudEvent.version",
    "access": "public",
    "description": "Return the version of the CloudEvent Specification implemented here",
    "lineNumber": 178,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "the value"
    },
    "params": []
  },
  {
    "__docId__": 64,
    "kind": "method",
    "name": "datacontenttypeDefault",
    "memberof": "src/cloudevent.js~CloudEvent",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/cloudevent.js~CloudEvent.datacontenttypeDefault",
    "access": "public",
    "description": "Return the default data content Type for a CloudEvent",
    "lineNumber": 188,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "the value"
    },
    "params": []
  },
  {
    "__docId__": 65,
    "kind": "method",
    "name": "mediaType",
    "memberof": "src/cloudevent.js~CloudEvent",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/cloudevent.js~CloudEvent.mediaType",
    "access": "public",
    "description": "Return the MIME Type for a CloudEvent",
    "lineNumber": 198,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "the value"
    },
    "params": []
  },
  {
    "__docId__": 66,
    "kind": "method",
    "name": "isDatacontenttypeJSONEvent",
    "memberof": "src/cloudevent.js~CloudEvent",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/cloudevent.js~CloudEvent.isDatacontenttypeJSONEvent",
    "access": "public",
    "description": "Tell the data content Type for a CloudEvent,\nif is a JSON-derived format,\nso data must be encoded/decoded accordingly.",
    "lineNumber": 213,
    "params": [
      {
        "nullable": false,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "event",
        "description": "the CloudEvent to validate"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if data content type is JSON-like, otherwise false"
    },
    "throws": [
      {
        "types": [
          "TypeError"
        ],
        "description": "if event is not a CloudEvent instance or subclass"
      },
      {
        "types": [
          "Error"
        ],
        "description": "if event is undefined or null"
      }
    ]
  },
  {
    "__docId__": 67,
    "kind": "method",
    "name": "isStrictEvent",
    "memberof": "src/cloudevent.js~CloudEvent",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/cloudevent.js~CloudEvent.isStrictEvent",
    "access": "public",
    "description": "Tell if the object has the strict flag enabled.",
    "lineNumber": 232,
    "params": [
      {
        "nullable": false,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "event",
        "description": "the CloudEvent to validate"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if strict, otherwise false"
    },
    "throws": [
      {
        "types": [
          "TypeError"
        ],
        "description": "if event is not a CloudEvent instance or subclass"
      },
      {
        "types": [
          "Error"
        ],
        "description": "if event is undefined or null"
      }
    ]
  },
  {
    "__docId__": 68,
    "kind": "method",
    "name": "setStrictExtensionInEvent",
    "memberof": "src/cloudevent.js~CloudEvent",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/cloudevent.js~CloudEvent.setStrictExtensionInEvent",
    "access": "private",
    "description": "Set the strict flag into the given extensions object.\nShould not be used outside CloudEvent constructor.",
    "lineNumber": 254,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{}",
        "defaultRaw": {},
        "name": "obj",
        "description": "the object with extensions to fill (maybe already populated), that will be enhanced inplace"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "strict",
        "description": "the flag to set (default false)"
      }
    ],
    "throws": [
      {
        "types": [
          "TypeError"
        ],
        "description": "if obj is not an object, or strict is not a flag"
      },
      {
        "types": [
          "Error"
        ],
        "description": "if obj is undefined or null, or strict is undefined or null"
      }
    ],
    "return": null
  },
  {
    "__docId__": 69,
    "kind": "method",
    "name": "getStrictExtensionOfEvent",
    "memberof": "src/cloudevent.js~CloudEvent",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/cloudevent.js~CloudEvent.getStrictExtensionOfEvent",
    "access": "private",
    "description": "Get the strict flag from the given extensions object.\nShould not be used outside CloudEvent.",
    "lineNumber": 276,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{}",
        "defaultRaw": {},
        "name": "obj",
        "description": "the object with extensions to check"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "the strict flag value, or false if not found"
    },
    "throws": [
      {
        "types": [
          "TypeError"
        ],
        "description": "if obj is not an object, or strict is not a flag"
      },
      {
        "types": [
          "Error"
        ],
        "description": "if obj is undefined or null"
      }
    ]
  },
  {
    "__docId__": 70,
    "kind": "method",
    "name": "setExtensionsInEvent",
    "memberof": "src/cloudevent.js~CloudEvent",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/cloudevent.js~CloudEvent.setExtensionsInEvent",
    "access": "private",
    "description": "Set all extensions into the given object.\nShould not be used outside CloudEvent constructor.",
    "lineNumber": 302,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{}",
        "defaultRaw": {},
        "name": "obj",
        "description": "the object to fill, that will be enhanced inplace"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "null",
        "defaultRaw": null,
        "name": "extensions",
        "description": "the extensions to fill (maybe already populated)"
      }
    ],
    "throws": [
      {
        "types": [
          "TypeError"
        ],
        "description": "if obj is not an object, or strict is not a flag"
      },
      {
        "types": [
          "Error"
        ],
        "description": "if obj is undefined or null, or strict is undefined or null"
      }
    ],
    "return": null
  },
  {
    "__docId__": 71,
    "kind": "method",
    "name": "getExtensionsOfEvent",
    "memberof": "src/cloudevent.js~CloudEvent",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/cloudevent.js~CloudEvent.getExtensionsOfEvent",
    "access": "private",
    "description": "Get all extensions from the given object.\nShould not be used outside CloudEvent.",
    "lineNumber": 331,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{}",
        "defaultRaw": {},
        "name": "obj",
        "description": "the object to check"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "an object containins all extensions (non standard properties) found"
    },
    "throws": [
      {
        "types": [
          "TypeError"
        ],
        "description": "if obj is not an object"
      },
      {
        "types": [
          "Error"
        ],
        "description": "if obj is undefined or null"
      }
    ]
  },
  {
    "__docId__": 72,
    "kind": "method",
    "name": "validateEvent",
    "memberof": "src/cloudevent.js~CloudEvent",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/cloudevent.js~CloudEvent.validateEvent",
    "access": "public",
    "description": "Validate the given CloudEvent.",
    "lineNumber": 359,
    "params": [
      {
        "nullable": false,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "event",
        "description": "the CloudEvent to validate"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{}",
        "defaultRaw": {},
        "name": "options",
        "description": "containing: strict (boolean, default false) to validate it in a more strict way"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object[]"
      ],
      "spread": false,
      "description": "an array of (non null) validation errors, or at least an empty array"
    }
  },
  {
    "__docId__": 73,
    "kind": "method",
    "name": "isValidEvent",
    "memberof": "src/cloudevent.js~CloudEvent",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/cloudevent.js~CloudEvent.isValidEvent",
    "access": "public",
    "description": "Tell the given CloudEvent, if it's valid.\n\nSee {@link CloudEvent.validateEvent}.",
    "lineNumber": 425,
    "params": [
      {
        "nullable": false,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "event",
        "description": "the CloudEvent to validate"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{}",
        "defaultRaw": {},
        "name": "options",
        "description": "containing: strict (boolean, default false) to validate it in a more strict way"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if valid, otherwise false"
    }
  },
  {
    "__docId__": 74,
    "kind": "method",
    "name": "isCloudEvent",
    "memberof": "src/cloudevent.js~CloudEvent",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/cloudevent.js~CloudEvent.isCloudEvent",
    "access": "public",
    "description": "Tell the given CloudEvent, if it's instance of the CloudEvent class or a subclass of it.",
    "lineNumber": 439,
    "params": [
      {
        "nullable": false,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "event",
        "description": "the CloudEvent to check"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if it's an instance (or a subclass), otherwise false"
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "if event is undefined or null"
      }
    ]
  },
  {
    "__docId__": 75,
    "kind": "method",
    "name": "serializeEvent",
    "memberof": "src/cloudevent.js~CloudEvent",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/cloudevent.js~CloudEvent.serializeEvent",
    "access": "public",
    "description": "Serialize the given CloudEvent in JSON format.\nNote that here standard serialization to JSON is used (no additional libraries).\nNote that the result of encoder function is assigned to encoded data.",
    "lineNumber": 461,
    "params": [
      {
        "nullable": false,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "event",
        "description": "the CloudEvent to serialize"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{}",
        "defaultRaw": {},
        "name": "options",
        "description": "optional serialization attributes:\n       encoder (function, no default) a function that takes data and returns encoded data as a string,\n       encodedData (string, no default) already encoded data (but consistency with the datacontenttype is not checked),\n       onlyValid (boolean, default false) to serialize only if it's a valid instance,\n       onlyIfLessThan64KB (boolean, default false) to return the serialized string only if it's less than 64 KB,"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "the serialized event, as a string"
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "if event is undefined or null, or an option is undefined/null/wrong"
      }
    ]
  },
  {
    "__docId__": 76,
    "kind": "method",
    "name": "deserializeEvent",
    "memberof": "src/cloudevent.js~CloudEvent",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/cloudevent.js~CloudEvent.deserializeEvent",
    "access": "public",
    "description": "Deserialize/parse the given CloudEvent from JSON format.\nNote that here standard parse from JSON is used (no additional libraries).\nNote that the result of decoder function is assigned to decoded data.",
    "lineNumber": 520,
    "params": [
      {
        "nullable": false,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "ser",
        "description": "the serialized CloudEvent to parse/deserialize"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{}",
        "defaultRaw": {},
        "name": "options",
        "description": "optional deserialization attributes:\n       decoder (function, no default) a function that takes data and returns decoder data as a string,\n       decodedData (string, no default) already decoded data (but consistency with the datacontenttype is not checked),\n       onlyValid (boolean, default false) to deserialize only if it's a valid instance,\n       onlyIfLessThan64KB (boolean, default false) to return the deserialized string only if it's less than 64 KB,\n       timezoneOffset (number, default 0) to apply a different timezone offset"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "the deserialized event as a CloudEvent instance"
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "if ser is undefined or null, or an option is undefined/null/wrong"
      },
      {
        "types": [
          "Error"
        ],
        "description": "in case of JSON parsing error"
      }
    ]
  },
  {
    "__docId__": 77,
    "kind": "method",
    "name": "isStandardProperty",
    "memberof": "src/cloudevent.js~CloudEvent",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/cloudevent.js~CloudEvent.isStandardProperty",
    "access": "public",
    "description": "Tell the given property, if it's a standard CloudEvent property/attribute.",
    "lineNumber": 590,
    "params": [
      {
        "nullable": false,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "property",
        "description": "the property/attribute to check"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if it's standard otherwise false"
    }
  },
  {
    "__docId__": 78,
    "kind": "method",
    "name": "isExtensionProperty",
    "memberof": "src/cloudevent.js~CloudEvent",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/cloudevent.js~CloudEvent.isExtensionProperty",
    "access": "public",
    "description": "Tell the given property, if it's an extension CloudEvent property/attribute.",
    "lineNumber": 601,
    "params": [
      {
        "nullable": false,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "property",
        "description": "the property/attribute to check"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if it's an extension (not standard) otherwise false"
    }
  },
  {
    "__docId__": 79,
    "kind": "method",
    "name": "getJSONSchema",
    "memberof": "src/cloudevent.js~CloudEvent",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/cloudevent.js~CloudEvent.getJSONSchema",
    "access": "public",
    "description": "Get the JSON Schema for a CloudEvent.\nNote that it's not used in standard serialization to JSON,\nbut only in some serialization libraries.\nNote that schema definitions for data and extensions are right,\nbut I need to keep them commented here and to set the flag\nadditionalProperties to true,\nor when used both data and extensions will be empty in JSON output.\nNote that for time I had to keep its schema definition commented\nor schema validation on object instances would fail (because in the\nobject model I store it as a timestamp/date currently and not as a string).\n\nSee JSON Schema.",
    "lineNumber": 622,
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "the JSON Schema"
    },
    "params": []
  },
  {
    "__docId__": 80,
    "kind": "method",
    "name": "serialize",
    "memberof": "src/cloudevent.js~CloudEvent",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cloudevent.js~CloudEvent#serialize",
    "access": "public",
    "description": "Serialize the current CloudEvent.\n\nSee {@link CloudEvent.serializeEvent}.",
    "lineNumber": 657,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{}",
        "defaultRaw": {},
        "name": "options",
        "description": "optional serialization attributes:\n       encoder (function, default null) a function that takes data and returns encoded data,\n       encodedData (string, default null) already encoded data (but consistency with the datacontenttype is not checked),"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "the serialized event, as a string"
    }
  },
  {
    "__docId__": 81,
    "kind": "method",
    "name": "validate",
    "memberof": "src/cloudevent.js~CloudEvent",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cloudevent.js~CloudEvent#validate",
    "access": "public",
    "description": "Validate the current CloudEvent.\n\nSee {@link CloudEvent.validateEvent}.",
    "lineNumber": 669,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{}",
        "defaultRaw": {},
        "name": "options",
        "description": "containing: strict (boolean, default false) to validate it in a more strict way"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object[]"
      ],
      "spread": false,
      "description": "an array of (non null) validation errors, or at least an empty array"
    }
  },
  {
    "__docId__": 82,
    "kind": "method",
    "name": "isValid",
    "memberof": "src/cloudevent.js~CloudEvent",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cloudevent.js~CloudEvent#isValid",
    "access": "public",
    "description": "Tell the current CloudEvent, if it's valid.\n\nSee {@link CloudEvent.isValidEvent}.",
    "lineNumber": 681,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{}",
        "defaultRaw": {},
        "name": "options",
        "description": "containing: strict (boolean, default false) to validate it in a more strict way"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if valid, otherwise false"
    }
  },
  {
    "__docId__": 83,
    "kind": "get",
    "name": "isDatacontenttypeJSON",
    "memberof": "src/cloudevent.js~CloudEvent",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cloudevent.js~CloudEvent#isDatacontenttypeJSON",
    "access": "public",
    "description": "Getter method to tell if data content type is a JSON-derived format,\nso data must be encoded/decoded accordingly.\n\nSee {@link CloudEvent.isDatacontenttypeJSONEvent}.",
    "lineNumber": 693,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 84,
    "kind": "get",
    "name": "isStrict",
    "memberof": "src/cloudevent.js~CloudEvent",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cloudevent.js~CloudEvent#isStrict",
    "access": "public",
    "description": "Getter method to tell if the object has the strict flag enabled.\n\nSee {@link CloudEvent.isStrictEvent}.",
    "lineNumber": 704,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 85,
    "kind": "get",
    "name": "schema",
    "memberof": "src/cloudevent.js~CloudEvent",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cloudevent.js~CloudEvent#schema",
    "access": "public",
    "description": "Getter method to return JSON Schema for a CloudEvent.\n\nSee {@link CloudEvent.getJSONSchema}.",
    "lineNumber": 715,
    "type": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 86,
    "kind": "get",
    "name": "payload",
    "memberof": "src/cloudevent.js~CloudEvent",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cloudevent.js~CloudEvent#payload",
    "access": "public",
    "description": "Getter method to return a copy of CloudEvent data attribute,\nor original data payload.\n\nSee {@link CloudEvent.data}.",
    "lineNumber": 727,
    "type": {
      "nullable": null,
      "types": [
        "object",
        "Map",
        "Set"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 87,
    "kind": "get",
    "name": "extensions",
    "memberof": "src/cloudevent.js~CloudEvent",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cloudevent.js~CloudEvent#extensions",
    "access": "public",
    "description": "Getter method to return a copy of CloudEvent extensions.\n\nSee {@link CloudEvent.getExtensionsOfEvent}.",
    "lineNumber": 743,
    "type": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 88,
    "kind": "method",
    "name": "toString",
    "memberof": "src/cloudevent.js~CloudEvent",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cloudevent.js~CloudEvent#toString",
    "access": "public",
    "description": "Override the usual toString method,\nto show a summary (only some info) on current instance.\nNote that the representation of the 'data' attribute is\nlimited to 1024 chars (arbitrary limit, set here including the trim marker),\nto avoid too much overhead with instances with a big 'data' attribute.\n\nSee {@link Object.toString}.",
    "lineNumber": 758,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "a string representation for object instance"
    },
    "params": []
  },
  {
    "__docId__": 89,
    "kind": "get",
    "name": "[Symbol.toStringTag]",
    "memberof": "src/cloudevent.js~CloudEvent",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cloudevent.js~CloudEvent#[Symbol.toStringTag]",
    "access": "public",
    "description": "Gives a string valued property that is used in the creation of the default string description of an object.\n\nSee {@link Symbol.toStringTag}.",
    "lineNumber": 771,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "a string representation of the object type"
    },
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 90,
    "kind": "file",
    "name": "src/index.js",
    "content": "/*\r\n * Copyright 2018 the original author or authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n'use strict'\r\n\r\n/**\r\n * Get a reference to CloudEvent class definition.\r\n *\r\n * See {@link CloudEvent}.\r\n */\r\nconst cloudEventDefinition = require('./cloudevent')\r\n\r\n/**\r\n * Get a reference to JSONBatch class definition.\r\n *\r\n * See {@link JSONBatch}.\r\n */\r\nconst jsonBatchDefinition = require('./jsonbatch')\r\n\r\n/**\r\n * Get a reference to cloudevent class Validator.\r\n *\r\n * See {@link Validator}.\r\n */\r\nconst cloudEventValidator = require('./validator')\r\n\r\n/**\r\n * Get a reference to cloudevent class Transformer.\r\n *\r\n * See {@link Transformer}.\r\n */\r\nconst cloudEventTransformer = require('./transformer')\r\n\r\nmodule.exports = {\r\n  CloudEvent: cloudEventDefinition,\r\n  JSONBatch: jsonBatchDefinition,\r\n  CloudEventValidator: cloudEventValidator,\r\n  CloudEventTransformer: cloudEventTransformer\r\n}\r\n",
    "static": true,
    "longname": "/Users/martinis/work/prove/cloudevent.js/src/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 91,
    "kind": "file",
    "name": "src/jsonbatch.js",
    "content": "/*\r\n * Copyright 2018 the original author or authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n'use strict'\r\n\r\n/**\r\n * JSONBatch:\r\n * this module exports some useful definition and utility related to\r\n * the JSONBatch definition for CloudEvents.\r\n */\r\n\r\n/**\r\n * Get a reference to cloudevent CloudEvent class.\r\n *\r\n * @see Validator\r\n */\r\nconst CloudEvent = require('./cloudevent') // get cloudevent from here\r\n\r\n/**\r\n * Get a reference to cloudevent Validator class.\r\n *\r\n * @see Validator\r\n */\r\nconst V = require('./validator') // get validator from here\r\n\r\n/**\r\n * JSONBatch implementation.\r\n *\r\n * @see https://github.com/cloudevents/spec/blob/master/json-format.md#4-json-batch-format\r\n */\r\nclass JSONBatch {\r\n  /**\r\n   * Create a new instance of a JSONBatch object.\r\n   *\r\n   * Note that instancing is not allowed for this class because all its methods are static.\r\n   *\r\n   * @throws {Error} because instancing not allowed for this class\r\n   */\r\n  constructor () {\r\n    throw new Error('Instancing not allowed for this class')\r\n  }\r\n\r\n  /**\r\n   * Return the MIME Type for CloudEvent intances\r\n   * batched into a single JSON document (array),\r\n   * using the JSON Batch Format\r\n   *\r\n   * @static\r\n   * @return {string} the value\r\n   */\r\n  static mediaType () {\r\n    return 'application/cloudevents-batch+json'\r\n  }\r\n\r\n  /**\r\n   * Validate the given JSONBatch.\r\n   *\r\n   * @static\r\n   * @param {!object[]|object} batch the JSONBatch (array) to validate, or a single CloudEvent instance\r\n   * @param {object} [options={}] containing: strict (boolean, default false) to validate it in a more strict way\r\n   * @return {object[]} an array of (flattened, non null) validation errors, or at least an empty array\r\n   */\r\n  static validateBatch (batch, { strict = false } = {}) {\r\n    if (V.isUndefinedOrNull(batch)) {\r\n      return [new Error('JSONBatch undefined or null')]\r\n    }\r\n\r\n    // standard validation\r\n    const ve = [] // validation errors\r\n    if (V.isArray(batch)) {\r\n      // additional validation on nested items (any not null item)\r\n      const itemsValidation = batch.filter((i) => V.isDefinedAndNotNull(i)\r\n      ).map((i) => {\r\n        const ceValidation = CloudEvent.validateEvent(i, { strict })\r\n        if (ceValidation.length > 0) {\r\n          // return validation errors found\r\n          return ceValidation\r\n        }\r\n      })\r\n      ve.push(...itemsValidation)\r\n    } else if (CloudEvent.isCloudEvent(batch)) {\r\n      // validate the given (single) CloudEvent instance or subclass\r\n      // in strict mode this is a validation error anyway, so add it\r\n      if (strict === true) {\r\n        ve.push(new TypeError(\"The argument 'batch' must be an array, instead got a CloudEvent instance (or a subclass)\"))\r\n      }\r\n      ve.push(...CloudEvent.validateEvent(batch, { strict }))\r\n    } else {\r\n      return [new TypeError(`The argument 'batch' must be an array or a CloudEvent instance (or a subclass), instead got a '${typeof batch}'`)]\r\n    }\r\n\r\n    const veFiltered = ve.filter((i) => {\r\n      return (V.isArray(i) || V.isError(i))\r\n    }).reduce((acc, x) => acc.concat(x), []) // same as flat/flatMap\r\n\r\n    return veFiltered\r\n  }\r\n\r\n  /**\r\n   * Tell the given JSONBatch, if it's valid.\r\n   *\r\n   * See {@link CloudEvent.validateBatch}.\r\n   *\r\n   * @static\r\n   * @param {!object} batch the JSONBatch to validate\r\n   * @param {object} [options={}] containing: strict (boolean, default false) to validate it in a more strict way\r\n   * @return {boolean} true if valid, otherwise false\r\n   */\r\n  static isValidBatch (batch, { strict = false } = {}) {\r\n    const validationErrors = JSONBatch.validateBatch(batch, { strict })\r\n    const size = V.getSize(validationErrors)\r\n    return (size === 0)\r\n  }\r\n\r\n  /**\r\n   * Tell the given object, if it's a JSONBatch (or at least an empty one).\r\n   *\r\n   * @static\r\n   * @param {!object} batch the JSONBatch to check\r\n   * @return {boolean} true if it's an array, otherwise false\r\n   * @throws {Error} if batch is undefined or null\r\n   */\r\n  static isJSONBatch (batch) {\r\n    if (V.isUndefinedOrNull(batch)) {\r\n      throw new Error('JSONBatch undefined or null')\r\n    }\r\n    return V.isArray(batch)\r\n  }\r\n\r\n  /**\r\n   * Generator to iterate across all CloudEvent instances in the JSONBatch.\r\n   *\r\n   * @static\r\n   * @param {!object} batch the JSONBatch to iterate\r\n   * @param {object} [options={}] optional processing attributes:\r\n   *        onlyValid (boolean, default false) to extract only valid instances\r\n   *        strict (boolean, default false) to validate it in a more strict way\r\n   * @return {object} a CloudEvent (if any)\r\n   * @throws {Error} if batch is undefined or null\r\n   * @throws {TypeError} if batch is not a JSONBatch\r\n   */\r\n  static * getEvent (batch, {\r\n    onlyValid = false,\r\n    strict = false\r\n  } = {}) {\r\n    if (!JSONBatch.isJSONBatch(batch)) {\r\n      throw new TypeError('The given batch is not a JSONBatch')\r\n    }\r\n\r\n    const itemsFiltered = batch.filter((i) => V.isDefinedAndNotNull(i) && CloudEvent.isCloudEvent(i))\r\n    for (const i of itemsFiltered) {\r\n      if (onlyValid === false) {\r\n        yield i\r\n      } else {\r\n        // return only if it's a valid instance\r\n        if (CloudEvent.isValidEvent(i, { strict })) {\r\n          yield i\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Return any not null CloudEvent instance from the given object.\r\n   *\r\n   * @static\r\n   * @param {!object} batch the JSONBatch to extract CloudEvent instances (if any)\r\n   * @param {object} [options={}] optional processing attributes:\r\n   *        onlyValid (boolean, default false) to extract only valid instances\r\n   *        strict (boolean, default false) to validate it in a more strict way\r\n   * @return {object[]} processed events, as an array\r\n   * @throws {Error} if batch is undefined or null, or an option is undefined/null/wrong\r\n   * @throws {TypeError} if batch is not a JSONBatch\r\n   */\r\n  static getEvents (batch, {\r\n    onlyValid = false,\r\n    strict = false\r\n  } = {}) {\r\n    if (!JSONBatch.isJSONBatch(batch)) {\r\n      throw new TypeError('The given batch is not a JSONBatch')\r\n    }\r\n\r\n    const ce = [] // CloudEvent instances\r\n    // get values from the generator function, to simplify logic here\r\n    for (const val of JSONBatch.getEvent(batch, { onlyValid, strict })) {\r\n      ce.push(val)\r\n    }\r\n\r\n    return ce\r\n  }\r\n\r\n  /**\r\n   * Serialize the given JSONBatch in JSON format.\r\n   * Note that standard CloudEvent serialization will be called\r\n   * for any CloudEvent instance, nothing other;\r\n   * so options are the same used in CloudEvent related method.\r\n   *\r\n   * See {@link CloudEvent.serializeEvent}.\r\n   *\r\n   * @static\r\n   * @param {!object[]} batch the JSONBatch (so a CloudEvent array instance) to serialize\r\n   * @param {object} [options={}] optional serialization attributes\r\n   *        Additional options valid here:\r\n   *        logError (boolean, default false) to log to console serialization errors\r\n   *        throwError (boolean, default false) to throw serialization errors\r\n   * @return {string} the serialized JSONBatch, as a string\r\n   * @throws {Error} if batch is undefined or null, or an option is undefined/null/wrong\r\n   * @throws {TypeError} if batch is not a JSONBatch\r\n   */\r\n  static serializeEvents (batch, options = {}) {\r\n    if (!JSONBatch.isJSONBatch(batch)) {\r\n      throw new TypeError('The given batch is not a JSONBatch')\r\n    }\r\n\r\n    let ser = '[' // serialized CloudEvent instances\r\n    let num = 0 // number of serialized CloudEvent\r\n\r\n    // get values from the generator function, to simplify logic here\r\n    for (const val of JSONBatch.getEvent(batch, options)) {\r\n      ser += ((num > 0) ? ', ' : '')\r\n      ser += ((options.prettyPrint === true) ? '\\n' : '')\r\n      try {\r\n        ser += CloudEvent.serializeEvent(val, options)\r\n        num++\r\n      } catch (e) {\r\n        ser += 'null' // as a fallback placeholder\r\n        if (options.logError === true) {\r\n          console.error(e)\r\n        }\r\n        if (options.throwError === true) {\r\n          const msg = `Unable to serialize CloudEvent instance number ${num}, error detail: ${e.message}`\r\n          throw new Error(msg)\r\n        }\r\n      }\r\n    }\r\n\r\n    if (options.prettyPrint === true) {\r\n      ser += '\\n'\r\n    }\r\n    ser += ']'\r\n\r\n    return ser\r\n  }\r\n\r\n  /**\r\n   * Deserialize/parse the given JSONBatch from JSON format.\r\n   * Note that standard CloudEvent deserialization will be called\r\n   * for any CloudEvent instance, nothing other;\r\n   * so options are the same used in CloudEvent related method.\r\n   *\r\n   * See {@link CloudEvent.deserializeEvent}.\r\n   *\r\n   * @static\r\n   * @param {!string} ser the serialized JSONBatch to parse/deserialize\r\n   * @param {object} [options={}] optional deserialization attributes\r\n   *        Additional options valid here:\r\n   *        logError (boolean, default false) to log to console deserialization errors\r\n   *        throwError (boolean, default false) to throw serialization errors\r\n   * @return {object[]} the deserialized batch as a JSONBatch (so a CloudEvent array instance)\r\n   * @throws {Error} if ser is undefined or null, or an option is undefined/null/wrong\r\n   * @throws {Error} in case of JSON parsing error\r\n   * @throws {TypeError} if ser is not a JSONBatch representation\r\n   */\r\n  static deserializeEvents (ser, options = {}) {\r\n    if (!V.isStringNotEmpty(ser)) throw new Error(`Missing or wrong serialized data: '${ser}' must be a string and not a: '${typeof ser}'.`)\r\n\r\n    // first deserialize to normal object instances\r\n    let deser = null\r\n    try {\r\n      deser = JSON.parse(ser)\r\n    } catch (e) {\r\n      if (options.logError === true) {\r\n        console.error(e)\r\n      }\r\n      if (options.throwError === true) {\r\n        const msg = `Unable to deserialize the given string to JSONBatch, error detail: ${e.message}`\r\n        throw new Error(msg)\r\n      }\r\n    }\r\n    if (!V.isArray(deser)) {\r\n      throw new TypeError('The given string is not an array representation')\r\n    }\r\n\r\n    // then build CloudEvent instances from any not null object that seems compatible\r\n    const itemsFiltered = deser.filter((i) => V.isDefinedAndNotNull(i) && V.isObjectPlain(i))\r\n    const batch = []\r\n    let num = 0 // number of created CloudEvent\r\n    for (const i of itemsFiltered) {\r\n      // create a CloudEvent instance from the current object (if possible)\r\n      try {\r\n        const extensions = V.getObjectFilteredProperties(i, CloudEvent.isExtensionProperty)\r\n        // note that strict is handleg both as strict and inside extensions, but it's good the same\r\n        const ce = new CloudEvent(i.id, i.type, i.source, i.data, {\r\n          time: i.time,\r\n          datacontentencoding: i.datacontentencoding,\r\n          datacontenttype: i.datacontenttype,\r\n          schemaurl: i.schemaurl,\r\n          subject: i.subject,\r\n          strict: CloudEvent.getStrictExtensionOfEvent(i) || options.strict\r\n        },\r\n        extensions\r\n        )\r\n        if (V.isUndefinedOrNull(options.onlyValid) ||\r\n          options.onlyValid === false ||\r\n          (options.onlyValid === true && CloudEvent.isValidEvent(ce, { strict: options.strict }))\r\n        ) {\r\n          batch.push(ce)\r\n          num++\r\n        }\r\n      } catch (e) {\r\n        if (options.logError === true) {\r\n          console.error(e)\r\n        }\r\n        if (options.throwError === true) {\r\n          const msg = `Unable to create CloudEvent instance number ${num}, error detail: ${e.message}`\r\n          throw new Error(msg)\r\n        }\r\n      }\r\n    }\r\n\r\n    return batch\r\n  }\r\n}\r\n\r\nmodule.exports = JSONBatch\r\n",
    "static": true,
    "longname": "/Users/martinis/work/prove/cloudevent.js/src/jsonbatch.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 92,
    "kind": "class",
    "name": "JSONBatch",
    "memberof": "src/jsonbatch.js",
    "static": true,
    "longname": "src/jsonbatch.js~JSONBatch",
    "access": "public",
    "export": true,
    "importPath": "cloudevent/src/jsonbatch.js",
    "importStyle": "JSONBatch",
    "description": "JSONBatch implementation.",
    "see": [
      "https://github.com/cloudevents/spec/blob/master/json-format.md#4-json-batch-format"
    ],
    "lineNumber": 43,
    "interface": false
  },
  {
    "__docId__": 93,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/jsonbatch.js~JSONBatch",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/jsonbatch.js~JSONBatch#constructor",
    "access": "public",
    "description": "Create a new instance of a JSONBatch object.\n\nNote that instancing is not allowed for this class because all its methods are static.",
    "lineNumber": 51,
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "because instancing not allowed for this class"
      }
    ]
  },
  {
    "__docId__": 94,
    "kind": "method",
    "name": "mediaType",
    "memberof": "src/jsonbatch.js~JSONBatch",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/jsonbatch.js~JSONBatch.mediaType",
    "access": "public",
    "description": "Return the MIME Type for CloudEvent intances\nbatched into a single JSON document (array),\nusing the JSON Batch Format",
    "lineNumber": 63,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "the value"
    },
    "params": []
  },
  {
    "__docId__": 95,
    "kind": "method",
    "name": "validateBatch",
    "memberof": "src/jsonbatch.js~JSONBatch",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/jsonbatch.js~JSONBatch.validateBatch",
    "access": "public",
    "description": "Validate the given JSONBatch.",
    "lineNumber": 75,
    "params": [
      {
        "nullable": false,
        "types": [
          "object[]",
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "batch",
        "description": "the JSONBatch (array) to validate, or a single CloudEvent instance"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{}",
        "defaultRaw": {},
        "name": "options",
        "description": "containing: strict (boolean, default false) to validate it in a more strict way"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object[]"
      ],
      "spread": false,
      "description": "an array of (flattened, non null) validation errors, or at least an empty array"
    }
  },
  {
    "__docId__": 96,
    "kind": "method",
    "name": "isValidBatch",
    "memberof": "src/jsonbatch.js~JSONBatch",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/jsonbatch.js~JSONBatch.isValidBatch",
    "access": "public",
    "description": "Tell the given JSONBatch, if it's valid.\n\nSee {@link CloudEvent.validateBatch}.",
    "lineNumber": 121,
    "params": [
      {
        "nullable": false,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "batch",
        "description": "the JSONBatch to validate"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{}",
        "defaultRaw": {},
        "name": "options",
        "description": "containing: strict (boolean, default false) to validate it in a more strict way"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if valid, otherwise false"
    }
  },
  {
    "__docId__": 97,
    "kind": "method",
    "name": "isJSONBatch",
    "memberof": "src/jsonbatch.js~JSONBatch",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/jsonbatch.js~JSONBatch.isJSONBatch",
    "access": "public",
    "description": "Tell the given object, if it's a JSONBatch (or at least an empty one).",
    "lineNumber": 135,
    "params": [
      {
        "nullable": false,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "batch",
        "description": "the JSONBatch to check"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if it's an array, otherwise false"
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "if batch is undefined or null"
      }
    ]
  },
  {
    "__docId__": 98,
    "kind": "method",
    "name": "getEvent",
    "memberof": "src/jsonbatch.js~JSONBatch",
    "generator": true,
    "async": false,
    "static": true,
    "longname": "src/jsonbatch.js~JSONBatch.getEvent",
    "access": "public",
    "description": "Generator to iterate across all CloudEvent instances in the JSONBatch.",
    "lineNumber": 154,
    "params": [
      {
        "nullable": false,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "batch",
        "description": "the JSONBatch to iterate"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{}",
        "defaultRaw": {},
        "name": "options",
        "description": "optional processing attributes:\n       onlyValid (boolean, default false) to extract only valid instances\n       strict (boolean, default false) to validate it in a more strict way"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "a CloudEvent (if any)"
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "if batch is undefined or null"
      },
      {
        "types": [
          "TypeError"
        ],
        "description": "if batch is not a JSONBatch"
      }
    ]
  },
  {
    "__docId__": 99,
    "kind": "method",
    "name": "getEvents",
    "memberof": "src/jsonbatch.js~JSONBatch",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/jsonbatch.js~JSONBatch.getEvents",
    "access": "public",
    "description": "Return any not null CloudEvent instance from the given object.",
    "lineNumber": 187,
    "params": [
      {
        "nullable": false,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "batch",
        "description": "the JSONBatch to extract CloudEvent instances (if any)"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{}",
        "defaultRaw": {},
        "name": "options",
        "description": "optional processing attributes:\n       onlyValid (boolean, default false) to extract only valid instances\n       strict (boolean, default false) to validate it in a more strict way"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object[]"
      ],
      "spread": false,
      "description": "processed events, as an array"
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "if batch is undefined or null, or an option is undefined/null/wrong"
      },
      {
        "types": [
          "TypeError"
        ],
        "description": "if batch is not a JSONBatch"
      }
    ]
  },
  {
    "__docId__": 100,
    "kind": "method",
    "name": "serializeEvents",
    "memberof": "src/jsonbatch.js~JSONBatch",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/jsonbatch.js~JSONBatch.serializeEvents",
    "access": "public",
    "description": "Serialize the given JSONBatch in JSON format.\nNote that standard CloudEvent serialization will be called\nfor any CloudEvent instance, nothing other;\nso options are the same used in CloudEvent related method.\n\nSee {@link CloudEvent.serializeEvent}.",
    "lineNumber": 222,
    "params": [
      {
        "nullable": false,
        "types": [
          "object[]"
        ],
        "spread": false,
        "optional": false,
        "name": "batch",
        "description": "the JSONBatch (so a CloudEvent array instance) to serialize"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{}",
        "defaultRaw": {},
        "name": "options",
        "description": "optional serialization attributes\n       Additional options valid here:\n       logError (boolean, default false) to log to console serialization errors\n       throwError (boolean, default false) to throw serialization errors"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "the serialized JSONBatch, as a string"
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "if batch is undefined or null, or an option is undefined/null/wrong"
      },
      {
        "types": [
          "TypeError"
        ],
        "description": "if batch is not a JSONBatch"
      }
    ]
  },
  {
    "__docId__": 101,
    "kind": "method",
    "name": "deserializeEvents",
    "memberof": "src/jsonbatch.js~JSONBatch",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/jsonbatch.js~JSONBatch.deserializeEvents",
    "access": "public",
    "description": "Deserialize/parse the given JSONBatch from JSON format.\nNote that standard CloudEvent deserialization will be called\nfor any CloudEvent instance, nothing other;\nso options are the same used in CloudEvent related method.\n\nSee {@link CloudEvent.deserializeEvent}.",
    "lineNumber": 276,
    "params": [
      {
        "nullable": false,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "ser",
        "description": "the serialized JSONBatch to parse/deserialize"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{}",
        "defaultRaw": {},
        "name": "options",
        "description": "optional deserialization attributes\n       Additional options valid here:\n       logError (boolean, default false) to log to console deserialization errors\n       throwError (boolean, default false) to throw serialization errors"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object[]"
      ],
      "spread": false,
      "description": "the deserialized batch as a JSONBatch (so a CloudEvent array instance)"
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "if ser is undefined or null, or an option is undefined/null/wrong"
      },
      {
        "types": [
          "Error"
        ],
        "description": "in case of JSON parsing error"
      },
      {
        "types": [
          "TypeError"
        ],
        "description": "if ser is not a JSONBatch representation"
      }
    ]
  },
  {
    "__docId__": 102,
    "kind": "file",
    "name": "src/transformer.js",
    "content": "/*\r\n * Copyright 2018 the original author or authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n'use strict'\r\n\r\n/**\r\n * Transformers:\r\n * this module exports some useful generic functions for the transformation of objects.\r\n */\r\n\r\n/**\r\n * Get a reference to cloudevent Validator class.\r\n *\r\n * See {@link Validator}.\r\n */\r\nconst V = require('./validator') // get validator from here\r\n\r\n/** Get the host name where this code is runninng */\r\nconst hostname = require('os').hostname()\r\n\r\n/** Get the process id (pid) where this code is runninng */\r\nconst pid = require('process').pid\r\n\r\n/**\r\n * Useful Transformations for CloudEvent objects.\r\n *\r\n * Note that all methods here are static, so no need to instance this class;\r\n * see it as an Utility/Companion class.\r\n */\r\nclass Transformer {\r\n  /**\r\n   * Create a new instance of a Transformer object.\r\n   *\r\n   * Note that instancing is not allowed for this class because all its methods are static.\r\n   *\r\n   * @throws {Error} because instancing not allowed for this class\r\n   */\r\n  constructor () {\r\n    throw new Error('Instancing not allowed for this class')\r\n  }\r\n\r\n  /**\r\n   * Utility function that return a dump of the given object.\r\n   *\r\n   * @static\r\n   * @param {(?object|Map|Set)} obj the object to dump\r\n   * @param {string} [name='noname'] the name to assign in the returned string, or 'noname' as default value\r\n   * @return {string} the dump of the object or a message when obj is undefined/null/not an object\r\n   */\r\n  static dumpObject (obj, name = 'noname') {\r\n    if (V.isUndefined(obj)) {\r\n      return `${name}: undefined`\r\n    } else if (V.isNull(obj)) {\r\n      return `${name}: null`\r\n    } else if (V.isObject(obj) || V.isKeyedCollection(obj)) {\r\n      return `${name}: ${JSON.stringify(obj)}`\r\n    } else {\r\n      return `${name}: '${obj.toString()}'`\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Utility function that parse a string representation\r\n   * (compatible with the CloudEvent standard) of the given timestamp (Date)\r\n   * and returns it (if possible).\r\n   *\r\n   * Note that the value returned could be adjusted with the current timezone offset.\r\n   *\r\n   * @static\r\n   * @param {!string} obj the timestamp/date to parse (as a string)\r\n   * @param {number} [timezoneOffset=0] a timezone offset to add (in msec, default 0)\r\n   * @return {object} the parsed version, as a timestamp (Date) object, if possible\r\n   * @throws {TypeError} if obj is undefined or null, or is not a string\r\n   */\r\n  static timestampFromString (obj, timezoneOffset = 0) {\r\n    if (!V.isStringNotEmpty(obj)) {\r\n      throw new TypeError(`Missing or wrong timestamp: '${obj}' must be a string and not a: '${typeof obj}'.`)\r\n    }\r\n    const timestampMsec = Date.parse(obj)\r\n    return new Date(timestampMsec + timezoneOffset)\r\n  }\r\n\r\n  /**\r\n   * Utility function that return a string representation\r\n   * (compatible with the CloudEvent standard)\r\n   * of the given timestamp (Date), or the current one will be used.\r\n   *\r\n   * Note that the value returned is in the UTC format.\r\n   *\r\n   * @static\r\n   * @param {?object} obj the timestamp/date to convert, or the current one if not defined or null\r\n   * @return {string} the string representation of the object\r\n   * @throws {TypeError} if obj is undefined or null, or is not a Date instance\r\n   */\r\n  static timestampToString (obj) {\r\n    let timestamp = obj\r\n    if (V.isUndefinedOrNull(timestamp)) {\r\n      timestamp = new Date()\r\n    }\r\n    if (!V.isDateValid(timestamp)) {\r\n      throw new TypeError(`Missing or wrong timestamp: '${timestamp}' must be a date and not a: '${typeof timestamp}'.`)\r\n    }\r\n    return timestamp.toISOString()\r\n  }\r\n\r\n  /**\r\n   * Utility function that parse a number representation\r\n   * of the given timestamp (Date)\r\n   * and returns it (if possible).\r\n   *\r\n   * Note that the value returned could be adjusted with the current timezone offset.\r\n   *\r\n   * @static\r\n   * @param {!number} obj the timestamp/date to parse (as a number)\r\n   * @param {number} [timezoneOffset=0] a timezone offset to add (in msec, default 0)\r\n   * @return {object} the parsed version, as a timestamp (Date) object, if possible\r\n   * @throws {TypeError} if obj is undefined or null, or is not a number\r\n   */\r\n  static timestampFromNumber (obj, timezoneOffset = 0) {\r\n    if (!V.isNumber(obj)) {\r\n      throw new TypeError(`Missing or wrong timestamp: '${obj}' must be a number and not a: '${typeof obj}'.`)\r\n    }\r\n    return new Date(obj + timezoneOffset)\r\n  }\r\n\r\n  /**\r\n   * Utility function that return a number representation\r\n   * of the given timestamp (Date), or the current one will be used.\r\n   *\r\n   * Note that the value returned is in the UTC format.\r\n   *\r\n   * @static\r\n   * @param {?object} obj the timestamp/date to convert, or the current one if not defined or null\r\n   * @return {number} the number representation of the object\r\n   * @throws {TypeError} if obj is not a Date instance\r\n   */\r\n  static timestampToNumber (obj) {\r\n    let timestamp = obj\r\n    if (V.isUndefinedOrNull(timestamp)) {\r\n      timestamp = new Date()\r\n    }\r\n    if (!V.isDateValid(timestamp)) {\r\n      throw new TypeError(`Wrong timestamp: '${timestamp}' must be a date and not a: '${typeof timestamp}'.`)\r\n    }\r\n    return timestamp.getTime()\r\n  }\r\n\r\n  /**\r\n   * Utility function that encodes a string\r\n   * in base64 (compatible with the CloudEvent standard).\r\n   *\r\n   * @static\r\n   * @param {?string} obj the string to encode, or '' if not defined or null\r\n   * @return {string} the string encoded in base64\r\n   * @throws {TypeError} if str is not a string instance\r\n   */\r\n  static stringToBase64 (obj) {\r\n    let str = obj\r\n    if (V.isUndefinedOrNull(obj)) {\r\n      str = ''\r\n    }\r\n    if (!V.isString(str)) {\r\n      throw new TypeError(`Missing or wrong argument: '${str}' must be a string and not a: '${typeof str}'.`)\r\n    }\r\n    return Buffer.from(str).toString('base64')\r\n  }\r\n\r\n  /**\r\n   * Utility function that decodes a base64 string\r\n   * into a normal string using 'utf8' encoding\r\n   * (compatible with the CloudEvent standard).\r\n   *\r\n   * @static\r\n   * @param {?string} obj the string to decode, or '' if not defined or null\r\n   * @return {string} the string decoded from base64\r\n   * @throws {TypeError} if str is not a string instance\r\n   */\r\n  static stringFromBase64 (obj) {\r\n    let str = obj\r\n    if (V.isUndefinedOrNull(obj)) {\r\n      str = ''\r\n    }\r\n    if (!V.isString(str)) {\r\n      throw new TypeError(`Missing or wrong argument: '${str}' must be a string and not a: '${typeof str}'.`)\r\n    }\r\n    return Buffer.from(str, 'base64').toString('utf8')\r\n  }\r\n\r\n  /**\r\n   * Utility function that map an Error into an object\r\n   * (compatible with the CloudEvent standard), to fill its 'data' attribute.\r\n   *\r\n   * @static\r\n   * @param {!Error} err the Error to transform\r\n   * @param {object} [options={}] transformation options:\r\n   *        includeStackTrace flag (default false) to add the StackTrace into the object to return,\r\n   *        addStatus flag (default true) to add a 'status' attribute into the object to return,\r\n   *        addTimestamp flag (default false) to add the current 'timestamp' as attribute into the object to return,\r\n   * @return {object} the object representation of the error\r\n   * @throws {TypeError} if err is undefined or null, or is not an Error instance\r\n   */\r\n  static errorToData (err, {\r\n    includeStackTrace = false,\r\n    addStatus = true,\r\n    addTimestamp = false\r\n  } = {}\r\n  ) {\r\n    if (!V.isError(err)) {\r\n      throw new TypeError(`Missing or wrong argument: '${err}' must be an Error and not a: '${typeof err}'.`)\r\n    }\r\n    const data = {\r\n      name: err.name,\r\n      message: err.message,\r\n      stack: (includeStackTrace === true) ? err.stack : null\r\n    }\r\n    if (V.isDefinedAndNotNull(err.code)) {\r\n      data.code = err.code\r\n    }\r\n    if (addStatus === true) {\r\n      data.status = 'error'\r\n    }\r\n    if (addTimestamp === true) {\r\n      data.timestamp = Date.now()\r\n    }\r\n    return data\r\n  }\r\n\r\n  /**\r\n   * Utility function that get some process-related info and wrap into an object\r\n   * (compatible with the CloudEvent standard), to fill its 'data' attribute.\r\n   *\r\n   * @static\r\n   * @return {object} the object representation of process-related info data\r\n   */\r\n  static processInfoToData () {\r\n    return {\r\n      hostname: hostname,\r\n      pid: pid\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Utility function that strip all arguments (if any) from the given URI/URL string\r\n   * and returns the string without them.\r\n   *\r\n   * @static\r\n   * @param {!string} url the URI/URL (as a string)\r\n   * @param {object} [options={}] containing: strict (boolean, default false) to check it in a more strict way\r\n   * @return {string} the parsed version, but without arguments (if any)\r\n   * @throws {TypeError} if url is undefined or null, or is not a string\r\n   */\r\n  static uriStripArguments (url, { strict = false } = {}) {\r\n    if (!V.isString(url)) {\r\n      throw new TypeError(`Missing or wrong URL: '${url}' must be a string and not a: '${typeof url}'.`)\r\n    }\r\n    if (strict === true) {\r\n      if (!V.isURI(url)) {\r\n        throw new TypeError(`Missing or wrong URL: '${url}'`)\r\n      }\r\n    }\r\n    return url.split('?')[0]\r\n  }\r\n\r\n  /**\r\n   * Utility function that merge the given objects (at least one base and another)\r\n   * and returns the new one (but with the prototype of the first).\r\n   *\r\n   * @static\r\n   * @param {!object} base the first object to merge\r\n   * @param {object} others all other(s) object to merge (at least one)\r\n   * @return {object} the new object\r\n   * @throws {TypeError} if base is undefined or null, or is not an object\r\n   */\r\n  static mergeObjects (base, ...others) {\r\n    if (!V.isObject(base)) {\r\n      throw new TypeError(`Missing or wrong argument: '${base}' must be an object and not a: '${typeof base}'.`)\r\n    }\r\n    const baseProto = Object.getPrototypeOf(base)\r\n    return Object.assign(Object.create(baseProto), base, ...others) // set the prototype of the first argument in the clone\r\n  }\r\n}\r\n\r\n/**\r\n * Utility variable that returns the timezone offset value, in msec.\r\n *\r\n * @static\r\n */\r\nTransformer.timezoneOffsetMsec = new Date().getTimezoneOffset() * 60 * 1000\r\n\r\nmodule.exports = Transformer\r\n",
    "static": true,
    "longname": "/Users/martinis/work/prove/cloudevent.js/src/transformer.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 103,
    "kind": "class",
    "name": "Transformer",
    "memberof": "src/transformer.js",
    "static": true,
    "longname": "src/transformer.js~Transformer",
    "access": "public",
    "export": true,
    "importPath": "cloudevent/src/transformer.js",
    "importStyle": "Transformer",
    "description": "Useful Transformations for CloudEvent objects.\n\nNote that all methods here are static, so no need to instance this class;\nsee it as an Utility/Companion class.",
    "lineNumber": 42,
    "interface": false
  },
  {
    "__docId__": 104,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/transformer.js~Transformer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/transformer.js~Transformer#constructor",
    "access": "public",
    "description": "Create a new instance of a Transformer object.\n\nNote that instancing is not allowed for this class because all its methods are static.",
    "lineNumber": 50,
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "because instancing not allowed for this class"
      }
    ]
  },
  {
    "__docId__": 105,
    "kind": "method",
    "name": "dumpObject",
    "memberof": "src/transformer.js~Transformer",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/transformer.js~Transformer.dumpObject",
    "access": "public",
    "description": "Utility function that return a dump of the given object.",
    "lineNumber": 62,
    "params": [
      {
        "nullable": null,
        "types": [
          "?object",
          "Map",
          "Set"
        ],
        "spread": false,
        "optional": false,
        "name": "obj",
        "description": "the object to dump"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'noname'",
        "defaultRaw": "'noname'",
        "name": "name",
        "description": "the name to assign in the returned string, or 'noname' as default value"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "the dump of the object or a message when obj is undefined/null/not an object"
    }
  },
  {
    "__docId__": 106,
    "kind": "method",
    "name": "timestampFromString",
    "memberof": "src/transformer.js~Transformer",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/transformer.js~Transformer.timestampFromString",
    "access": "public",
    "description": "Utility function that parse a string representation\n(compatible with the CloudEvent standard) of the given timestamp (Date)\nand returns it (if possible).\n\nNote that the value returned could be adjusted with the current timezone offset.",
    "lineNumber": 87,
    "params": [
      {
        "nullable": false,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "obj",
        "description": "the timestamp/date to parse (as a string)"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "0",
        "defaultRaw": 0,
        "name": "timezoneOffset",
        "description": "a timezone offset to add (in msec, default 0)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "the parsed version, as a timestamp (Date) object, if possible"
    },
    "throws": [
      {
        "types": [
          "TypeError"
        ],
        "description": "if obj is undefined or null, or is not a string"
      }
    ]
  },
  {
    "__docId__": 107,
    "kind": "method",
    "name": "timestampToString",
    "memberof": "src/transformer.js~Transformer",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/transformer.js~Transformer.timestampToString",
    "access": "public",
    "description": "Utility function that return a string representation\n(compatible with the CloudEvent standard)\nof the given timestamp (Date), or the current one will be used.\n\nNote that the value returned is in the UTC format.",
    "lineNumber": 107,
    "params": [
      {
        "nullable": true,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "obj",
        "description": "the timestamp/date to convert, or the current one if not defined or null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "the string representation of the object"
    },
    "throws": [
      {
        "types": [
          "TypeError"
        ],
        "description": "if obj is undefined or null, or is not a Date instance"
      }
    ]
  },
  {
    "__docId__": 108,
    "kind": "method",
    "name": "timestampFromNumber",
    "memberof": "src/transformer.js~Transformer",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/transformer.js~Transformer.timestampFromNumber",
    "access": "public",
    "description": "Utility function that parse a number representation\nof the given timestamp (Date)\nand returns it (if possible).\n\nNote that the value returned could be adjusted with the current timezone offset.",
    "lineNumber": 131,
    "params": [
      {
        "nullable": false,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "obj",
        "description": "the timestamp/date to parse (as a number)"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "0",
        "defaultRaw": 0,
        "name": "timezoneOffset",
        "description": "a timezone offset to add (in msec, default 0)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "the parsed version, as a timestamp (Date) object, if possible"
    },
    "throws": [
      {
        "types": [
          "TypeError"
        ],
        "description": "if obj is undefined or null, or is not a number"
      }
    ]
  },
  {
    "__docId__": 109,
    "kind": "method",
    "name": "timestampToNumber",
    "memberof": "src/transformer.js~Transformer",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/transformer.js~Transformer.timestampToNumber",
    "access": "public",
    "description": "Utility function that return a number representation\nof the given timestamp (Date), or the current one will be used.\n\nNote that the value returned is in the UTC format.",
    "lineNumber": 149,
    "params": [
      {
        "nullable": true,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "obj",
        "description": "the timestamp/date to convert, or the current one if not defined or null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the number representation of the object"
    },
    "throws": [
      {
        "types": [
          "TypeError"
        ],
        "description": "if obj is not a Date instance"
      }
    ]
  },
  {
    "__docId__": 110,
    "kind": "method",
    "name": "stringToBase64",
    "memberof": "src/transformer.js~Transformer",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/transformer.js~Transformer.stringToBase64",
    "access": "public",
    "description": "Utility function that encodes a string\nin base64 (compatible with the CloudEvent standard).",
    "lineNumber": 169,
    "params": [
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "obj",
        "description": "the string to encode, or '' if not defined or null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "the string encoded in base64"
    },
    "throws": [
      {
        "types": [
          "TypeError"
        ],
        "description": "if str is not a string instance"
      }
    ]
  },
  {
    "__docId__": 111,
    "kind": "method",
    "name": "stringFromBase64",
    "memberof": "src/transformer.js~Transformer",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/transformer.js~Transformer.stringFromBase64",
    "access": "public",
    "description": "Utility function that decodes a base64 string\ninto a normal string using 'utf8' encoding\n(compatible with the CloudEvent standard).",
    "lineNumber": 190,
    "params": [
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "obj",
        "description": "the string to decode, or '' if not defined or null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "the string decoded from base64"
    },
    "throws": [
      {
        "types": [
          "TypeError"
        ],
        "description": "if str is not a string instance"
      }
    ]
  },
  {
    "__docId__": 112,
    "kind": "method",
    "name": "errorToData",
    "memberof": "src/transformer.js~Transformer",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/transformer.js~Transformer.errorToData",
    "access": "public",
    "description": "Utility function that map an Error into an object\n(compatible with the CloudEvent standard), to fill its 'data' attribute.",
    "lineNumber": 214,
    "params": [
      {
        "nullable": false,
        "types": [
          "Error"
        ],
        "spread": false,
        "optional": false,
        "name": "err",
        "description": "the Error to transform"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{}",
        "defaultRaw": {},
        "name": "options",
        "description": "transformation options:\n       includeStackTrace flag (default false) to add the StackTrace into the object to return,\n       addStatus flag (default true) to add a 'status' attribute into the object to return,\n       addTimestamp flag (default false) to add the current 'timestamp' as attribute into the object to return,"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "the object representation of the error"
    },
    "throws": [
      {
        "types": [
          "TypeError"
        ],
        "description": "if err is undefined or null, or is not an Error instance"
      }
    ]
  },
  {
    "__docId__": 113,
    "kind": "method",
    "name": "processInfoToData",
    "memberof": "src/transformer.js~Transformer",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/transformer.js~Transformer.processInfoToData",
    "access": "public",
    "description": "Utility function that get some process-related info and wrap into an object\n(compatible with the CloudEvent standard), to fill its 'data' attribute.",
    "lineNumber": 247,
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "the object representation of process-related info data"
    },
    "params": []
  },
  {
    "__docId__": 114,
    "kind": "method",
    "name": "uriStripArguments",
    "memberof": "src/transformer.js~Transformer",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/transformer.js~Transformer.uriStripArguments",
    "access": "public",
    "description": "Utility function that strip all arguments (if any) from the given URI/URL string\nand returns the string without them.",
    "lineNumber": 264,
    "params": [
      {
        "nullable": false,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "url",
        "description": "the URI/URL (as a string)"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{}",
        "defaultRaw": {},
        "name": "options",
        "description": "containing: strict (boolean, default false) to check it in a more strict way"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "the parsed version, but without arguments (if any)"
    },
    "throws": [
      {
        "types": [
          "TypeError"
        ],
        "description": "if url is undefined or null, or is not a string"
      }
    ]
  },
  {
    "__docId__": 115,
    "kind": "method",
    "name": "mergeObjects",
    "memberof": "src/transformer.js~Transformer",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/transformer.js~Transformer.mergeObjects",
    "access": "public",
    "description": "Utility function that merge the given objects (at least one base and another)\nand returns the new one (but with the prototype of the first).",
    "lineNumber": 286,
    "params": [
      {
        "nullable": false,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "base",
        "description": "the first object to merge"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "others",
        "description": "all other(s) object to merge (at least one)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "the new object"
    },
    "throws": [
      {
        "types": [
          "TypeError"
        ],
        "description": "if base is undefined or null, or is not an object"
      }
    ]
  },
  {
    "__docId__": 116,
    "kind": "file",
    "name": "src/validator.js",
    "content": "/*\r\n * Copyright 2018 the original author or authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n'use strict'\r\n\r\n/**\r\n * Validators:\r\n * this module exports some useful generic functions for the validation of objects.\r\n */\r\n\r\nconst url = require('url')\r\n\r\n/**\r\n * Generic Validator implementation.\r\n *\r\n * Note that all methods here are static, so no need to instance this class;\r\n * see it as an Utility/Companion class.\r\n */\r\nclass Validator {\r\n  /**\r\n   * Create a new instance of a Validator object.\r\n   *\r\n   * Note that instancing is not allowed for this class because all its methods are static.\r\n   *\r\n   * @throws {Error} because instancing not allowed for this class\r\n   */\r\n  constructor () {\r\n    throw new Error('Instancing not allowed for this class')\r\n  }\r\n\r\n  /**\r\n   * Tell if the given argument is undefined.\r\n   *\r\n   * @static\r\n   * @param {?object} arg the object to check\r\n   * @return {boolean} true if undefined, false otherwise\r\n   */\r\n  static isUndefined (arg) {\r\n    return (arg === undefined)\r\n  }\r\n\r\n  /**\r\n   * Tell if the given argument is null.\r\n   *\r\n   * @static\r\n   * @param {?object} arg the object to check\r\n   * @return {boolean} true if null, false otherwise\r\n   */\r\n  static isNull (arg) {\r\n    return (arg === null)\r\n  }\r\n\r\n  /**\r\n   * Tell if the given argument is undefined or null.\r\n   *\r\n   * @static\r\n   * @param {?object} arg the object to check\r\n   * @return {boolean} true if undefined or null, false otherwise\r\n   */\r\n  static isUndefinedOrNull (arg) {\r\n    return (arg === undefined || arg === null)\r\n  }\r\n\r\n  /**\r\n   * Tell if the given argument is defined and not null.\r\n   *\r\n   * @static\r\n   * @param {?object} arg the object to check\r\n   * @return {boolean} true if defined and not null, false otherwise\r\n   */\r\n  static isDefinedAndNotNull (arg) {\r\n    return (arg !== undefined && arg !== null)\r\n  }\r\n\r\n  /**\r\n   * Tell if the given argument is a string.\r\n   *\r\n   * @static\r\n   * @param {?object} arg the object to check\r\n   * @return {boolean} true if it's a string, false otherwise\r\n   */\r\n  static isString (arg) {\r\n    return (Validator.isDefinedAndNotNull(arg) && (typeof arg === 'string'))\r\n  }\r\n\r\n  /**\r\n   * Tell if the given argument is a not empty string.\r\n   *\r\n   * See {@link Validator.isString}.\r\n   *\r\n   * @static\r\n   * @param {?object} arg the object to check\r\n   * @return {boolean} true if it's a not empty string, false otherwise\r\n   */\r\n  static isStringNotEmpty (arg) {\r\n    return (Validator.isString(arg) && (arg.length > 0))\r\n  }\r\n\r\n  /**\r\n   * Tell if the given argument is a date.\r\n   *\r\n   * @static\r\n   * @param {?object} arg the object to check\r\n   * @return {boolean} true if it's a date, false otherwise\r\n   */\r\n  static isDate (arg) {\r\n    return (Validator.isDefinedAndNotNull(arg) && (typeof arg === 'object' || arg instanceof Date))\r\n  }\r\n\r\n  /**\r\n   * Tell if the given argument is a valid date.\r\n   *\r\n   * See {@link Validator.isDate}.\r\n   *\r\n   * @static\r\n   * @param {?object} arg the object to check\r\n   * @return {boolean} true if it's a valid date, false otherwise\r\n   */\r\n  static isDateValid (arg) {\r\n    return (Validator.isDate(arg) && !isNaN(arg))\r\n  }\r\n\r\n  /**\r\n   * Tell if the given argument is a valid date and in the past or now.\r\n   *\r\n   * See {@link Validator.isDateValid}.\r\n   *\r\n   * @static\r\n   * @param {?object} arg the object to check\r\n   * @return {boolean} true if it's a valid date in the past (or now), false otherwise\r\n   */\r\n  static isDatePast (arg) {\r\n    return (Validator.isDateValid(arg) && arg.getTime() <= Date.now())\r\n  }\r\n\r\n  /**\r\n   * Tell if the given argument is a valid date and in the future or now.\r\n   *\r\n   * See {@link Validator.isDateValid}.\r\n   *\r\n   * @static\r\n   * @param {?object} arg the object to check\r\n   * @return {boolean} true if it's a valid date in the future (or now), false otherwise\r\n   */\r\n  static isDateFuture (arg) {\r\n    return (Validator.isDateValid(arg) && arg.getTime() >= Date.now())\r\n  }\r\n\r\n  /**\r\n   * Tell if the given argument is a number.\r\n   *\r\n   * @static\r\n   * @param {?object} arg the object to check\r\n   * @return {boolean} true if it's a number, false otherwise\r\n   */\r\n  static isNumber (arg) {\r\n    return (Validator.isDefinedAndNotNull(arg) && typeof arg === 'number' && !isNaN(arg))\r\n  }\r\n\r\n  /**\r\n   * Tell if the given argument is an array.\r\n   *\r\n   * @static\r\n   * @param {?object} arg the object to check\r\n   * @return {boolean} true if it's an array, false otherwise\r\n   */\r\n  static isArray (arg) {\r\n    return (Validator.isDefinedAndNotNull(arg) && (Array.isArray(arg)))\r\n  }\r\n\r\n  /**\r\n   * Tell if the given argument is a boolean.\r\n   *\r\n   * @static\r\n   * @param {?object} arg the object to check\r\n   * @return {boolean} true if it's a boolean, false otherwise\r\n   */\r\n  static isBoolean (arg) {\r\n    return (typeof arg === 'boolean')\r\n  }\r\n\r\n  /**\r\n   * Tell if the given argument is an instance of the given class reference.\r\n   *\r\n   * @static\r\n   * @param {?object} arg the object to check\r\n   * @param {?object} classReference the class that should be implemented/extended\r\n   * @return {boolean} true if it's an instance (or extends) that class, false otherwise\r\n   */\r\n  static isClass (arg, classReference) {\r\n    return (arg instanceof classReference)\r\n  }\r\n\r\n  /**\r\n   * Tell if the given argument is an error.\r\n   *\r\n   * @static\r\n   * @param {?object} arg the object to check\r\n   * @return {boolean} true if it's an error, false otherwise\r\n   */\r\n  static isError (arg) {\r\n    return (arg instanceof Error && typeof arg.message !== 'undefined')\r\n  }\r\n\r\n  /**\r\n   * Tell if the given argument is a function.\r\n   *\r\n   * @static\r\n   * @param {?object} arg the object to check\r\n   * @return {boolean} true if it's a function, false otherwise\r\n   */\r\n  static isFunction (arg) {\r\n    return (typeof arg === 'function')\r\n  }\r\n\r\n  /**\r\n   * Tell if the given argument is an object\r\n   * and is defined and not null.\r\n   *\r\n   * @static\r\n   * @param {?object} arg the object to check\r\n   * @return {boolean} true if it's an object, false otherwise\r\n   */\r\n  static isObject (arg) {\r\n    return (Validator.isDefinedAndNotNull(arg) && (typeof arg === 'object'))\r\n  }\r\n\r\n  /**\r\n   * Tell if the given argument is a plain object\r\n   * and not: undefined, null, Array, Date, Number, String,\r\n   * Symbol, Map/WeakMap, Set/WeakSet, etc.\r\n   *\r\n   * @static\r\n   * @param {?object} arg the object to check\r\n   * @return {boolean} true if it's a plain object, false otherwise\r\n   */\r\n  static isObjectPlain (arg) {\r\n    return (Object.prototype.toString.call(arg) === '[object Object]')\r\n  }\r\n\r\n  /**\r\n   * Tell if the given argument is a keyed collection.\r\n   *\r\n   * @static\r\n   * @param {?object} arg the object to check\r\n   * @return {boolean} true if it's a Map|WeakMap or a Set|WeakSet, false otherwise\r\n   */\r\n  static isKeyedCollection (arg) {\r\n    return (Validator.isDefinedAndNotNull(arg) && (\r\n      arg instanceof Map || arg instanceof WeakMap ||\r\n      arg instanceof Set || arg instanceof WeakSet\r\n    ))\r\n  }\r\n\r\n  /**\r\n   * Tell if the given argument is a plain object or a keyed collection.\r\n   *\r\n   * See {@link Validator.isObject}, {@link Validator.isKeyedCollection}.\r\n   *\r\n   * @static\r\n   * @param {?object} arg the object to check\r\n   * @return {boolean} true if it's a plain object or a keyed collection, false otherwise\r\n   */\r\n  static isObjectOrCollection (arg) {\r\n    return (Validator.isObjectPlain(arg) || Validator.isKeyedCollection(arg))\r\n  }\r\n\r\n  /**\r\n   * Tell if the given argument is a plain object or a keyed collection, but not an array.\r\n   *\r\n   * See {@link Validator.isObjectOrCollection}.\r\n   * See {@link Validator.isArray}.\r\n   *\r\n   * @static\r\n   * @param {?object} arg the object to check\r\n   * @return {boolean} true if it's a plain object or a keyed collection but not an array, false otherwise\r\n   */\r\n  static isObjectOrCollectionNotArray (arg) {\r\n    return (Validator.isObjectOrCollection(arg) && !Validator.isArray(arg))\r\n  }\r\n\r\n  /**\r\n   * Tell if the given argument is a plain object or a keyed collection, but not a string.\r\n   *\r\n   * See {@link Validator.isObjectOrCollection}.\r\n   *\r\n   * @static\r\n   * @param {?object} arg the object to check\r\n   * @return {boolean} true if it's a plain object or a keyed collection but not a string, false otherwise\r\n   */\r\n  static isObjectOrCollectionNotString (arg) {\r\n    return (Validator.isObjectOrCollection(arg) && (typeof arg !== 'string'))\r\n  }\r\n\r\n  /**\r\n   * Tell if the given argument is a plain object or a keyed collection, or a string.\r\n   *\r\n   * See {@link Validator.isObjectOrCollection}.\r\n   *\r\n   * @static\r\n   * @param {?object} arg the object to check\r\n   * @return {boolean} true if it's a plain object or a keyed collection or a string, false otherwise\r\n   */\r\n  static isObjectOrCollectionOrString (arg) {\r\n    return (Validator.isObjectOrCollection(arg) || (typeof arg === 'string'))\r\n  }\r\n\r\n  /**\r\n   * Tell if the given argument is a string representation of a version number.\r\n   *\r\n   * Note that the version string could be something like:\r\n   * - as minimum a number is needed for an integer version\r\n   * - at the beginning I can have an optional char 'v' or 'V'\r\n   * - anything after the third number will be considered as a string\r\n   * - format updated to handle version output of 'git describe'\r\n   *\r\n   * @static\r\n   * @param {?string} arg the version string to check\r\n   * @return {boolean} true if it's a version string, false otherwise\r\n   */\r\n  static isVersion (arg) {\r\n    // quick check if the given string is in the format 'n.n.n'\r\n    const versionRegex = /^(?:v|V?)((\\d+)(?:\\.?)){1,3}(?:\\W|_?)(.*)$/gm\r\n    return (Validator.isStringNotEmpty(arg) && versionRegex.test(arg))\r\n  }\r\n\r\n  /**\r\n   * Tell if the given argument is an URI or an URL.\r\n   *\r\n   * @static\r\n   * @param {?string} arg the uri/url to check\r\n   * @param {?string} base the (optional) base to build the full URL\r\n   * @return {boolean} true if it's an URI/URL, false otherwise\r\n   */\r\n  static isURI (arg, base) {\r\n    // quick check if the given string is an URI or an URL\r\n    if (!Validator.isStringNotEmpty(arg)) {\r\n      return false\r\n    }\r\n    // simple check if it's an URL, trying to instancing it\r\n    // note that this requires to import related module here (but not in Browsers) ...\r\n    if (Validator.isStringNotEmpty(base)) {\r\n      try {\r\n        const u = new url.URL(arg, base)\r\n        return (u !== null)\r\n      } catch (e) {\r\n        // console.error(e)\r\n        return false\r\n      }\r\n    } else {\r\n      // simple check if it's an URI (or better, a relative URL)\r\n      if (arg.startsWith('/')) {\r\n        return true\r\n      }\r\n      try {\r\n        // return (new URL(arg) !== null)\r\n        const u = new url.URL(arg)\r\n        return (u !== null)\r\n      } catch (e) {\r\n        // console.error(e)\r\n        return false\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Tell if the given object contains at least one property\r\n   * that has a standard (reserved) property name.\r\n   *\r\n   * @static\r\n   * @param {?object} obj the object to check\r\n   * @param {?function} isPropStandard the function that tell the given argument (property), if it's standard\r\n   * @return {boolean} true if at least one property with a standard name is found, otherwise false\r\n   */\r\n  static doesObjectContainsStandardProperty (obj, isPropStandard) {\r\n    if (!Validator.isObject(obj)) return false\r\n    if (!Validator.isFunction(isPropStandard)) return false\r\n    let standardPropFound = false\r\n    for (const prop in obj) {\r\n      if (isPropStandard(prop) === true) {\r\n        standardPropFound = true\r\n        break\r\n      }\r\n    }\r\n    return standardPropFound\r\n  }\r\n\r\n  /**\r\n   * Tell if the given string has a standard (reserved) property name.\r\n   *\r\n   * @static\r\n   * @param {?string} str the string to check\r\n   * @param {?function} isPropStandard the function that tell the given argument (property), if it's standard\r\n   * @return {boolean} true if the given string has a standard name, otherwise false\r\n   */\r\n  static doesStringIsStandardProperty (str, isPropStandard) {\r\n    if (!Validator.isStringNotEmpty(str)) return false\r\n    if (!Validator.isFunction(isPropStandard)) return false\r\n    let standardPropFound = false\r\n    if (isPropStandard(str) === true) {\r\n      standardPropFound = true\r\n    }\r\n    return standardPropFound\r\n  }\r\n\r\n  /**\r\n   * Ensure that the given argument is undefined.\r\n   *\r\n   * See {@link Validator.isUndefined}.\r\n   *\r\n   * @static\r\n   * @param {?object} arg the object to check\r\n   * @param {string} [name='arg'] the name to use in generated error (or the value of first argument if not given)\r\n   * @return {TypeError} if it's not undefined, nothing otherwise\r\n   */\r\n  static ensureIsUndefined (arg, name = 'arg') {\r\n    if (!Validator.isUndefined(arg)) {\r\n      return new TypeError(`The argument '${name}' must be undefined, instead got a '${typeof arg}'`)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Ensure that the given argument is null.\r\n   *\r\n   * See {@link Validator.isNull}.\r\n   *\r\n   * @static\r\n   * @param {?object} arg the object to check\r\n   * @param {string} [name='arg'] the name to use in generated error (or the value of first argument if not given)\r\n   * @return {TypeError} if it's not null, nothing otherwise\r\n   */\r\n  static ensureIsNull (arg, name = 'arg') {\r\n    if (!Validator.isNull(arg)) {\r\n      return new TypeError(`The argument '${name}' must be null, instead got a '${typeof arg}'`)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Ensure that the given argument is undefined or null.\r\n   *\r\n   * See {@link Validator.isUndefinedOrNull}.\r\n   *\r\n   * @static\r\n   * @param {?object} arg the object to check\r\n   * @param {string} [name='arg'] the name to use in generated error (or the value of first argument if not given)\r\n   * @return {TypeError} if it's not undefined or null, nothing otherwise\r\n   */\r\n  static ensureIsUndefinedOrNull (arg, name = 'arg') {\r\n    if (!Validator.isUndefinedOrNull(arg)) {\r\n      return new TypeError(`The argument '${name}' must be undefined or null, instead got a '${typeof arg}'`)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Ensure that the given argument is defined and not null.\r\n   *\r\n   * See {@link Validator.isDefinedAndNotNull}.\r\n   *\r\n   * @static\r\n   * @param {?object} arg the object to check\r\n   * @param {string} [name='arg'] the name to use in generated error (or the value of first argument if not given)\r\n   * @return {TypeError} if it's not undefined or null, nothing otherwise\r\n   */\r\n  static ensureIsDefinedAndNotNull (arg, name = 'arg') {\r\n    if (!Validator.isDefinedAndNotNull(arg)) {\r\n      return new TypeError(`The argument '${name}' must be defined and not null, instead got a '${typeof arg}'`)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Ensure that the given argument is an array.\r\n   *\r\n   * See {@link Validator.isArray}.\r\n   *\r\n   * @static\r\n   * @param {?object} arg the object to check\r\n   * @param {string} [name='arg'] the name to use in generated error (or the value of first argument if not given)\r\n   * @return {TypeError} if it's not an array, nothing otherwise\r\n   */\r\n  static ensureIsArray (arg, name = 'arg') {\r\n    if (!Validator.isArray(arg)) {\r\n      return new TypeError(`The argument '${name}' must be an array, instead got a '${typeof arg}'`)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Ensure that the given argument is a boolean.\r\n   *\r\n   * See {@link Validator.isBoolean}.\r\n   *\r\n   * @static\r\n   * @param {?object} arg the object to check\r\n   * @param {string} [name='arg'] the name to use in generated error (or the value of first argument if not given)\r\n   * @return {TypeError} if it's not a boolean, nothing otherwise\r\n   */\r\n  static ensureIsBoolean (arg, name = 'arg') {\r\n    if (!Validator.isBoolean(arg)) {\r\n      return new TypeError(`The argument '${name}' must be a boolean, instead got a '${typeof arg}'`)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Ensure that the given argument is an instance of the given class reference.\r\n   *\r\n   * See {@link Validator.isClass}.\r\n   *\r\n   * @static\r\n   * @param {?object} arg the object to check\r\n   * @param {?object} classReference the class that should be implemented/extended\r\n   * @param {string} [name='arg'] the name to use in generated error (or the value of first argument if not given)\r\n   * @return {TypeError} if it's not an instance (or extends) that class, nothing otherwise\r\n   */\r\n  static ensureIsClass (arg, classReference, name = 'arg') {\r\n    if (!Validator.isClass(arg, classReference)) {\r\n      return new TypeError(`The argument '${name}' must be an instance of the given class reference, instead got a '${typeof arg}'`)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Ensure that the given argument is a function.\r\n   *\r\n   * See {@link Validator.isFunction}.\r\n   *\r\n   * @static\r\n   * @param {?object} arg the object to check\r\n   * @param {string} [name='arg'] the name to use in generated error (or the value of first argument if not given)\r\n   * @return {TypeError} if it's not a function, nothing otherwise\r\n   */\r\n  static ensureIsFunction (arg, name = 'arg') {\r\n    if (!Validator.isFunction(arg)) {\r\n      return new TypeError(`The argument '${name}' must be a function, instead got a '${typeof arg}'`)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Ensure that the given argument is a string.\r\n   *\r\n   * See {@link Validator.isString}.\r\n   *\r\n   * @static\r\n   * @param {?object} arg the object to check\r\n   * @param {string} [name='arg'] the name to use in generated error (or the value of first argument if not given)\r\n   * @return {TypeError} if it's not a string, nothing otherwise\r\n   */\r\n  static ensureIsString (arg, name = 'arg') {\r\n    if (!Validator.isString(arg)) {\r\n      return new TypeError(`The argument '${name}' must be a string, instead got a '${typeof arg}'`)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Ensure that the given argument is a not empty string.\r\n   *\r\n   * See {@link Validator.isStringNotEmpty}.\r\n   *\r\n   * @static\r\n   * @param {?object} arg the object to check\r\n   * @param {string} [name='arg'] the name to use in generated error (or the value of first argument if not given)\r\n   * @return {Error} if it's not a string not empty, nothing otherwise\r\n   */\r\n  static ensureIsStringNotEmpty (arg, name = 'arg') {\r\n    if (!Validator.isStringNotEmpty(arg)) {\r\n      return new Error(`The string '${name}' must be not empty`)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Ensure that the given argument is an object.\r\n   *\r\n   * See {@link Validator.isObject}.\r\n   *\r\n   * @static\r\n   * @param {?object} arg the object to check\r\n   * @param {string} [name='arg'] the name to use in generated error (or the value of first argument if not given)\r\n   * @return {TypeError} if it's not an object, nothing otherwise\r\n   */\r\n  static ensureIsObject (arg, name = 'arg') {\r\n    if (!Validator.isObject(arg)) {\r\n      return new TypeError(`The argument '${name}' must be an object, instead got a '${typeof arg}'`)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Ensure that the given argument is a plain object\r\n   * and not: undefined, null, Array, Date, Number, String,\r\n   * Symbol, Map/WeakMap, Set/WeakSet, etc.\r\n   *\r\n   * See {@link Validator.isObjectPlain}.\r\n   *\r\n   * @static\r\n   * @param {?object} arg the object to check\r\n   * @param {string} [name='arg'] the name to use in generated error (or the value of first argument if not given)\r\n   * @return {TypeError} if it's not a plain object, nothing otherwise\r\n   */\r\n  static ensureIsObjectPlain (arg, name = 'arg') {\r\n    if (!Validator.isObjectPlain(arg)) {\r\n      return new TypeError(`The argument '${name}' must be a plain object, instead got a '${typeof arg}'`)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Ensure that the given argument is a plain object or a collection.\r\n   *\r\n   * See {@link Validator.isObjectOrCollection}.\r\n   *\r\n   * @static\r\n   * @param {?object} arg the object to check\r\n   * @param {string} [name='arg'] the name to use in generated error (or the value of first argument if not given)\r\n   * @return {TypeError} if it's not a plain object nor a collection, nothing otherwise\r\n   */\r\n  static ensureIsObjectOrCollection (arg, name = 'arg') {\r\n    if (!Validator.isObjectOrCollection(arg)) {\r\n      return new TypeError(`The argument '${name}' must be an object or a collection, instead got a '${typeof arg}'`)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Ensure that the given argument is a plain object or a collection, not an array.\r\n   *\r\n   * See {@link Validator.isObjectOrCollectionNotArray}.\r\n   *\r\n   * @static\r\n   * @param {?object} arg the object to check\r\n   * @param {string} [name='arg'] the name to use in generated error (or the value of first argument if not given)\r\n   * @return {TypeError} if it's not a plain object nor a collection or it's an array, nothing otherwise\r\n   */\r\n  static ensureIsObjectOrCollectionNotArray (arg, name = 'arg') {\r\n    if (!Validator.isObjectOrCollectionNotArray(arg)) {\r\n      return new TypeError(`The argument '${name}' must be an object or a collection and not an array, instead got a '${typeof arg}'`)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Ensure that the given argument is a plain object or a collection, not a string.\r\n   *\r\n   * See {@link Validator.isObjectOrCollectionNotString}.\r\n   *\r\n   * @static\r\n   * @param {?object} arg the object to check\r\n   * @param {string} [name='arg'] the name to use in generated error (or the value of first argument if not given)\r\n   * @return {TypeError} if it's not a plain object nor a collection or it's a string, nothing otherwise\r\n   */\r\n  static ensureIsObjectOrCollectionNotString (arg, name = 'arg') {\r\n    if (!Validator.isObjectOrCollectionNotString(arg)) {\r\n      return new TypeError(`The argument '${name}' must be an object or a collection and not a string, instead got a '${typeof arg}'`)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Ensure that the given argument is a plain object or a collection, or a string.\r\n   *\r\n   * See {@link Validator.isObjectOrCollectionOrString}.\r\n   *\r\n   * @static\r\n   * @param {?object} arg the object to check\r\n   * @param {string} [name='arg'] the name to use in generated error (or the value of first argument if not given)\r\n   * @return {TypeError} if it's not a plain object nor a collection nor a string, nothing otherwise\r\n   */\r\n  static ensureIsObjectOrCollectionOrString (arg, name = 'arg') {\r\n    if (!Validator.isObjectOrCollectionOrString(arg)) {\r\n      return new TypeError(`The argument '${name}' must be an object or a collection or a string, instead got a '${typeof arg}'`)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Ensure that the given argument is a date.\r\n   *\r\n   * See {@link Validator.isDate}.\r\n   *\r\n   * @static\r\n   * @param {?object} arg the object to check\r\n   * @param {string} [name='arg'] the name to use in generated error (or the value of first argument if not given)\r\n   * @return {Error} if it's not a date, nothing otherwise\r\n   */\r\n  static ensureIsDate (arg, name = 'arg') {\r\n    if (!Validator.isDate(arg)) {\r\n      return new Error(`The argument '${name}' must be a Date, instead got a '${typeof arg}'`)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Ensure that the given argument is a date in the past or now.\r\n   *\r\n   * See {@link Validator.isDatePast}.\r\n   *\r\n   * @static\r\n   * @param {?object} arg the object to check\r\n   * @param {string} [name='arg'] the name to use in generated error (or the value of first argument if not given)\r\n   * @return {Error} if it's not a date in the past, nothing otherwise\r\n   */\r\n  static ensureIsDatePast (arg, name = 'arg') {\r\n    if (!Validator.isDatePast(arg)) {\r\n      return new Error(`The argument '${name}' must be a Date that belongs to the past`)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Ensure that the given argument is a date in the future or now.\r\n   *\r\n   * See {@link Validator.isDateFuture}.\r\n   *\r\n   * @static\r\n   * @param {?object} arg the object to check\r\n   * @param {string} [name='arg'] the name to use in generated error (or the value of first argument if not given)\r\n   * @return {Error} if it's not a date in the future, nothing otherwise\r\n   */\r\n  static ensureIsDateFuture (arg, name = 'arg') {\r\n    if (!Validator.isDateFuture(arg)) {\r\n      return new Error(`The argument '${name}' must be a Date that belongs to the future`)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Ensure that the given argument is a number.\r\n   *\r\n   * See {@link Validator.isNumber}.\r\n   *\r\n   * @static\r\n   * @param {?object} arg the object to check\r\n   * @param {string} [name='arg'] the name to use in generated error (or the value of first argument if not given)\r\n   * @return {Error} if it's not a number, nothing otherwise\r\n   */\r\n  static ensureIsNumber (arg, name = 'arg') {\r\n    if (!Validator.isNumber(arg)) {\r\n      return new Error(`The argument '${name}' must be a Number, instead got a '${typeof arg}'`)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Ensure that the given argument is an error instance or its subclass.\r\n   *\r\n   * See {@link Validator.isError}.\r\n   *\r\n   * @static\r\n   * @param {?object} arg the object to check\r\n   * @param {string} [name='arg'] the name to use in generated error (or the value of first argument if not given)\r\n   * @return {Error} if it's not an error or its subclass, nothing otherwise\r\n   */\r\n  static ensureIsError (arg, name = 'arg') {\r\n    if (!Validator.isError(arg)) {\r\n      return new Error(`The argument '${name}' must be an Error or a subclass of it, instead got a '${typeof arg}'`)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Ensure that the given argument is a string version.\r\n   *\r\n   * See {@link Validator.isVersion}.\r\n   *\r\n   * @static\r\n   * @param {?object} arg the object to check\r\n   * @param {string} [name='arg'] the name to use in generated error (or the value of first argument if not given)\r\n   * @return {Error} if it's not a string version, nothing otherwise\r\n   */\r\n  static ensureIsVersion (arg, name = 'arg') {\r\n    if (!Validator.isVersion(arg)) {\r\n      return new Error(`The argument '${name}' must be a string in the format 'n.n.n', and not '${arg}'`)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Ensure that the given argument is an URI/URL.\r\n   *\r\n   * See {@link Validator.isURI}.\r\n   *\r\n   * @static\r\n   * @param {?object} arg the object to check\r\n   * @param {?string} base the (optional) base to build the full URL\r\n   * @param {string} [name='arg'] the name to use in generated error (or the value of first argument if not given)\r\n   * @return {Error} if it's not an URI/URL, nothing otherwise\r\n   */\r\n  static ensureIsURI (arg, base, name = 'arg') {\r\n    if (!Validator.isURI(arg, base)) {\r\n      return new Error(`The argument '${name}' must be an URI or URL string, and not '${arg}', '${base}'`)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Ensure that the given object does not contain any property\r\n   * that has a standard (reserved) property name.\r\n   *\r\n   * See {@link Validator.doesObjectContainsStandardProperty}.\r\n   *\r\n   * @static\r\n   * @param {?object} arg the object to check\r\n   * @param {?function} isPropStandard the function that tell the given argument (property), if it's standard\r\n   * @param {string} [name='arg'] the name to use in generated error (or the value of first argument if not given)\r\n   * @return {Error} if at least one property with a standard name is found, nothing otherwise\r\n   */\r\n  static ensureObjectDoesNotContainStandardProperty (arg, isPropStandard, name = 'arg') {\r\n    if (Validator.doesObjectContainsStandardProperty(arg, isPropStandard)) {\r\n      return new Error(`The object with name '${name}' contains at least one property with a standard name`)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Tell the size of the given object\r\n   *\r\n   * @static\r\n   * @param {?object} arg the object to check\r\n   * @return {number} the size if it's an array|Map|Set|object|string, nothing otherwise\r\n   * @throws {TypeError} if it's not an array nor a collection nor object nor a string\r\n   */\r\n  static getSize (arg) {\r\n    if ((arg === undefined || arg === null)) {\r\n      return\r\n    }\r\n    if (Array.isArray(arg)) {\r\n      return arg.length\r\n    } else if (arg instanceof Map || arg instanceof Set) {\r\n      return arg.size\r\n    } else if (typeof arg === 'object') {\r\n      return Object.keys(arg).length\r\n    } else if (typeof arg === 'string') {\r\n      return arg.length\r\n    }\r\n    // else\r\n    throw new TypeError(`Unable to calculate the size of the argument '${arg}'.`)\r\n  }\r\n\r\n  /**\r\n   * Tell the size in bytes of the given string.\r\n   *\r\n   * @static\r\n   * @param {?string} str the string to check\r\n   * @return {number} the size if it's a string, nothing otherwise\r\n   * @throws {TypeError} if it's not a string\r\n   */\r\n  static getSizeInBytes (str) {\r\n    if ((str === undefined || str === null)) {\r\n      return\r\n    }\r\n    if (typeof str === 'string') {\r\n      return Buffer.from(str).length\r\n    }\r\n    // else\r\n    throw new TypeError(`Unable to calculate the size in bytes of the argument '${str}'.`)\r\n  }\r\n\r\n  /**\r\n   * Return the value of the variable given as argument.\r\n   *\r\n   * Note that this could have been written (in a shorter way)\r\n   * as an arrow function.\r\n   *\r\n   * @static\r\n   * @param {?object} arg the argument\r\n   * @return {string} the value of the variable (if defined and not null), nothing otherwise\r\n   */\r\n  static getArgumentValue (arg) {\r\n    if ((arg === undefined || arg === null)) {\r\n      return arg\r\n    }\r\n    // else\r\n    return arguments[0]\r\n  }\r\n\r\n  /**\r\n   * Return the name of the variable given as argument.\r\n   *\r\n   * To use it, must be called using the trick to wrap argument\r\n   * inside an object literal, so for example use it inside a template string with:\r\n   * `${getArgumentName({x})}`\r\n   * with nested objects (like with options with a property x inside)\r\n   * you need to use with:\r\n   * `${getArgumentName({options})}.${getArgumentName({x})}`.\r\n   * Note that this could have been written (in a shorter way)\r\n   * as an arrow function.\r\n   *\r\n   * @static\r\n   * @param {?object} arg the argument\r\n   * @return {string} the name of the variable (if defined and not null), nothing otherwise\r\n   */\r\n  static getArgumentName (arg) {\r\n    if ((arg === undefined || arg === null)) {\r\n      return\r\n    }\r\n    // else\r\n    return Object.keys(arg)[0]\r\n  }\r\n\r\n  /**\r\n   * Return the argument if it's defined and not null,\r\n   * otherwise the given default value is returned.\r\n   *\r\n   * @static\r\n   * @param {?object} arg the argument to return\r\n   * @param {?object} def the default value to return\r\n   * @return {object} the argument (if defined and not null), otherwise the default value\r\n   */\r\n  static getOrElse (arg, def) {\r\n    if (typeof arg !== 'undefined' && arg !== null) {\r\n      return arg\r\n    }\r\n    // else\r\n    return def\r\n  }\r\n\r\n  /**\r\n   * Return a copy of the given ibject,\r\n   * with all properties filtered by the given function (predicate).\r\n   *\r\n   * @static\r\n   * @param {?object} obj the base object\r\n   * @param {?function} propFilter the function (predicate) for filtering properties\r\n   * @return {object} a new object containing only filtered properties\r\n   * @throws {TypeError} if obj is not a plain object, or propFilter is not a function\r\n   */\r\n  static getObjectFilteredProperties (obj, propFilter) {\r\n    if (!Validator.isObjectPlain(obj)) throw new TypeError(`The argument 'obj' must be a plain object, instead got a '${typeof obj}'`)\r\n    if (!Validator.isFunction(propFilter)) throw new TypeError(`The argument 'propFilter' must be a function, instead got a '${typeof propFilter}'`)\r\n    const objFiltered = {}\r\n    for (const [key, value] of Object.entries(obj)) {\r\n      if (propFilter(key) === true) {\r\n        objFiltered[key] = value\r\n      }\r\n    }\r\n    return objFiltered\r\n  }\r\n\r\n  /**\r\n   * Throw if the given argument is an error instance or its subclass.\r\n   *\r\n   * See {@link Validator.isError}.\r\n   *\r\n   * @static\r\n   * @param {?object} arg the object to check\r\n   * @throws {Error} the given error\r\n   */\r\n  static throwOnError (arg) {\r\n    if (Validator.isError(arg)) {\r\n      throw arg\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Throw if the given argument is false.\r\n   * Note that this is similar to assertions.\r\n   *\r\n   * See {@link Validator.isError}.\r\n   *\r\n   * @static\r\n   * @param {?object} arg the object to check\r\n   * @param {string} [name='arg'] the name to use in generated error (or the value of first argument if not given)\r\n   * @throws {Error} if the given argument is not a boolean, or if it's false\r\n   */\r\n  static throwOnFalse (arg, name = 'arg') {\r\n    if (!Validator.isBoolean(arg) || arg === false) {\r\n      return new Error(`The argument '${name}' is false`)\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = Validator\r\n",
    "static": true,
    "longname": "/Users/martinis/work/prove/cloudevent.js/src/validator.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 117,
    "kind": "class",
    "name": "Validator",
    "memberof": "src/validator.js",
    "static": true,
    "longname": "src/validator.js~Validator",
    "access": "public",
    "export": true,
    "importPath": "cloudevent/src/validator.js",
    "importStyle": "Validator",
    "description": "Generic Validator implementation.\n\nNote that all methods here are static, so no need to instance this class;\nsee it as an Utility/Companion class.",
    "lineNumber": 31,
    "interface": false
  },
  {
    "__docId__": 118,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/validator.js~Validator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/validator.js~Validator#constructor",
    "access": "public",
    "description": "Create a new instance of a Validator object.\n\nNote that instancing is not allowed for this class because all its methods are static.",
    "lineNumber": 39,
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "because instancing not allowed for this class"
      }
    ]
  },
  {
    "__docId__": 119,
    "kind": "method",
    "name": "isUndefined",
    "memberof": "src/validator.js~Validator",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/validator.js~Validator.isUndefined",
    "access": "public",
    "description": "Tell if the given argument is undefined.",
    "lineNumber": 50,
    "params": [
      {
        "nullable": true,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "arg",
        "description": "the object to check"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if undefined, false otherwise"
    }
  },
  {
    "__docId__": 120,
    "kind": "method",
    "name": "isNull",
    "memberof": "src/validator.js~Validator",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/validator.js~Validator.isNull",
    "access": "public",
    "description": "Tell if the given argument is null.",
    "lineNumber": 61,
    "params": [
      {
        "nullable": true,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "arg",
        "description": "the object to check"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if null, false otherwise"
    }
  },
  {
    "__docId__": 121,
    "kind": "method",
    "name": "isUndefinedOrNull",
    "memberof": "src/validator.js~Validator",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/validator.js~Validator.isUndefinedOrNull",
    "access": "public",
    "description": "Tell if the given argument is undefined or null.",
    "lineNumber": 72,
    "params": [
      {
        "nullable": true,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "arg",
        "description": "the object to check"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if undefined or null, false otherwise"
    }
  },
  {
    "__docId__": 122,
    "kind": "method",
    "name": "isDefinedAndNotNull",
    "memberof": "src/validator.js~Validator",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/validator.js~Validator.isDefinedAndNotNull",
    "access": "public",
    "description": "Tell if the given argument is defined and not null.",
    "lineNumber": 83,
    "params": [
      {
        "nullable": true,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "arg",
        "description": "the object to check"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if defined and not null, false otherwise"
    }
  },
  {
    "__docId__": 123,
    "kind": "method",
    "name": "isString",
    "memberof": "src/validator.js~Validator",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/validator.js~Validator.isString",
    "access": "public",
    "description": "Tell if the given argument is a string.",
    "lineNumber": 94,
    "params": [
      {
        "nullable": true,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "arg",
        "description": "the object to check"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if it's a string, false otherwise"
    }
  },
  {
    "__docId__": 124,
    "kind": "method",
    "name": "isStringNotEmpty",
    "memberof": "src/validator.js~Validator",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/validator.js~Validator.isStringNotEmpty",
    "access": "public",
    "description": "Tell if the given argument is a not empty string.\n\nSee {@link Validator.isString}.",
    "lineNumber": 107,
    "params": [
      {
        "nullable": true,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "arg",
        "description": "the object to check"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if it's a not empty string, false otherwise"
    }
  },
  {
    "__docId__": 125,
    "kind": "method",
    "name": "isDate",
    "memberof": "src/validator.js~Validator",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/validator.js~Validator.isDate",
    "access": "public",
    "description": "Tell if the given argument is a date.",
    "lineNumber": 118,
    "params": [
      {
        "nullable": true,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "arg",
        "description": "the object to check"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if it's a date, false otherwise"
    }
  },
  {
    "__docId__": 126,
    "kind": "method",
    "name": "isDateValid",
    "memberof": "src/validator.js~Validator",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/validator.js~Validator.isDateValid",
    "access": "public",
    "description": "Tell if the given argument is a valid date.\n\nSee {@link Validator.isDate}.",
    "lineNumber": 131,
    "params": [
      {
        "nullable": true,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "arg",
        "description": "the object to check"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if it's a valid date, false otherwise"
    }
  },
  {
    "__docId__": 127,
    "kind": "method",
    "name": "isDatePast",
    "memberof": "src/validator.js~Validator",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/validator.js~Validator.isDatePast",
    "access": "public",
    "description": "Tell if the given argument is a valid date and in the past or now.\n\nSee {@link Validator.isDateValid}.",
    "lineNumber": 144,
    "params": [
      {
        "nullable": true,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "arg",
        "description": "the object to check"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if it's a valid date in the past (or now), false otherwise"
    }
  },
  {
    "__docId__": 128,
    "kind": "method",
    "name": "isDateFuture",
    "memberof": "src/validator.js~Validator",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/validator.js~Validator.isDateFuture",
    "access": "public",
    "description": "Tell if the given argument is a valid date and in the future or now.\n\nSee {@link Validator.isDateValid}.",
    "lineNumber": 157,
    "params": [
      {
        "nullable": true,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "arg",
        "description": "the object to check"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if it's a valid date in the future (or now), false otherwise"
    }
  },
  {
    "__docId__": 129,
    "kind": "method",
    "name": "isNumber",
    "memberof": "src/validator.js~Validator",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/validator.js~Validator.isNumber",
    "access": "public",
    "description": "Tell if the given argument is a number.",
    "lineNumber": 168,
    "params": [
      {
        "nullable": true,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "arg",
        "description": "the object to check"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if it's a number, false otherwise"
    }
  },
  {
    "__docId__": 130,
    "kind": "method",
    "name": "isArray",
    "memberof": "src/validator.js~Validator",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/validator.js~Validator.isArray",
    "access": "public",
    "description": "Tell if the given argument is an array.",
    "lineNumber": 179,
    "params": [
      {
        "nullable": true,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "arg",
        "description": "the object to check"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if it's an array, false otherwise"
    }
  },
  {
    "__docId__": 131,
    "kind": "method",
    "name": "isBoolean",
    "memberof": "src/validator.js~Validator",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/validator.js~Validator.isBoolean",
    "access": "public",
    "description": "Tell if the given argument is a boolean.",
    "lineNumber": 190,
    "params": [
      {
        "nullable": true,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "arg",
        "description": "the object to check"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if it's a boolean, false otherwise"
    }
  },
  {
    "__docId__": 132,
    "kind": "method",
    "name": "isClass",
    "memberof": "src/validator.js~Validator",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/validator.js~Validator.isClass",
    "access": "public",
    "description": "Tell if the given argument is an instance of the given class reference.",
    "lineNumber": 202,
    "params": [
      {
        "nullable": true,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "arg",
        "description": "the object to check"
      },
      {
        "nullable": true,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "classReference",
        "description": "the class that should be implemented/extended"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if it's an instance (or extends) that class, false otherwise"
    }
  },
  {
    "__docId__": 133,
    "kind": "method",
    "name": "isError",
    "memberof": "src/validator.js~Validator",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/validator.js~Validator.isError",
    "access": "public",
    "description": "Tell if the given argument is an error.",
    "lineNumber": 213,
    "params": [
      {
        "nullable": true,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "arg",
        "description": "the object to check"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if it's an error, false otherwise"
    }
  },
  {
    "__docId__": 134,
    "kind": "method",
    "name": "isFunction",
    "memberof": "src/validator.js~Validator",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/validator.js~Validator.isFunction",
    "access": "public",
    "description": "Tell if the given argument is a function.",
    "lineNumber": 224,
    "params": [
      {
        "nullable": true,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "arg",
        "description": "the object to check"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if it's a function, false otherwise"
    }
  },
  {
    "__docId__": 135,
    "kind": "method",
    "name": "isObject",
    "memberof": "src/validator.js~Validator",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/validator.js~Validator.isObject",
    "access": "public",
    "description": "Tell if the given argument is an object\nand is defined and not null.",
    "lineNumber": 236,
    "params": [
      {
        "nullable": true,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "arg",
        "description": "the object to check"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if it's an object, false otherwise"
    }
  },
  {
    "__docId__": 136,
    "kind": "method",
    "name": "isObjectPlain",
    "memberof": "src/validator.js~Validator",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/validator.js~Validator.isObjectPlain",
    "access": "public",
    "description": "Tell if the given argument is a plain object\nand not: undefined, null, Array, Date, Number, String,\nSymbol, Map/WeakMap, Set/WeakSet, etc.",
    "lineNumber": 249,
    "params": [
      {
        "nullable": true,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "arg",
        "description": "the object to check"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if it's a plain object, false otherwise"
    }
  },
  {
    "__docId__": 137,
    "kind": "method",
    "name": "isKeyedCollection",
    "memberof": "src/validator.js~Validator",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/validator.js~Validator.isKeyedCollection",
    "access": "public",
    "description": "Tell if the given argument is a keyed collection.",
    "lineNumber": 260,
    "params": [
      {
        "nullable": true,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "arg",
        "description": "the object to check"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if it's a Map|WeakMap or a Set|WeakSet, false otherwise"
    }
  },
  {
    "__docId__": 138,
    "kind": "method",
    "name": "isObjectOrCollection",
    "memberof": "src/validator.js~Validator",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/validator.js~Validator.isObjectOrCollection",
    "access": "public",
    "description": "Tell if the given argument is a plain object or a keyed collection.\n\nSee {@link Validator.isObject}, {@link Validator.isKeyedCollection}.",
    "lineNumber": 276,
    "params": [
      {
        "nullable": true,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "arg",
        "description": "the object to check"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if it's a plain object or a keyed collection, false otherwise"
    }
  },
  {
    "__docId__": 139,
    "kind": "method",
    "name": "isObjectOrCollectionNotArray",
    "memberof": "src/validator.js~Validator",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/validator.js~Validator.isObjectOrCollectionNotArray",
    "access": "public",
    "description": "Tell if the given argument is a plain object or a keyed collection, but not an array.\n\nSee {@link Validator.isObjectOrCollection}.\nSee {@link Validator.isArray}.",
    "lineNumber": 290,
    "params": [
      {
        "nullable": true,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "arg",
        "description": "the object to check"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if it's a plain object or a keyed collection but not an array, false otherwise"
    }
  },
  {
    "__docId__": 140,
    "kind": "method",
    "name": "isObjectOrCollectionNotString",
    "memberof": "src/validator.js~Validator",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/validator.js~Validator.isObjectOrCollectionNotString",
    "access": "public",
    "description": "Tell if the given argument is a plain object or a keyed collection, but not a string.\n\nSee {@link Validator.isObjectOrCollection}.",
    "lineNumber": 303,
    "params": [
      {
        "nullable": true,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "arg",
        "description": "the object to check"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if it's a plain object or a keyed collection but not a string, false otherwise"
    }
  },
  {
    "__docId__": 141,
    "kind": "method",
    "name": "isObjectOrCollectionOrString",
    "memberof": "src/validator.js~Validator",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/validator.js~Validator.isObjectOrCollectionOrString",
    "access": "public",
    "description": "Tell if the given argument is a plain object or a keyed collection, or a string.\n\nSee {@link Validator.isObjectOrCollection}.",
    "lineNumber": 316,
    "params": [
      {
        "nullable": true,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "arg",
        "description": "the object to check"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if it's a plain object or a keyed collection or a string, false otherwise"
    }
  },
  {
    "__docId__": 142,
    "kind": "method",
    "name": "isVersion",
    "memberof": "src/validator.js~Validator",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/validator.js~Validator.isVersion",
    "access": "public",
    "description": "Tell if the given argument is a string representation of a version number.\n\nNote that the version string could be something like:\n- as minimum a number is needed for an integer version\n- at the beginning I can have an optional char 'v' or 'V'\n- anything after the third number will be considered as a string\n- format updated to handle version output of 'git describe'",
    "lineNumber": 333,
    "params": [
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "arg",
        "description": "the version string to check"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if it's a version string, false otherwise"
    }
  },
  {
    "__docId__": 143,
    "kind": "method",
    "name": "isURI",
    "memberof": "src/validator.js~Validator",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/validator.js~Validator.isURI",
    "access": "public",
    "description": "Tell if the given argument is an URI or an URL.",
    "lineNumber": 347,
    "params": [
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "arg",
        "description": "the uri/url to check"
      },
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "base",
        "description": "the (optional) base to build the full URL"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if it's an URI/URL, false otherwise"
    }
  },
  {
    "__docId__": 144,
    "kind": "method",
    "name": "doesObjectContainsStandardProperty",
    "memberof": "src/validator.js~Validator",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/validator.js~Validator.doesObjectContainsStandardProperty",
    "access": "public",
    "description": "Tell if the given object contains at least one property\nthat has a standard (reserved) property name.",
    "lineNumber": 387,
    "params": [
      {
        "nullable": true,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "obj",
        "description": "the object to check"
      },
      {
        "nullable": true,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "isPropStandard",
        "description": "the function that tell the given argument (property), if it's standard"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if at least one property with a standard name is found, otherwise false"
    }
  },
  {
    "__docId__": 145,
    "kind": "method",
    "name": "doesStringIsStandardProperty",
    "memberof": "src/validator.js~Validator",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/validator.js~Validator.doesStringIsStandardProperty",
    "access": "public",
    "description": "Tell if the given string has a standard (reserved) property name.",
    "lineNumber": 408,
    "params": [
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "str",
        "description": "the string to check"
      },
      {
        "nullable": true,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "isPropStandard",
        "description": "the function that tell the given argument (property), if it's standard"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if the given string has a standard name, otherwise false"
    }
  },
  {
    "__docId__": 146,
    "kind": "method",
    "name": "ensureIsUndefined",
    "memberof": "src/validator.js~Validator",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/validator.js~Validator.ensureIsUndefined",
    "access": "public",
    "description": "Ensure that the given argument is undefined.\n\nSee {@link Validator.isUndefined}.",
    "lineNumber": 428,
    "params": [
      {
        "nullable": true,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "arg",
        "description": "the object to check"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'arg'",
        "defaultRaw": "'arg'",
        "name": "name",
        "description": "the name to use in generated error (or the value of first argument if not given)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "TypeError"
      ],
      "spread": false,
      "description": "if it's not undefined, nothing otherwise"
    }
  },
  {
    "__docId__": 147,
    "kind": "method",
    "name": "ensureIsNull",
    "memberof": "src/validator.js~Validator",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/validator.js~Validator.ensureIsNull",
    "access": "public",
    "description": "Ensure that the given argument is null.\n\nSee {@link Validator.isNull}.",
    "lineNumber": 444,
    "params": [
      {
        "nullable": true,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "arg",
        "description": "the object to check"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'arg'",
        "defaultRaw": "'arg'",
        "name": "name",
        "description": "the name to use in generated error (or the value of first argument if not given)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "TypeError"
      ],
      "spread": false,
      "description": "if it's not null, nothing otherwise"
    }
  },
  {
    "__docId__": 148,
    "kind": "method",
    "name": "ensureIsUndefinedOrNull",
    "memberof": "src/validator.js~Validator",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/validator.js~Validator.ensureIsUndefinedOrNull",
    "access": "public",
    "description": "Ensure that the given argument is undefined or null.\n\nSee {@link Validator.isUndefinedOrNull}.",
    "lineNumber": 460,
    "params": [
      {
        "nullable": true,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "arg",
        "description": "the object to check"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'arg'",
        "defaultRaw": "'arg'",
        "name": "name",
        "description": "the name to use in generated error (or the value of first argument if not given)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "TypeError"
      ],
      "spread": false,
      "description": "if it's not undefined or null, nothing otherwise"
    }
  },
  {
    "__docId__": 149,
    "kind": "method",
    "name": "ensureIsDefinedAndNotNull",
    "memberof": "src/validator.js~Validator",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/validator.js~Validator.ensureIsDefinedAndNotNull",
    "access": "public",
    "description": "Ensure that the given argument is defined and not null.\n\nSee {@link Validator.isDefinedAndNotNull}.",
    "lineNumber": 476,
    "params": [
      {
        "nullable": true,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "arg",
        "description": "the object to check"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'arg'",
        "defaultRaw": "'arg'",
        "name": "name",
        "description": "the name to use in generated error (or the value of first argument if not given)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "TypeError"
      ],
      "spread": false,
      "description": "if it's not undefined or null, nothing otherwise"
    }
  },
  {
    "__docId__": 150,
    "kind": "method",
    "name": "ensureIsArray",
    "memberof": "src/validator.js~Validator",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/validator.js~Validator.ensureIsArray",
    "access": "public",
    "description": "Ensure that the given argument is an array.\n\nSee {@link Validator.isArray}.",
    "lineNumber": 492,
    "params": [
      {
        "nullable": true,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "arg",
        "description": "the object to check"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'arg'",
        "defaultRaw": "'arg'",
        "name": "name",
        "description": "the name to use in generated error (or the value of first argument if not given)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "TypeError"
      ],
      "spread": false,
      "description": "if it's not an array, nothing otherwise"
    }
  },
  {
    "__docId__": 151,
    "kind": "method",
    "name": "ensureIsBoolean",
    "memberof": "src/validator.js~Validator",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/validator.js~Validator.ensureIsBoolean",
    "access": "public",
    "description": "Ensure that the given argument is a boolean.\n\nSee {@link Validator.isBoolean}.",
    "lineNumber": 508,
    "params": [
      {
        "nullable": true,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "arg",
        "description": "the object to check"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'arg'",
        "defaultRaw": "'arg'",
        "name": "name",
        "description": "the name to use in generated error (or the value of first argument if not given)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "TypeError"
      ],
      "spread": false,
      "description": "if it's not a boolean, nothing otherwise"
    }
  },
  {
    "__docId__": 152,
    "kind": "method",
    "name": "ensureIsClass",
    "memberof": "src/validator.js~Validator",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/validator.js~Validator.ensureIsClass",
    "access": "public",
    "description": "Ensure that the given argument is an instance of the given class reference.\n\nSee {@link Validator.isClass}.",
    "lineNumber": 525,
    "params": [
      {
        "nullable": true,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "arg",
        "description": "the object to check"
      },
      {
        "nullable": true,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "classReference",
        "description": "the class that should be implemented/extended"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'arg'",
        "defaultRaw": "'arg'",
        "name": "name",
        "description": "the name to use in generated error (or the value of first argument if not given)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "TypeError"
      ],
      "spread": false,
      "description": "if it's not an instance (or extends) that class, nothing otherwise"
    }
  },
  {
    "__docId__": 153,
    "kind": "method",
    "name": "ensureIsFunction",
    "memberof": "src/validator.js~Validator",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/validator.js~Validator.ensureIsFunction",
    "access": "public",
    "description": "Ensure that the given argument is a function.\n\nSee {@link Validator.isFunction}.",
    "lineNumber": 541,
    "params": [
      {
        "nullable": true,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "arg",
        "description": "the object to check"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'arg'",
        "defaultRaw": "'arg'",
        "name": "name",
        "description": "the name to use in generated error (or the value of first argument if not given)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "TypeError"
      ],
      "spread": false,
      "description": "if it's not a function, nothing otherwise"
    }
  },
  {
    "__docId__": 154,
    "kind": "method",
    "name": "ensureIsString",
    "memberof": "src/validator.js~Validator",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/validator.js~Validator.ensureIsString",
    "access": "public",
    "description": "Ensure that the given argument is a string.\n\nSee {@link Validator.isString}.",
    "lineNumber": 557,
    "params": [
      {
        "nullable": true,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "arg",
        "description": "the object to check"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'arg'",
        "defaultRaw": "'arg'",
        "name": "name",
        "description": "the name to use in generated error (or the value of first argument if not given)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "TypeError"
      ],
      "spread": false,
      "description": "if it's not a string, nothing otherwise"
    }
  },
  {
    "__docId__": 155,
    "kind": "method",
    "name": "ensureIsStringNotEmpty",
    "memberof": "src/validator.js~Validator",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/validator.js~Validator.ensureIsStringNotEmpty",
    "access": "public",
    "description": "Ensure that the given argument is a not empty string.\n\nSee {@link Validator.isStringNotEmpty}.",
    "lineNumber": 573,
    "params": [
      {
        "nullable": true,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "arg",
        "description": "the object to check"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'arg'",
        "defaultRaw": "'arg'",
        "name": "name",
        "description": "the name to use in generated error (or the value of first argument if not given)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Error"
      ],
      "spread": false,
      "description": "if it's not a string not empty, nothing otherwise"
    }
  },
  {
    "__docId__": 156,
    "kind": "method",
    "name": "ensureIsObject",
    "memberof": "src/validator.js~Validator",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/validator.js~Validator.ensureIsObject",
    "access": "public",
    "description": "Ensure that the given argument is an object.\n\nSee {@link Validator.isObject}.",
    "lineNumber": 589,
    "params": [
      {
        "nullable": true,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "arg",
        "description": "the object to check"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'arg'",
        "defaultRaw": "'arg'",
        "name": "name",
        "description": "the name to use in generated error (or the value of first argument if not given)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "TypeError"
      ],
      "spread": false,
      "description": "if it's not an object, nothing otherwise"
    }
  },
  {
    "__docId__": 157,
    "kind": "method",
    "name": "ensureIsObjectPlain",
    "memberof": "src/validator.js~Validator",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/validator.js~Validator.ensureIsObjectPlain",
    "access": "public",
    "description": "Ensure that the given argument is a plain object\nand not: undefined, null, Array, Date, Number, String,\nSymbol, Map/WeakMap, Set/WeakSet, etc.\n\nSee {@link Validator.isObjectPlain}.",
    "lineNumber": 607,
    "params": [
      {
        "nullable": true,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "arg",
        "description": "the object to check"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'arg'",
        "defaultRaw": "'arg'",
        "name": "name",
        "description": "the name to use in generated error (or the value of first argument if not given)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "TypeError"
      ],
      "spread": false,
      "description": "if it's not a plain object, nothing otherwise"
    }
  },
  {
    "__docId__": 158,
    "kind": "method",
    "name": "ensureIsObjectOrCollection",
    "memberof": "src/validator.js~Validator",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/validator.js~Validator.ensureIsObjectOrCollection",
    "access": "public",
    "description": "Ensure that the given argument is a plain object or a collection.\n\nSee {@link Validator.isObjectOrCollection}.",
    "lineNumber": 623,
    "params": [
      {
        "nullable": true,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "arg",
        "description": "the object to check"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'arg'",
        "defaultRaw": "'arg'",
        "name": "name",
        "description": "the name to use in generated error (or the value of first argument if not given)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "TypeError"
      ],
      "spread": false,
      "description": "if it's not a plain object nor a collection, nothing otherwise"
    }
  },
  {
    "__docId__": 159,
    "kind": "method",
    "name": "ensureIsObjectOrCollectionNotArray",
    "memberof": "src/validator.js~Validator",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/validator.js~Validator.ensureIsObjectOrCollectionNotArray",
    "access": "public",
    "description": "Ensure that the given argument is a plain object or a collection, not an array.\n\nSee {@link Validator.isObjectOrCollectionNotArray}.",
    "lineNumber": 639,
    "params": [
      {
        "nullable": true,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "arg",
        "description": "the object to check"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'arg'",
        "defaultRaw": "'arg'",
        "name": "name",
        "description": "the name to use in generated error (or the value of first argument if not given)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "TypeError"
      ],
      "spread": false,
      "description": "if it's not a plain object nor a collection or it's an array, nothing otherwise"
    }
  },
  {
    "__docId__": 160,
    "kind": "method",
    "name": "ensureIsObjectOrCollectionNotString",
    "memberof": "src/validator.js~Validator",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/validator.js~Validator.ensureIsObjectOrCollectionNotString",
    "access": "public",
    "description": "Ensure that the given argument is a plain object or a collection, not a string.\n\nSee {@link Validator.isObjectOrCollectionNotString}.",
    "lineNumber": 655,
    "params": [
      {
        "nullable": true,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "arg",
        "description": "the object to check"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'arg'",
        "defaultRaw": "'arg'",
        "name": "name",
        "description": "the name to use in generated error (or the value of first argument if not given)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "TypeError"
      ],
      "spread": false,
      "description": "if it's not a plain object nor a collection or it's a string, nothing otherwise"
    }
  },
  {
    "__docId__": 161,
    "kind": "method",
    "name": "ensureIsObjectOrCollectionOrString",
    "memberof": "src/validator.js~Validator",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/validator.js~Validator.ensureIsObjectOrCollectionOrString",
    "access": "public",
    "description": "Ensure that the given argument is a plain object or a collection, or a string.\n\nSee {@link Validator.isObjectOrCollectionOrString}.",
    "lineNumber": 671,
    "params": [
      {
        "nullable": true,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "arg",
        "description": "the object to check"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'arg'",
        "defaultRaw": "'arg'",
        "name": "name",
        "description": "the name to use in generated error (or the value of first argument if not given)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "TypeError"
      ],
      "spread": false,
      "description": "if it's not a plain object nor a collection nor a string, nothing otherwise"
    }
  },
  {
    "__docId__": 162,
    "kind": "method",
    "name": "ensureIsDate",
    "memberof": "src/validator.js~Validator",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/validator.js~Validator.ensureIsDate",
    "access": "public",
    "description": "Ensure that the given argument is a date.\n\nSee {@link Validator.isDate}.",
    "lineNumber": 687,
    "params": [
      {
        "nullable": true,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "arg",
        "description": "the object to check"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'arg'",
        "defaultRaw": "'arg'",
        "name": "name",
        "description": "the name to use in generated error (or the value of first argument if not given)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Error"
      ],
      "spread": false,
      "description": "if it's not a date, nothing otherwise"
    }
  },
  {
    "__docId__": 163,
    "kind": "method",
    "name": "ensureIsDatePast",
    "memberof": "src/validator.js~Validator",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/validator.js~Validator.ensureIsDatePast",
    "access": "public",
    "description": "Ensure that the given argument is a date in the past or now.\n\nSee {@link Validator.isDatePast}.",
    "lineNumber": 703,
    "params": [
      {
        "nullable": true,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "arg",
        "description": "the object to check"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'arg'",
        "defaultRaw": "'arg'",
        "name": "name",
        "description": "the name to use in generated error (or the value of first argument if not given)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Error"
      ],
      "spread": false,
      "description": "if it's not a date in the past, nothing otherwise"
    }
  },
  {
    "__docId__": 164,
    "kind": "method",
    "name": "ensureIsDateFuture",
    "memberof": "src/validator.js~Validator",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/validator.js~Validator.ensureIsDateFuture",
    "access": "public",
    "description": "Ensure that the given argument is a date in the future or now.\n\nSee {@link Validator.isDateFuture}.",
    "lineNumber": 719,
    "params": [
      {
        "nullable": true,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "arg",
        "description": "the object to check"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'arg'",
        "defaultRaw": "'arg'",
        "name": "name",
        "description": "the name to use in generated error (or the value of first argument if not given)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Error"
      ],
      "spread": false,
      "description": "if it's not a date in the future, nothing otherwise"
    }
  },
  {
    "__docId__": 165,
    "kind": "method",
    "name": "ensureIsNumber",
    "memberof": "src/validator.js~Validator",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/validator.js~Validator.ensureIsNumber",
    "access": "public",
    "description": "Ensure that the given argument is a number.\n\nSee {@link Validator.isNumber}.",
    "lineNumber": 735,
    "params": [
      {
        "nullable": true,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "arg",
        "description": "the object to check"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'arg'",
        "defaultRaw": "'arg'",
        "name": "name",
        "description": "the name to use in generated error (or the value of first argument if not given)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Error"
      ],
      "spread": false,
      "description": "if it's not a number, nothing otherwise"
    }
  },
  {
    "__docId__": 166,
    "kind": "method",
    "name": "ensureIsError",
    "memberof": "src/validator.js~Validator",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/validator.js~Validator.ensureIsError",
    "access": "public",
    "description": "Ensure that the given argument is an error instance or its subclass.\n\nSee {@link Validator.isError}.",
    "lineNumber": 751,
    "params": [
      {
        "nullable": true,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "arg",
        "description": "the object to check"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'arg'",
        "defaultRaw": "'arg'",
        "name": "name",
        "description": "the name to use in generated error (or the value of first argument if not given)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Error"
      ],
      "spread": false,
      "description": "if it's not an error or its subclass, nothing otherwise"
    }
  },
  {
    "__docId__": 167,
    "kind": "method",
    "name": "ensureIsVersion",
    "memberof": "src/validator.js~Validator",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/validator.js~Validator.ensureIsVersion",
    "access": "public",
    "description": "Ensure that the given argument is a string version.\n\nSee {@link Validator.isVersion}.",
    "lineNumber": 767,
    "params": [
      {
        "nullable": true,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "arg",
        "description": "the object to check"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'arg'",
        "defaultRaw": "'arg'",
        "name": "name",
        "description": "the name to use in generated error (or the value of first argument if not given)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Error"
      ],
      "spread": false,
      "description": "if it's not a string version, nothing otherwise"
    }
  },
  {
    "__docId__": 168,
    "kind": "method",
    "name": "ensureIsURI",
    "memberof": "src/validator.js~Validator",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/validator.js~Validator.ensureIsURI",
    "access": "public",
    "description": "Ensure that the given argument is an URI/URL.\n\nSee {@link Validator.isURI}.",
    "lineNumber": 784,
    "params": [
      {
        "nullable": true,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "arg",
        "description": "the object to check"
      },
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "base",
        "description": "the (optional) base to build the full URL"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'arg'",
        "defaultRaw": "'arg'",
        "name": "name",
        "description": "the name to use in generated error (or the value of first argument if not given)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Error"
      ],
      "spread": false,
      "description": "if it's not an URI/URL, nothing otherwise"
    }
  },
  {
    "__docId__": 169,
    "kind": "method",
    "name": "ensureObjectDoesNotContainStandardProperty",
    "memberof": "src/validator.js~Validator",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/validator.js~Validator.ensureObjectDoesNotContainStandardProperty",
    "access": "public",
    "description": "Ensure that the given object does not contain any property\nthat has a standard (reserved) property name.\n\nSee {@link Validator.doesObjectContainsStandardProperty}.",
    "lineNumber": 802,
    "params": [
      {
        "nullable": true,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "arg",
        "description": "the object to check"
      },
      {
        "nullable": true,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "isPropStandard",
        "description": "the function that tell the given argument (property), if it's standard"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'arg'",
        "defaultRaw": "'arg'",
        "name": "name",
        "description": "the name to use in generated error (or the value of first argument if not given)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Error"
      ],
      "spread": false,
      "description": "if at least one property with a standard name is found, nothing otherwise"
    }
  },
  {
    "__docId__": 170,
    "kind": "method",
    "name": "getSize",
    "memberof": "src/validator.js~Validator",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/validator.js~Validator.getSize",
    "access": "public",
    "description": "Tell the size of the given object",
    "lineNumber": 816,
    "params": [
      {
        "nullable": true,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "arg",
        "description": "the object to check"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the size if it's an array|Map|Set|object|string, nothing otherwise"
    },
    "throws": [
      {
        "types": [
          "TypeError"
        ],
        "description": "if it's not an array nor a collection nor object nor a string"
      }
    ]
  },
  {
    "__docId__": 171,
    "kind": "method",
    "name": "getSizeInBytes",
    "memberof": "src/validator.js~Validator",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/validator.js~Validator.getSizeInBytes",
    "access": "public",
    "description": "Tell the size in bytes of the given string.",
    "lineNumber": 841,
    "params": [
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "str",
        "description": "the string to check"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the size if it's a string, nothing otherwise"
    },
    "throws": [
      {
        "types": [
          "TypeError"
        ],
        "description": "if it's not a string"
      }
    ]
  },
  {
    "__docId__": 172,
    "kind": "method",
    "name": "getArgumentValue",
    "memberof": "src/validator.js~Validator",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/validator.js~Validator.getArgumentValue",
    "access": "public",
    "description": "Return the value of the variable given as argument.\n\nNote that this could have been written (in a shorter way)\nas an arrow function.",
    "lineNumber": 862,
    "params": [
      {
        "nullable": true,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "arg",
        "description": "the argument"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "the value of the variable (if defined and not null), nothing otherwise"
    }
  },
  {
    "__docId__": 173,
    "kind": "method",
    "name": "getArgumentName",
    "memberof": "src/validator.js~Validator",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/validator.js~Validator.getArgumentName",
    "access": "public",
    "description": "Return the name of the variable given as argument.\n\nTo use it, must be called using the trick to wrap argument\ninside an object literal, so for example use it inside a template string with:\n`${getArgumentName({x})}`\nwith nested objects (like with options with a property x inside)\nyou need to use with:\n`${getArgumentName({options})}.${getArgumentName({x})}`.\nNote that this could have been written (in a shorter way)\nas an arrow function.",
    "lineNumber": 886,
    "params": [
      {
        "nullable": true,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "arg",
        "description": "the argument"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "the name of the variable (if defined and not null), nothing otherwise"
    }
  },
  {
    "__docId__": 174,
    "kind": "method",
    "name": "getOrElse",
    "memberof": "src/validator.js~Validator",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/validator.js~Validator.getOrElse",
    "access": "public",
    "description": "Return the argument if it's defined and not null,\notherwise the given default value is returned.",
    "lineNumber": 903,
    "params": [
      {
        "nullable": true,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "arg",
        "description": "the argument to return"
      },
      {
        "nullable": true,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "def",
        "description": "the default value to return"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "the argument (if defined and not null), otherwise the default value"
    }
  },
  {
    "__docId__": 175,
    "kind": "method",
    "name": "getObjectFilteredProperties",
    "memberof": "src/validator.js~Validator",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/validator.js~Validator.getObjectFilteredProperties",
    "access": "public",
    "description": "Return a copy of the given ibject,\nwith all properties filtered by the given function (predicate).",
    "lineNumber": 921,
    "params": [
      {
        "nullable": true,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "obj",
        "description": "the base object"
      },
      {
        "nullable": true,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "propFilter",
        "description": "the function (predicate) for filtering properties"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "a new object containing only filtered properties"
    },
    "throws": [
      {
        "types": [
          "TypeError"
        ],
        "description": "if obj is not a plain object, or propFilter is not a function"
      }
    ]
  },
  {
    "__docId__": 176,
    "kind": "method",
    "name": "throwOnError",
    "memberof": "src/validator.js~Validator",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/validator.js~Validator.throwOnError",
    "access": "public",
    "description": "Throw if the given argument is an error instance or its subclass.\n\nSee {@link Validator.isError}.",
    "lineNumber": 942,
    "params": [
      {
        "nullable": true,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "arg",
        "description": "the object to check"
      }
    ],
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "the given error"
      }
    ],
    "return": null
  },
  {
    "__docId__": 177,
    "kind": "method",
    "name": "throwOnFalse",
    "memberof": "src/validator.js~Validator",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/validator.js~Validator.throwOnFalse",
    "access": "public",
    "description": "Throw if the given argument is false.\nNote that this is similar to assertions.\n\nSee {@link Validator.isError}.",
    "lineNumber": 959,
    "params": [
      {
        "nullable": true,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "arg",
        "description": "the object to check"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'arg'",
        "defaultRaw": "'arg'",
        "name": "name",
        "description": "the name to use in generated error (or the value of first argument if not given)"
      }
    ],
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "if the given argument is not a boolean, or if it's false"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "kind": "index",
    "content": "# cloudevent / cloudevent.js\n\n  [![NPM Version](https://img.shields.io/npm/v/cloudevent.svg?style=flat)](https://npmjs.org/package/cloudevent/)\n  [![NPM Downloads](https://img.shields.io/npm/dm/cloudevent.svg?style=flat)](https://npmjs.org/package/cloudevent/)\n  [![Code Style](https://img.shields.io/badge/code%20style-standard-brightgreen.svg?style=flat)](http://standardjs.com/)\n  [![Coverage Status](https://coveralls.io/repos/github/smartiniOnGitHub/cloudevent.js/badge.svg?branch=master)](https://coveralls.io/github/smartiniOnGitHub/cloudevent.js/?branch=master)\n  [![dependencies Status](https://david-dm.org/smartiniOnGitHub/cloudevent.js/status.svg)](https://david-dm.org/smartiniOnGitHub/cloudevent.js)\n  [![devDependencies Status](https://david-dm.org/smartiniOnGitHub/cloudevent.js/dev-status.svg)](https://david-dm.org/smartiniOnGitHub/cloudevent.js?type=dev)\n  [![Known Vulnerabilities](https://snyk.io//test/github/smartiniOnGitHub/cloudevent.js/badge.svg?targetFile=package.json)](https://snyk.io//test/github/smartiniOnGitHub/cloudevent.js?targetFile=package.json)\n  [![license - APACHE-2.0](https://img.shields.io/npm/l/cloudevent.svg)](http://opensource.org/licenses/APACHE-2.0)\n\nJavaScript/Node.js implementation of [CloudEvents](http://cloudevents.io/)\n\nCurrent release implements the v0.3 of the CloudEvents Spec.\n\nThe purpose of this library is to create instances of CloudEvents in a simple way \n(with some useful defaults), or in a full way (all attributes).\nOptional, it's possible to validate created instances to be sure they are compliant with the standard.\n\nThen, created instances can be serialized, for example to be sent (or saved/stored) somewhere.\n\nNote that many features are exposed directly by the CloudEvent class with standard class instance \nmethods, and even as class static methods (that operates on a given CloudEvent).\nAnyway, to be more future-proof the library now exports a main object, with all features inside \n(the class for CloudEvent, its Validator class as CloudEventValidator, etc); \nusing destructuring assignment (as seen in code samples) usage will be easier.\n\n\n## Usage\n\nGet a reference to the library:\n\n```js\n// Node.js example\n\n// reference the library, not needed if using destructuring assignment, see below\nconst CloudEventExports = require('cloudevent')\n\n// minimal, most common usage\n// const { CloudEvent } = require('cloudevent')\n// other, get more objects exposed by the library\nconst { CloudEvent, CloudEventValidator: V, CloudEventTransformer: T } = require('cloudevent')\nassert(CloudEvent !== null && V !== null && T !== null)\n```\n\ncreate some sample CloudEvent instances:\n\n```js\n// create some sample instances but without mandatory fields (for validation) ...\nconst ceEmpty = new CloudEvent() // create an empty CloudEvent instance (not valid for the validator, even in default case, when strict mode flag is disabled)\nconst ceMinimalMandatoryUndefinedNoStrict = new CloudEvent(undefined, undefined, undefined, undefined, { strict: false }) // expected success\nconst ceMinimalMandatoryUndefinedStrict = new CloudEvent(undefined, undefined, undefined, undefined, { strict: true }) // expected failure, so ceMinimalMandatoryUndefinedStrict will not be defined\n\n// define some common attributes\nconst ceCommonOptions = {\n  time: new Date(),\n  datacontenttype: 'application/json',\n  schemaurl: 'http://my-schema.localhost.localdomain/v1/',\n  subject: 'subject',\n  strict: false // same as default\n}\nconst ceCommonOptionsStrict = { ...ceCommonOptions, strict: true }\nconst ceCommonExtensions = { exampleExtension: 'value' }\nconst ceNamespace = 'com.github.smartiniOnGitHub.cloudeventjs.testevent-v1.0.0'\nconst ceServerUrl = '/test'\nconst ceCommonData = { hello: 'world', year: 2019 }\n\n// create some sample minimal instances, good even for validation ...\nconst ceMinimal = new CloudEvent('1', // id\n  ceNamespace, // type\n  '/', // source\n  {} // data (empty) // optional, but useful the same in this sample usage\n)\n\n// create some instances with an undefined mandatory argument (handled by defaults), but with strict flag disabled: expected success ...\n// note that null values are not handled by default values, only undefined values ...\nconst ceFull = new CloudEvent('1/full',\n  ceNamespace,\n  ceServerUrl,\n  ceCommonData, // data\n  ceCommonOptions,\n  ceCommonExtensions\n)\nconst ceFullStrict = new CloudEvent('2/full-strict',\n  ceNamespace,\n  ceServerUrl,\n  ceCommonData, // data\n  ceCommonOptionsStrict, // use common options, but set strict mode to true\n  ceCommonExtensions\n)\nassert(ceFullStrict.isStrict)\nassert(!ceFull.isStrict) // ensure common options object has not been changed when reusing some of its values for the second instance\nassert(!CloudEvent.isStrictEvent(ceFull)) // the same, but using static method\n// create an instance that wrap an Error\nconst error = new Error('sample error')\nerror.code = 1000 // add a sample error code, as number\nconst errorToData = T.errorToData(error, {\n  includeStackTrace: true,\n  // addStatus: false,\n  addTimestamp: true\n})\nconst ceErrorStrict = new CloudEvent('2/error-strict',\n  ceNamespace,\n  ceServerUrl,\n  errorToData, // data\n  ceCommonOptionsStrict, // use common options, but set strict mode to true\n  ceCommonExtensions\n)\nassert(ceErrorStrict !== null)\nassert(ceErrorStrict.isStrict)\nassert(!ceErrorStrict.isStrict) // ensure common options object has not been changed when reusing some of its values for the second instance\nassert(!CloudEvent.isStrictEvent(ceErrorStrict)) // the same, but using static method\n// create an instance with a different content type\nconst ceFullStrictOtherContentType = new CloudEvent('3/full-strict-other-content-type',\n  ceNamespace,\n  ceServerUrl,\n  ceCommonData, // data\n  { ...ceCommonOptionsStrict, datacontenttype: 'application/xml' }, // use common strict options, but set strict mode to true\n  ceCommonExtensions\n)\nassert(ceFullStrictOtherContentType !== null)\nassert(ceFullStrictOtherContentType.isStrict)\n```\n\noptional, do some validations/checks on created instances.\nAs sample, use class static methods like 'isValidEvent' and 'ValidateEvent', \nor instance methods like 'isValid', 'validate', etc ...\n\n```js\nassert(!ceEmpty.isValid())\nassert(!ceMinimalMandatoryUndefinedNoStrict.isValid())\nassert(ceMinimal.isValid())\nassert(ceFull.isValid())\nassert(ceFullStrict.isValid())\nassert(ceErrorStrict.isValid())\nassert(ceFullStrictOtherContentType.isValid())\n// etc ...\n\nconsole.log(`Validation on ceEmpty: isValid: ${ceEmpty.isValid()}`)\n\nconsole.log(`Validation output for ceEmpty, default strict mode is: size: ${CloudEvent.validateEvent(ceEmpty).length}, details:\\n` + CloudEvent.validateEvent(ceEmpty))\nconsole.log(`Validation output for ceEmpty, force strict mode to true is size: ${CloudEvent.validateEvent(ceEmpty, { strict: true }).length}, details:\\n` + CloudEvent.validateEvent(ceEmpty, { strict: true }))\n```\n\nserialization examples:\n\n```js\n// default contenttype\nconst ceFullSerializedStatic = CloudEvent.serializeEvent(ceFull)\nconst ceFullSerialized = ceFull.serialize()\nconsole.log('Serialization output for ceFull, details:\\n' + ceFullSerialized)\nconst ceFullStrictSerialized = ceFullStrict.serialize()\nconsole.log('Serialization output for ceFullStrict, details:\\n' + ceFullStrictSerialized)\n// non default contenttype\nconst ceFullStrictOtherContentTypeSerializedStatic = CloudEvent.serializeEvent(ceFullStrictOtherContentType, {\n  // encoder: (data) => '<data \"encoder\"=\"sample\" />',\n  encodedData: '<data \"hello\"=\"world\" \"year\"=\"2019\" />',\n  onlyValid: true\n})\nconst ceFullStrictOtherContentTypeSerialized = ceFullStrictOtherContentType.serialize({\n  // encoder: (data) => '<data \"encoder\"=\"sample\" />',\n  encodedData: '<data \"hello\"=\"world\" \"year\"=\"2019\" />',\n  onlyValid: true\n})\nconsole.log('Serialization output for ceFullStrictOtherContentType, details:\\n' + ceFullStrictOtherContentTypeSerialized)\n\n// then use (send/store/etc) serialized instances ...\n\n```\n\ndeserialization (parse) examples:\n\n```js\n// deserialization examples\n// default contenttype\nconsole.log('\\nSome deserialization/parse examples:')\nconst ceFullDeserialized = CloudEvent.deserializeEvent(ceFullSerialized)\nassert(ceFullDeserialized !== null)\nassert(ceFullDeserialized.isValid())\nassert(!ceFullDeserialized.isStrict)\nassert(CloudEvent.isCloudEvent(ceFullDeserialized))\nconsole.log(`cloudEvent dump: ${T.dumpObject(ceFullDeserialized, 'ceFullDeserialized')}`)\nconst ceFullStrictDeserializedOnlyValid = CloudEvent.deserializeEvent(ceFullStrictSerialized, { onlyValid: true })\nassert(ceFullStrictDeserializedOnlyValid !== null)\nconsole.log(`cloudEvent dump: ${T.dumpObject(ceFullStrictDeserializedOnlyValid, 'ceFullStrictDeserializedOnlyValid')}`)\n// non default contenttype\nconst ceFullStrictOtherContentTypeDeserialized = CloudEvent.deserializeEvent(ceFullStrictOtherContentTypeSerialized, {\n  // decoder: (data) => { decoder: 'Sample' },\n  decodedData: { hello: 'world', year: 2019 },\n  onlyValid: true\n})\nassert(ceFullStrictOtherContentTypeDeserialized !== null)\nassert(ceFullStrictOtherContentTypeDeserialized.isValid())\nassert(ceFullStrictOtherContentTypeDeserialized.isStrict)\nassert(CloudEvent.isCloudEvent(ceFullStrictOtherContentTypeDeserialized))\nconsole.log(`cloudEvent dump: ${T.dumpObject(ceFullStrictOtherContentTypeDeserialized, 'ceFullStrictOtherContentTypeDeserialized')}`)\n\n// then use (validate/send/store/etc) deserialized instances ...\n\n```\n\nLook into the [example](./example/) folder for more sample scripts that uses the library \n(inline but it's the same using it from npm registry); \nyou can find even examples for using JSONBatch objects (array of CloudEvent instances).\n\n\n## Requirements\n\nNode.js 8.16.x or later.\n\n\n## Note\n\nNote that in this implementation there is even the ability to validate CloudEvent instances \nin a stricter way, by setting to true the attribute 'strict' in options in constructor options; \nor specify it during validation.\nThat attribute when set will be put in the 'extensions' standard attribute of a CloudEvent.\n\nYou can find Code Documentation for the API of the library [here](https://smartiniongithub.github.io/cloudevent.js/).\n\nSee the CloudEvents Specification [here](https://github.com/cloudevents/spec).\n\nIn the past the name for this package was 'cloudevent.js', but it has been deprecated now \nand changed to the simpler 'cloudevent', so it will be easier to get it at npm.\n\nSince v0.2 of the spec, there is no more a standard attribute to specify the version \nof any specific event type, so the best if to follow their recommendations, \nand for example add a version in the 'type' attribute \n(for example '-v1.0.0' at the end of its base value, or at the end of its full value) ,\nor into the 'schemaurl' attribute but only its major version \n(like '-v1' or '/v1/' at the end).\nSince v0.3 of the spec, there is no more a standard attribute for extensions, \nso they are merged into usual properties (but must not use names \nof standard properties); a best practice is to use reverse-DNS name \nbut without dots, so like 'com_github_smartiniOnGitHub_cloudevent'.\n\n\n## Contributing\n\n1. Fork it ( https://github.com/smartiniOnGitHub/cloudevent.js/fork )\n2. Create your feature branch (git checkout -b my-new-feature)\n3. Commit your changes (git commit -am 'Add some feature')\n4. Push to the branch (git push origin my-new-feature)\n5. Create a new Pull Request\n\n\n## License\n\nLicensed under [Apache-2.0](./LICENSE).\n\n----\n",
    "longname": "/Users/martinis/work/prove/cloudevent.js/README.md",
    "name": "./README.md",
    "static": true,
    "access": "public"
  },
  {
    "kind": "packageJSON",
    "content": "{\n  \"name\": \"cloudevent\",\n  \"version\": \"0.6.0\",\n  \"description\": \"JavaScript/Node.js implementation of the CloudEvents standard format\",\n  \"main\": \"src/index\",\n  \"scripts\": {\n    \"dependency:log\": \"npm list > ./temp/dependencies.log\",\n    \"docs\": \"npx esdoc\",\n    \"example\": \"node example/nodejs-base\",\n    \"example:debug\": \"node --inspect-brk example/nodejs-base\",\n    \"lint\": \"standard \\\"./src/**/*.js\\\" \\\"./test/**/*.test.js\\\" \\\"./example/**/*.js\\\"\",\n    \"lint:log\": \"npm run lint > ./temp/lint-standard.log\",\n    \"license-check\": \"npx legally\",\n    \"license-check:log\": \"npx legally > ./temp/license-check.log\",\n    \"license-checker\": \"npx license-checker --production --onlyAllow='Apache-2.0;BSD-2-Clause;BSD-3-Clause;MIT;ISC'\",\n    \"license-checker:log\": \"npm run license-checker | tee ./temp/license-checker.log\",\n    \"test:coverage\": \"npm run test:unit -- --cov --coverage-report=html\",\n    \"test:unit\": \"tap -J --comments --no-esm --strict test/*.test.js\",\n    \"test:unit:dev\": \"tap -J --comments --no-esm --strict --watch test/*.test.js\",\n    \"test:unit:debug\": \"tap -T --node-arg=--inspect-brk --comments --no-esm --strict test/*.test.js\",\n    \"test\": \"npm run lint && npm run test:unit\"\n  },\n  \"dependencies\": {},\n  \"devDependencies\": {\n    \"esdoc\": \"^1.1.0\",\n    \"esdoc-standard-plugin\": \"^1.0.0\",\n    \"esdoc-ecmascript-proposal-plugin\": \"^1.0.0\",\n    \"esdoc-node\": \"^1.0.5\",\n    \"standard\": \"^14.3.1\",\n    \"tap\": \"^14.8.2\"\n  },\n  \"peerDependencies\": {},\n  \"engines\": {\n    \"node\": \">=8.16.2\"\n  },\n  \"homepage\": \"https://github.com/smartiniOnGitHub/cloudevent.js#readme\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/smartiniOnGitHub/cloudevent.js.git\"\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/smartiniOnGitHub/cloudevent.js/issues\"\n  },\n  \"keywords\": [\n    \"library\",\n    \"cloudevents\"\n  ],\n  \"author\": \"Sandro Martini <sandro.martini@gmail.com>\",\n  \"license\": \"Apache-2.0\"\n}\n",
    "longname": "/Users/martinis/work/prove/cloudevent.js/package.json",
    "name": "package.json",
    "static": true,
    "access": "public"
  },
  {
    "__docId__": 178,
    "kind": "testFile",
    "name": "test/cloudevent-serialization.test.js",
    "content": "/*\r\n * Copyright 2018 the original author or authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n'use strict'\r\n\r\nconst assert = require('assert').strict\r\nconst test = require('tap').test\r\n\r\n/** @test {CloudEvent} */\r\ntest('ensure serialization functions exists (check only the static method here)', (t) => {\r\n  t.plan(9)\r\n\r\n  {\r\n    const { CloudEvent } = require('../src/') // get references via destructuring\r\n    t.ok(CloudEvent)\r\n    // optional, using some standard Node.js assert statements, as a sample\r\n    assert(CloudEvent !== null)\r\n    assert.strictEqual(typeof CloudEvent, 'function')\r\n    assert(new CloudEvent() instanceof CloudEvent)\r\n    assert.strictEqual(CloudEvent.mediaType(), 'application/cloudevents+json')\r\n    t.ok(CloudEvent)\r\n    t.strictEqual(typeof CloudEvent, 'function')\r\n    t.strictEqual(new CloudEvent() instanceof CloudEvent, true)\r\n    t.strictEqual(CloudEvent.mediaType(), 'application/cloudevents+json')\r\n\r\n    const ceSerialize = CloudEvent.serializeEvent\r\n    assert(ceSerialize !== null)\r\n    assert(typeof ceSerialize === 'function')\r\n    t.ok(ceSerialize)\r\n    t.strictEqual(typeof ceSerialize, 'function')\r\n\r\n    const ceDeserialize = CloudEvent.deserializeEvent\r\n    assert(ceDeserialize !== null)\r\n    assert(typeof ceDeserialize === 'function')\r\n    t.ok(ceDeserialize)\r\n    t.strictEqual(typeof ceDeserialize, 'function')\r\n  }\r\n})\r\n\r\n// import some common test data\r\nconst {\r\n  commonEventTime,\r\n  ceCommonOptions,\r\n  ceCommonOptionsStrict,\r\n  ceCommonExtensions,\r\n  ceNamespace,\r\n  ceServerUrl,\r\n  ceCommonData\r\n} = require('./common-test-data')\r\n\r\n/** sample data as an xml string */\r\nconst ceDataAsXmlString = '<data \"hello\"=\"world\" \"year\"=\"2019\" />'\r\n/** sample data as a json string */\r\nconst ceDataAsJSONString = JSON.stringify(ceCommonData)\r\n/** create a sample string big (more than 64 KB) */\r\nconst ceBigStringLength = 100000\r\nconst ceBigString = getRandomString(ceBigStringLength) // a random string with n chars\r\n\r\n// sample function to calculate a random string, given the length, to use in tests here\r\nfunction getRandomString (length) {\r\n  let str = Math.random().toString(36).substr(2)\r\n  while (str.length < length) {\r\n    str += Math.random().toString(36).substr(2)\r\n  }\r\n  return str.substr(0, length)\r\n}\r\n\r\n/** @test {CloudEvent} */\r\ntest('serialize some CloudEvent instances to JSON, and ensure they are right', (t) => {\r\n  t.plan(60)\r\n\r\n  const { CloudEvent, CloudEventTransformer: T } = require('../src/')\r\n  // t.ok(CloudEvent)\r\n\r\n  {\r\n    // create an instance with undefined data attribute, but with strict flag disabled: expected success ...\r\n    // note that null values are not handled by default values, only undefined values ...\r\n    const ceFull = new CloudEvent('1/full/sample-data/no-strict',\r\n      ceNamespace,\r\n      ceServerUrl,\r\n      ceCommonData, // data\r\n      ceCommonOptions,\r\n      ceCommonExtensions\r\n    )\r\n    assert(ceFull !== null)\r\n    t.ok(ceFull)\r\n    t.ok(ceFull.isValid())\r\n    t.ok(ceFull.validate().length === 0)\r\n    t.ok(ceFull.validate({ strict: false }).length === 0)\r\n    t.ok(ceFull.validate({ strict: true }).length === 0)\r\n    t.ok(CloudEvent.isValidEvent(ceFull))\r\n    t.ok(CloudEvent.validateEvent(ceFull).length === 0)\r\n    t.ok(CloudEvent.validateEvent(ceFull, { strict: false }).length === 0)\r\n    t.ok(CloudEvent.validateEvent(ceFull, { strict: true }).length === 0)\r\n    t.strictEqual(ceFull.datacontenttype, CloudEvent.datacontenttypeDefault())\r\n    t.ok(CloudEvent.isDatacontenttypeJSONEvent(ceFull))\r\n\r\n    t.throws(function () {\r\n      const ceFullSerialized = CloudEvent.serializeEvent(undefined)\r\n      assert(ceFullSerialized === null) // never executed\r\n    }, Error, 'Expected exception when serializing an undefined / null CloudEvent instance')\r\n    t.throws(function () {\r\n      const ceFullSerialized = CloudEvent.serializeEvent(null)\r\n      assert(ceFullSerialized === null) // never executed\r\n    }, Error, 'Expected exception when serializing an undefined / null CloudEvent instance')\r\n\r\n    const ceFullSerializedStatic = CloudEvent.serializeEvent(ceFull)\r\n    t.ok(ceFullSerializedStatic)\r\n    const ceFullSerialized = ceFull.serialize()\r\n    t.ok(ceFullSerialized)\r\n    assert(ceFullSerializedStatic === ceFullSerialized)\r\n    t.strictSame(ceFullSerializedStatic, ceFullSerialized)\r\n    const ceSerialize = CloudEvent.serializeEvent\r\n    assert(ceSerialize !== null)\r\n    t.ok(ceSerialize)\r\n    const ceFullSerializedFunction = ceSerialize(ceFull)\r\n    t.ok(ceFullSerializedFunction)\r\n    t.strictSame(ceFullSerializedFunction, ceFullSerializedStatic)\r\n    t.strictSame(ceFullSerializedFunction, ceFullSerialized)\r\n\r\n    const ceFullSerializedComparison = `{\"id\":\"1/full/sample-data/no-strict\",\"type\":\"com.github.smartiniOnGitHub.cloudeventjs.testevent\",\"source\":\"/test\",\"data\":{\"hello\":\"world\",\"year\":2019},\"specversion\":\"0.3\",\"datacontenttype\":\"application/json\",\"time\":\"${T.timestampToString(commonEventTime)}\",\"schemaurl\":\"http://my-schema.localhost.localdomain\",\"subject\":\"subject\",\"exampleExtension\":\"value\"}`\r\n    t.strictSame(ceFullSerialized, ceFullSerializedComparison)\r\n    const ceFullDeserialized = JSON.parse(ceFullSerialized) // note that some fields (like dates) will be different when deserialized in this way ...\r\n    ceFullDeserialized.time = commonEventTime // quick fix for the Date/timestamp attribute in the deserialized object\r\n    ceFullDeserialized.datacontentencoding = undefined // quick fix for this not so common attribute in the deserialized object\r\n    t.same(ceFull, ceFullDeserialized)\r\n\r\n    const ceFullSerializedOnlyValidFalse = ceSerialize(ceFull, { onlyValid: false })\r\n    t.ok(ceFullSerializedOnlyValidFalse)\r\n    const ceFullSerializedOnlyValidTrue = ceSerialize(ceFull, { onlyValid: true })\r\n    t.ok(ceFullSerializedOnlyValidTrue)\r\n\r\n    {\r\n      const ceFullBad = new CloudEvent(null,\r\n        ceNamespace,\r\n        ceServerUrl,\r\n        ceCommonData, // data\r\n        ceCommonOptions,\r\n        ceCommonExtensions\r\n      )\r\n      assert(ceFullBad !== null)\r\n      t.ok(ceFullBad)\r\n      t.ok(!ceFullBad.isValid())\r\n      const ceFullBadSerializedOnlyValidFalse = ceSerialize(ceFullBad, { onlyValid: false })\r\n      t.ok(ceFullBadSerializedOnlyValidFalse)\r\n      t.throws(function () {\r\n        const ceFullBadSerializedOnlyValidTrue = ceSerialize(ceFullBad, { onlyValid: true })\r\n        assert(ceFullBadSerializedOnlyValidTrue === null) // never executed\r\n      }, Error, 'Expected exception when serializing a bad CloudEvent instance')\r\n    }\r\n\r\n    // test to ensure that old style extensions are not serialized\r\n    const ceFullSerializedStaticWithoutExtensionsProperty = CloudEvent.serializeEvent({ ...ceFull, extensions: { exampleExtensionToSkip: 'valueToSkip' } })\r\n    t.ok(ceFullSerializedStaticWithoutExtensionsProperty)\r\n    t.strictSame(ceFullSerializedStaticWithoutExtensionsProperty.search('exampleExtensionToSkip'), -1)\r\n  }\r\n\r\n  {\r\n    // the same but with strict mode enabled ...\r\n    const ceFullStrict = new CloudEvent('1/full/sample-data/strict',\r\n      ceNamespace,\r\n      ceServerUrl,\r\n      ceCommonData, // data\r\n      ceCommonOptionsStrict,\r\n      ceCommonExtensions\r\n    )\r\n    assert(ceFullStrict !== null)\r\n    t.ok(ceFullStrict)\r\n    t.ok(ceFullStrict.isValid())\r\n    t.ok(ceFullStrict.validate().length === 0)\r\n    t.ok(ceFullStrict.validate({ strict: true }).length === 0)\r\n    t.ok(ceFullStrict.validate({ strict: false }).length === 0)\r\n    t.ok(CloudEvent.isValidEvent(ceFullStrict))\r\n    t.ok(CloudEvent.validateEvent(ceFullStrict).length === 0)\r\n    t.ok(CloudEvent.validateEvent(ceFullStrict, { strict: true }).length === 0)\r\n    t.ok(CloudEvent.validateEvent(ceFullStrict, { strict: false }).length === 0)\r\n    t.strictEqual(ceFullStrict.datacontenttype, CloudEvent.datacontenttypeDefault())\r\n    t.ok(CloudEvent.isDatacontenttypeJSONEvent(ceFullStrict))\r\n\r\n    t.throws(function () {\r\n      const ceFullSerialized = CloudEvent.serializeEvent(undefined)\r\n      assert(ceFullSerialized === null) // never executed\r\n    }, Error, 'Expected exception when serializing an undefined / null CloudEvent instance')\r\n    t.throws(function () {\r\n      const ceFullSerialized = CloudEvent.serializeEvent(null)\r\n      assert(ceFullSerialized === null) // never executed\r\n    }, Error, 'Expected exception when serializing an undefined / null CloudEvent instance')\r\n\r\n    const ceFullStrictSerializedStatic = CloudEvent.serializeEvent(ceFullStrict)\r\n    t.ok(ceFullStrictSerializedStatic)\r\n    const ceFullStrictSerialized = ceFullStrict.serialize()\r\n    t.ok(ceFullStrictSerialized)\r\n    assert(ceFullStrictSerializedStatic === ceFullStrictSerialized)\r\n    t.strictSame(ceFullStrictSerializedStatic, ceFullStrictSerialized)\r\n    const ceSerialize = CloudEvent.serializeEvent\r\n    assert(ceSerialize !== null)\r\n    t.ok(ceSerialize)\r\n    const ceFullStrictSerializedFunction = ceSerialize(ceFullStrict)\r\n    t.ok(ceFullStrictSerializedFunction)\r\n    t.strictSame(ceFullStrictSerializedFunction, ceFullStrictSerializedStatic)\r\n    t.strictSame(ceFullStrictSerializedFunction, ceFullStrictSerialized)\r\n\r\n    const ceFullStrictSerializedComparison = `{\"id\":\"1/full/sample-data/strict\",\"type\":\"com.github.smartiniOnGitHub.cloudeventjs.testevent\",\"source\":\"/test\",\"data\":{\"hello\":\"world\",\"year\":2019},\"specversion\":\"0.3\",\"datacontenttype\":\"application/json\",\"time\":\"${T.timestampToString(commonEventTime)}\",\"schemaurl\":\"http://my-schema.localhost.localdomain\",\"subject\":\"subject\",\"com_github_smartiniOnGitHub_cloudevent\":{\"strict\":true},\"exampleExtension\":\"value\"}`\r\n    t.strictSame(ceFullStrictSerialized, ceFullStrictSerializedComparison)\r\n    const ceFullStrictDeserialized = JSON.parse(ceFullStrictSerialized) // note that some fields (like dates) will be different when deserialized in this way ...\r\n    ceFullStrictDeserialized.time = commonEventTime // quick fix for the Date/timestamp attribute in the deserialized object\r\n    ceFullStrictDeserialized.datacontentencoding = undefined // quick fix for this not so common attribute in the deserialized object\r\n    t.same(ceFullStrict, ceFullStrictDeserialized)\r\n\r\n    const ceFullStrictSerializedOnlyValidFalse = ceSerialize(ceFullStrict, { onlyValid: false })\r\n    t.ok(ceFullStrictSerializedOnlyValidFalse)\r\n    const ceFullStrictSerializedOnlyValidTrue = ceSerialize(ceFullStrict, { onlyValid: true })\r\n    t.ok(ceFullStrictSerializedOnlyValidTrue)\r\n\r\n    {\r\n      const ceFullStrictBad = new CloudEvent('1/full/sample-data/strict',\r\n        ceNamespace,\r\n        ceServerUrl,\r\n        ceCommonData, // data\r\n        ceCommonOptionsStrict,\r\n        ceCommonExtensions\r\n      )\r\n      assert(ceFullStrictBad !== null)\r\n      t.ok(ceFullStrictBad)\r\n      ceFullStrictBad.id = null // remove some mandatory attribute now, to let serialization fail\r\n      t.ok(!ceFullStrictBad.isValid())\r\n      const ceFullStrictBadSerializedOnlyValidFalse = ceSerialize(ceFullStrictBad, { onlyValid: false })\r\n      t.ok(ceFullStrictBadSerializedOnlyValidFalse)\r\n      t.throws(function () {\r\n        const ceFullStrictBadSerializedOnlyValidTrue = ceSerialize(ceFullStrictBad, { onlyValid: true })\r\n        assert(ceFullStrictBadSerializedOnlyValidTrue === null) // never executed\r\n      }, Error, 'Expected exception when serializing a bad CloudEvent instance')\r\n    }\r\n\r\n    // test to ensure that old style extensions are not serialized\r\n    const ceFullStrictSerializedStaticWithoutExtensionsProperty = CloudEvent.serializeEvent({ ...ceFullStrict, extensions: { exampleExtensionToSkip: 'valueToSkip' } })\r\n    t.ok(ceFullStrictSerializedStaticWithoutExtensionsProperty)\r\n    t.strictSame(ceFullStrictSerializedStaticWithoutExtensionsProperty.search('exampleExtensionToSkip'), -1)\r\n  }\r\n})\r\n\r\n/** @test {CloudEvent} */\r\ntest('serialize a CloudEvent instance with a non default contenttype and empty serialization options, expect error', (t) => {\r\n  t.plan(34)\r\n\r\n  const { CloudEvent } = require('../src/')\r\n  t.ok(CloudEvent)\r\n\r\n  {\r\n    // create an instance with non default contenttype (other options default): expected success ...\r\n    // when I try to serialize it without specifying serialization options, expect to have an error raised ...\r\n    const ceFullOtherContentType = new CloudEvent('1/non-default-contenttype/sample-data/no-strict',\r\n      ceNamespace,\r\n      ceServerUrl,\r\n      ceCommonData, // data\r\n      {\r\n        ...ceCommonOptions,\r\n        datacontenttype: 'application/xml'\r\n      },\r\n      ceCommonExtensions\r\n    )\r\n    assert(ceFullOtherContentType !== null)\r\n    t.ok(ceFullOtherContentType)\r\n    t.ok(ceFullOtherContentType.isValid())\r\n    t.ok(!ceFullOtherContentType.isStrict)\r\n    t.throws(function () {\r\n      const ceFullOtherContentTypeSerialized = ceFullOtherContentType.serialize()\r\n      assert(ceFullOtherContentTypeSerialized === null) // never executed\r\n    }, Error, 'Expected exception when serializing the current CloudEvent instance')\r\n    t.throws(function () {\r\n      const ceFullOtherContentTypeSerialized = CloudEvent.serializeEvent(ceFullOtherContentType, {\r\n        encoder: 'encoderToXmlSample'\r\n      })\r\n      assert(ceFullOtherContentTypeSerialized === null) // never executed\r\n    }, Error, 'Expected exception when serializing the current CloudEvent instance')\r\n    t.throws(function () {\r\n      const ceFullOtherContentTypeSerialized = CloudEvent.serializeEvent(ceFullOtherContentType, {\r\n        encodedData: true\r\n      })\r\n      assert(ceFullOtherContentTypeSerialized === null) // never executed\r\n    }, Error, 'Expected exception when serializing the current CloudEvent instance')\r\n    t.throws(function () {\r\n      const flag = CloudEvent.isStrictEvent(undefined)\r\n      assert(flag === false) // never executed\r\n    }, Error, 'Expected exception when trying to get the strict mode for an undefined/null CloudEvent instance')\r\n    t.throws(function () {\r\n      const flag = CloudEvent.isStrictEvent(null)\r\n      assert(flag === false) // never executed\r\n    }, Error, 'Expected exception when trying to get the strict mode for an undefined/null CloudEvent instance')\r\n    t.throws(function () {\r\n      const flag = CloudEvent.isStrictEvent({})\r\n      assert(flag === false) // never executed\r\n    }, Error, 'Expected exception when trying to get the strict mode for for not a CloudEvent instance')\r\n\r\n    {\r\n      const ce = ceFullOtherContentType\r\n      CloudEvent.setStrictExtensionInEvent(ce, false)\r\n      const flag = CloudEvent.isStrictEvent(ce)\r\n      t.strictSame(flag, false)\r\n    }\r\n    {\r\n      const ce = ceFullOtherContentType\r\n      CloudEvent.setStrictExtensionInEvent(ce, true)\r\n      const flag = CloudEvent.isStrictEvent(ce)\r\n      t.strictSame(flag, true)\r\n    }\r\n\r\n    {\r\n      const ceFullOtherContentTypeBad = new CloudEvent(null,\r\n        ceNamespace,\r\n        ceServerUrl,\r\n        ceCommonData, // data\r\n        {\r\n          ...ceCommonOptions,\r\n          datacontenttype: 'application/xml'\r\n        },\r\n        ceCommonExtensions\r\n      )\r\n      assert(ceFullOtherContentTypeBad !== null)\r\n      t.ok(ceFullOtherContentTypeBad)\r\n      t.ok(!ceFullOtherContentTypeBad.isValid())\r\n      const ceFullBadSerializedOnlyValidFalse = CloudEvent.serializeEvent(ceFullOtherContentTypeBad, {\r\n        encodedData: ceDataAsXmlString,\r\n        onlyValid: false\r\n      })\r\n      t.ok(ceFullBadSerializedOnlyValidFalse)\r\n      t.throws(function () {\r\n        const ceFullBadSerializedOnlyValidTrue = CloudEvent.serializeEvent(ceFullOtherContentTypeBad, {\r\n          encodedData: ceDataAsXmlString,\r\n          onlyValid: true\r\n        })\r\n        assert(ceFullBadSerializedOnlyValidTrue === null) // never executed\r\n      }, Error, 'Expected exception when serializing a bad CloudEvent instance')\r\n    }\r\n  }\r\n\r\n  {\r\n    // the same but with strict mode enabled ...\r\n    // expect success even if content type is not default and data is not a string,\r\n    // anyway use encoder/decoder to let serialization/deserialization work in this case (strict) ...\r\n    const ceFullOtherContentTypeStrict = new CloudEvent('1/non-default-contenttype/sample-data/strict',\r\n      ceNamespace,\r\n      ceServerUrl,\r\n      ceCommonData, // data\r\n      {\r\n        ...ceCommonOptionsStrict,\r\n        datacontenttype: 'application/xml'\r\n      },\r\n      ceCommonExtensions\r\n    )\r\n    assert(ceFullOtherContentTypeStrict !== null)\r\n    t.ok(ceFullOtherContentTypeStrict)\r\n    t.ok(ceFullOtherContentTypeStrict.isValid())\r\n    t.ok(ceFullOtherContentTypeStrict.isStrict)\r\n    t.throws(function () {\r\n      const ceFullOtherContentTypeStrictSerialized = ceFullOtherContentTypeStrict.serialize()\r\n      assert(ceFullOtherContentTypeStrictSerialized === null) // never executed\r\n    }, Error, 'Expected exception when serializing the current CloudEvent instance')\r\n    t.throws(function () {\r\n      const ceFullOtherContentTypeStrictSerialized = ceFullOtherContentTypeStrict.serialize({\r\n        encoder: null,\r\n        encodedData: null\r\n      })\r\n      assert(ceFullOtherContentTypeStrictSerialized === null) // never executed\r\n    }, Error, 'Expected exception when serializing the current CloudEvent instance')\r\n    t.throws(function () {\r\n      const ceFullOtherContentTypeStrictSerialized = CloudEvent.serializeEvent(ceFullOtherContentTypeStrict, { onlyValid: true })\r\n      assert(ceFullOtherContentTypeStrictSerialized === null) // never executed\r\n    }, Error, 'Expected exception when serializing the current CloudEvent instance')\r\n    t.throws(function () {\r\n      const ceFullOtherContentTypeStrictSerialized = CloudEvent.serializeEvent(ceFullOtherContentTypeStrict, {\r\n        encoder: null,\r\n        encodedData: null,\r\n        onlyValid: true\r\n      })\r\n      assert(ceFullOtherContentTypeStrictSerialized === null) // never executed\r\n    }, Error, 'Expected exception when serializing the current CloudEvent instance')\r\n    t.throws(function () {\r\n      const ceFullOtherContentTypeSerialized = CloudEvent.serializeEvent(ceFullOtherContentTypeStrict, {\r\n        encoder: 'encoderToXmlSample'\r\n      })\r\n      assert(ceFullOtherContentTypeSerialized === null) // never executed\r\n    }, Error, 'Expected exception when serializing the current CloudEvent instance')\r\n    t.throws(function () {\r\n      const ceFullOtherContentTypeSerialized = CloudEvent.serializeEvent(ceFullOtherContentTypeStrict, {\r\n        encodedData: true\r\n      })\r\n      assert(ceFullOtherContentTypeSerialized === null) // never executed\r\n    }, Error, 'Expected exception when serializing the current CloudEvent instance')\r\n    t.throws(function () {\r\n      const flag = CloudEvent.isStrictEvent(undefined)\r\n      assert(flag === false) // never executed\r\n    }, Error, 'Expected exception when trying to get the strict mode for an undefined/null CloudEvent instance')\r\n    t.throws(function () {\r\n      const flag = CloudEvent.isStrictEvent(null)\r\n      assert(flag === false) // never executed\r\n    }, Error, 'Expected exception when trying to get the strict mode for an undefined/null CloudEvent instance')\r\n    t.throws(function () {\r\n      const flag = CloudEvent.isStrictEvent({})\r\n      assert(flag === false) // never executed\r\n    }, Error, 'Expected exception when trying to get the strict mode for for not a CloudEvent instance')\r\n\r\n    {\r\n      const ce = ceFullOtherContentTypeStrict\r\n      CloudEvent.setStrictExtensionInEvent(ce, false)\r\n      const flag = CloudEvent.isStrictEvent(ce)\r\n      t.strictSame(flag, false)\r\n    }\r\n    {\r\n      const ce = ceFullOtherContentTypeStrict\r\n      CloudEvent.setStrictExtensionInEvent(ce, true)\r\n      const flag = CloudEvent.isStrictEvent(ce)\r\n      t.strictSame(flag, true)\r\n    }\r\n\r\n    {\r\n      const ceFullOtherContentTypeStrictBad = new CloudEvent('1/non-default-contenttype/sample-data/strict',\r\n        ceNamespace,\r\n        ceServerUrl,\r\n        ceCommonData, // data\r\n        {\r\n          ...ceCommonOptionsStrict,\r\n          datacontenttype: 'application/xml'\r\n        },\r\n        ceCommonExtensions\r\n      )\r\n      assert(ceFullOtherContentTypeStrictBad !== null)\r\n      t.ok(ceFullOtherContentTypeStrictBad)\r\n      ceFullOtherContentTypeStrictBad.id = null // remove some mandatory attribute now, to let serialization fail\r\n      t.ok(!ceFullOtherContentTypeStrictBad.isValid())\r\n      const ceFullStrictBadSerializedOnlyValidFalse = CloudEvent.serializeEvent(ceFullOtherContentTypeStrictBad, {\r\n        encodedData: ceDataAsXmlString,\r\n        onlyValid: false\r\n      })\r\n      t.ok(ceFullStrictBadSerializedOnlyValidFalse)\r\n      t.throws(function () {\r\n        const ceFullStrictBadSerializedOnlyValidTrue = CloudEvent.serializeEvent(ceFullOtherContentTypeStrictBad, {\r\n          encodedData: ceDataAsXmlString,\r\n          onlyValid: true\r\n        })\r\n        assert(ceFullStrictBadSerializedOnlyValidTrue === null) // never executed\r\n      }, Error, 'Expected exception when serializing a bad CloudEvent instance')\r\n    }\r\n  }\r\n})\r\n\r\n// sample encoding function, to use in tests here\r\nfunction encoderToXmlSample (data) {\r\n  // return ceDataAsXmlString\r\n  // return data.toString()\r\n  return '<data encoder=\"sample\" />'\r\n}\r\n\r\n/** @test {CloudEvent} */\r\ntest('serialize a CloudEvent instance with a non default contenttype and right serialization options, expect success', (t) => {\r\n  t.plan(28)\r\n\r\n  const { CloudEvent, CloudEventValidator: V } = require('../src/')\r\n  t.ok(CloudEvent)\r\n  t.ok(encoderToXmlSample)\r\n  t.ok(V.isFunction(encoderToXmlSample))\r\n  t.ok(!V.ensureIsFunction(encoderToXmlSample, 'encoderToXmlSample')) // no error returned\r\n\r\n  {\r\n    // create an instance with non default contenttype (other options default): expected success ...\r\n    // when I try to serialize specifying right serialization options, expect success ...\r\n    const ceFullOtherContentType = new CloudEvent('1/non-default-contenttype/sample-data/no-strict',\r\n      ceNamespace,\r\n      ceServerUrl,\r\n      ceCommonData, // data\r\n      {\r\n        ...ceCommonOptions,\r\n        datacontenttype: 'application/xml'\r\n      },\r\n      ceCommonExtensions\r\n    )\r\n    assert(ceFullOtherContentType !== null)\r\n    t.ok(ceFullOtherContentType)\r\n    t.ok(ceFullOtherContentType.isValid())\r\n    // test different combinations of serialization options\r\n    // note that if given, encoder function has priority over encoded data\r\n    const cceFullOtherContentTypeSerialized1 = ceFullOtherContentType.serialize({\r\n      encoder: encoderToXmlSample\r\n    })\r\n    t.ok(cceFullOtherContentTypeSerialized1)\r\n    t.ok(CloudEvent.isValidEvent(ceFullOtherContentType))\r\n    const cceFullOtherContentTypeSerialized2 = ceFullOtherContentType.serialize({\r\n      encodedData: ceDataAsXmlString\r\n    })\r\n    t.ok(cceFullOtherContentTypeSerialized2)\r\n    t.ok(CloudEvent.isValidEvent(ceFullOtherContentType))\r\n    const fixedEncodedData = '<data \"fixed\"=\"encoded\" />'\r\n    const cceFullOtherContentTypeSerialized3 = ceFullOtherContentType.serialize({\r\n      encoder: encoderToXmlSample,\r\n      // encodedData: undefined\r\n      // encodedData: null\r\n      // encodedData: ceDataAsXmlString\r\n      encodedData: fixedEncodedData\r\n    })\r\n    t.ok(cceFullOtherContentTypeSerialized3)\r\n    t.ok(CloudEvent.isValidEvent(ceFullOtherContentType))\r\n    const cceFullOtherContentTypeSerialized4 = CloudEvent.serializeEvent(ceFullOtherContentType, {\r\n      encoder: encoderToXmlSample,\r\n      encodedData: fixedEncodedData,\r\n      onlyValid: false\r\n    })\r\n    t.ok(cceFullOtherContentTypeSerialized4)\r\n    t.ok(CloudEvent.isValidEvent(ceFullOtherContentType))\r\n    const cceFullOtherContentTypeSerialized5 = CloudEvent.serializeEvent(ceFullOtherContentType, {\r\n      encoder: encoderToXmlSample,\r\n      encodedData: fixedEncodedData,\r\n      onlyValid: true\r\n    })\r\n    t.ok(cceFullOtherContentTypeSerialized5)\r\n    t.ok(CloudEvent.isValidEvent(ceFullOtherContentType))\r\n  }\r\n\r\n  {\r\n    // the same but with strict mode enabled ...\r\n    // expect success even if content type is not default and data is not a string,\r\n    // anyway use encoder/decoder to let serialization/deserialization work in this case (strict) ...\r\n    const ceFullOtherContentTypeStrict = new CloudEvent('1/non-default-contenttype/sample-data/strict',\r\n      ceNamespace,\r\n      ceServerUrl,\r\n      ceCommonData, // data\r\n      {\r\n        ...ceCommonOptionsStrict,\r\n        datacontenttype: 'application/xml'\r\n      },\r\n      ceCommonExtensions\r\n    )\r\n    assert(ceFullOtherContentTypeStrict !== null)\r\n    t.ok(ceFullOtherContentTypeStrict)\r\n    t.ok(ceFullOtherContentTypeStrict.isValid())\r\n    // test different combinations of serialization options\r\n    // note that if given, encoder function has priority over encoded data\r\n    const ceFullOtherContentTypeStrictSerialized1 = ceFullOtherContentTypeStrict.serialize({\r\n      encoder: encoderToXmlSample\r\n    })\r\n    t.ok(ceFullOtherContentTypeStrictSerialized1)\r\n    t.ok(CloudEvent.isValidEvent(ceFullOtherContentTypeStrict))\r\n    const ceFullOtherContentTypeStrictSerialized2 = ceFullOtherContentTypeStrict.serialize({\r\n      encodedData: ceDataAsXmlString\r\n    })\r\n    t.ok(ceFullOtherContentTypeStrictSerialized2)\r\n    t.ok(CloudEvent.isValidEvent(ceFullOtherContentTypeStrict))\r\n    const fixedEncodedData = '<data \"fixed\"=\"encoded\" />'\r\n    const ceFullOtherContentTypeStrictSerialized3 = ceFullOtherContentTypeStrict.serialize({\r\n      encoder: encoderToXmlSample,\r\n      // encodedData: undefined\r\n      // encodedData: null\r\n      // encodedData: ceDataAsXmlString\r\n      encodedData: fixedEncodedData\r\n    })\r\n    t.ok(ceFullOtherContentTypeStrictSerialized3)\r\n    t.ok(CloudEvent.isValidEvent(ceFullOtherContentTypeStrict))\r\n    const ceFullOtherContentTypeStrictSerialized4 = CloudEvent.serializeEvent(ceFullOtherContentTypeStrict, {\r\n      encoder: encoderToXmlSample,\r\n      encodedData: fixedEncodedData,\r\n      onlyValid: false\r\n    })\r\n    t.ok(ceFullOtherContentTypeStrictSerialized4)\r\n    t.ok(CloudEvent.isValidEvent(ceFullOtherContentTypeStrict))\r\n    const ceFullOtherContentTypeStrictSerialized5 = CloudEvent.serializeEvent(ceFullOtherContentTypeStrict, {\r\n      encoder: encoderToXmlSample,\r\n      encodedData: fixedEncodedData,\r\n      onlyValid: true\r\n    })\r\n    // note that onlyValid here is a check on transformed data ...\r\n    t.ok(ceFullOtherContentTypeStrictSerialized5)\r\n    t.ok(V.isStringNotEmpty(ceFullOtherContentTypeStrictSerialized5))\r\n  }\r\n})\r\n\r\n// sample encoding function to JSON, to use in tests here\r\nfunction encoderToJSON (data) {\r\n  // return ceDataAsJSONString\r\n  return JSON.stringify(data)\r\n}\r\n\r\n/** @test {CloudEvent} */\r\ntest('serialize a CloudEvent instance with a non default contenttype (but in the JSON-like family) and right serialization options, expect success', (t) => {\r\n  t.plan(54)\r\n\r\n  const { CloudEvent, CloudEventValidator: V } = require('../src/')\r\n  t.ok(CloudEvent)\r\n  t.ok(encoderToJSON)\r\n  t.ok(V.isFunction(encoderToJSON))\r\n  t.ok(!V.ensureIsFunction(encoderToJSON, 'encoderToJSON')) // no error returned\r\n\r\n  {\r\n    // create an instance with non default contenttype (other options default): expected success ...\r\n    const ceFullOtherContentTypeJSON = new CloudEvent('1/non-default-contenttype-but-json/sample-data/no-strict',\r\n      ceNamespace,\r\n      ceServerUrl,\r\n      ceCommonData, // data\r\n      {\r\n        ...ceCommonOptions,\r\n        datacontenttype: 'text/json'\r\n      },\r\n      ceCommonExtensions\r\n    )\r\n    assert(ceFullOtherContentTypeJSON !== null)\r\n    t.ok(ceFullOtherContentTypeJSON)\r\n    t.ok(ceFullOtherContentTypeJSON.isValid())\r\n    t.ok(!ceFullOtherContentTypeJSON.isStrict)\r\n    t.notStrictEqual(ceFullOtherContentTypeJSON.datacontenttype, CloudEvent.datacontenttypeDefault())\r\n    t.ok(CloudEvent.isDatacontenttypeJSONEvent(ceFullOtherContentTypeJSON))\r\n\r\n    // improve coverage on that method\r\n    t.throws(function () {\r\n      const dct = CloudEvent.isDatacontenttypeJSONEvent(undefined)\r\n      assert(dct === false) // never executed\r\n    }, Error, 'Expected exception when trying to get the data content type for an undefined/null CloudEvent instance')\r\n    t.throws(function () {\r\n      const dct = CloudEvent.isDatacontenttypeJSONEvent(null)\r\n      assert(dct === false) // never executed\r\n    }, Error, 'Expected exception when trying to get the data content type for an undefined/null CloudEvent instance')\r\n    t.throws(function () {\r\n      const dct = CloudEvent.isDatacontenttypeJSONEvent({})\r\n      assert(dct === false) // never executed\r\n    }, Error, 'Expected exception when trying to get the data content type for for not a CloudEvent instance')\r\n    {\r\n      const ce = ceFullOtherContentTypeJSON\r\n      CloudEvent.setStrictExtensionInEvent(ce, false)\r\n      const dct = CloudEvent.isDatacontenttypeJSONEvent(ce)\r\n      t.strictSame(dct, true)\r\n      t.strictSame(ce.isDatacontenttypeJSON, true)\r\n    }\r\n    {\r\n      const ce = ceFullOtherContentTypeJSON\r\n      CloudEvent.setStrictExtensionInEvent(ce, true)\r\n      const dct = CloudEvent.isDatacontenttypeJSONEvent(ce)\r\n      t.strictSame(dct, true)\r\n      t.strictSame(ce.isDatacontenttypeJSON, true)\r\n    }\r\n\r\n    // when I try to serialize it without specifying serialization options, expect to have an error raised ...\r\n    t.throws(function () {\r\n      const ceFullOtherContentTypeSerialized = ceFullOtherContentTypeJSON.serialize()\r\n      assert(ceFullOtherContentTypeSerialized === null) // never executed\r\n    }, Error, 'Expected exception when serializing the current CloudEvent instance')\r\n    t.throws(function () {\r\n      const ceFullOtherContentTypeSerialized = CloudEvent.serializeEvent(ceFullOtherContentTypeJSON, {\r\n        encoder: 'encoderToJSON'\r\n      })\r\n      assert(ceFullOtherContentTypeSerialized === null) // never executed\r\n    }, Error, 'Expected exception when serializing the current CloudEvent instance')\r\n    t.throws(function () {\r\n      const ceFullOtherContentTypeSerialized = CloudEvent.serializeEvent(ceFullOtherContentTypeJSON, {\r\n        encodedData: true\r\n      })\r\n      assert(ceFullOtherContentTypeSerialized === null) // never executed\r\n    }, Error, 'Expected exception when serializing the current CloudEvent instance')\r\n\r\n    // when I try to serialize specifying right serialization options, expect success ...\r\n    // test different combinations of serialization options\r\n    // note that if given, encoder function has priority over encoded data\r\n    const cceFullOtherContentTypeSerialized1 = ceFullOtherContentTypeJSON.serialize({\r\n      encoder: encoderToJSON\r\n    })\r\n    t.ok(cceFullOtherContentTypeSerialized1)\r\n    t.ok(CloudEvent.isValidEvent(ceFullOtherContentTypeJSON))\r\n    const cceFullOtherContentTypeSerialized2 = ceFullOtherContentTypeJSON.serialize({\r\n      encodedData: ceDataAsJSONString\r\n    })\r\n    t.ok(cceFullOtherContentTypeSerialized2)\r\n    t.ok(CloudEvent.isValidEvent(ceFullOtherContentTypeJSON))\r\n    const fixedEncodedData = { fixed: 'encoded' }\r\n    const cceFullOtherContentTypeSerialized3 = ceFullOtherContentTypeJSON.serialize({\r\n      encoder: encoderToJSON,\r\n      // encodedData: undefined\r\n      // encodedData: null\r\n      // encodedData: ceDataAsJSONString\r\n      encodedData: fixedEncodedData\r\n    })\r\n    t.ok(cceFullOtherContentTypeSerialized3)\r\n    t.ok(CloudEvent.isValidEvent(ceFullOtherContentTypeJSON))\r\n    const cceFullOtherContentTypeSerialized4 = CloudEvent.serializeEvent(ceFullOtherContentTypeJSON, {\r\n      encoder: encoderToJSON,\r\n      encodedData: fixedEncodedData,\r\n      onlyValid: false\r\n    })\r\n    t.ok(cceFullOtherContentTypeSerialized4)\r\n    t.ok(CloudEvent.isValidEvent(ceFullOtherContentTypeJSON))\r\n    const cceFullOtherContentTypeSerialized5 = CloudEvent.serializeEvent(ceFullOtherContentTypeJSON, {\r\n      encoder: encoderToJSON,\r\n      encodedData: fixedEncodedData,\r\n      onlyValid: true\r\n    })\r\n    t.ok(cceFullOtherContentTypeSerialized5)\r\n    t.ok(CloudEvent.isValidEvent(ceFullOtherContentTypeJSON))\r\n\r\n    // the same for deserializtion ...\r\n  }\r\n\r\n  {\r\n    // create an instance with non default contenttype (other options default): expected success ...\r\n    const ceFullOtherContentTypeJSONStrict = new CloudEvent('1/non-default-contenttype-but-json/sample-data/strict',\r\n      ceNamespace,\r\n      ceServerUrl,\r\n      ceCommonData, // data\r\n      {\r\n        ...ceCommonOptionsStrict,\r\n        datacontenttype: 'text/json'\r\n      },\r\n      ceCommonExtensions\r\n    )\r\n    assert(ceFullOtherContentTypeJSONStrict !== null)\r\n    t.ok(ceFullOtherContentTypeJSONStrict)\r\n    t.ok(ceFullOtherContentTypeJSONStrict.isValid())\r\n    t.ok(ceFullOtherContentTypeJSONStrict.isStrict)\r\n    t.notStrictEqual(ceFullOtherContentTypeJSONStrict.datacontenttype, CloudEvent.datacontenttypeDefault())\r\n    t.ok(CloudEvent.isDatacontenttypeJSONEvent(ceFullOtherContentTypeJSONStrict))\r\n\r\n    // improve coverage on that method\r\n    t.throws(function () {\r\n      const dct = CloudEvent.isDatacontenttypeJSONEvent(undefined)\r\n      assert(dct === false) // never executed\r\n    }, Error, 'Expected exception when trying to get the data content type for an undefined/null CloudEvent instance')\r\n    t.throws(function () {\r\n      const dct = CloudEvent.isDatacontenttypeJSONEvent(null)\r\n      assert(dct === false) // never executed\r\n    }, Error, 'Expected exception when trying to get the data content type for an undefined/null CloudEvent instance')\r\n    t.throws(function () {\r\n      const dct = CloudEvent.isDatacontenttypeJSONEvent({})\r\n      assert(dct === false) // never executed\r\n    }, Error, 'Expected exception when trying to get the data content type for for not a CloudEvent instance')\r\n    {\r\n      const ce = ceFullOtherContentTypeJSONStrict\r\n      CloudEvent.setStrictExtensionInEvent(ce, false)\r\n      const dct = CloudEvent.isDatacontenttypeJSONEvent(ce)\r\n      t.strictSame(dct, true)\r\n      t.strictSame(ce.isDatacontenttypeJSON, true)\r\n    }\r\n    {\r\n      const ce = ceFullOtherContentTypeJSONStrict\r\n      CloudEvent.setStrictExtensionInEvent(ce, true)\r\n      const dct = CloudEvent.isDatacontenttypeJSONEvent(ce)\r\n      t.strictSame(dct, true)\r\n      t.strictSame(ce.isDatacontenttypeJSON, true)\r\n    }\r\n\r\n    // when I try to serialize it without specifying serialization options, expect to have an error raised ...\r\n    t.throws(function () {\r\n      const ceFullOtherContentTypeSerialized = ceFullOtherContentTypeJSONStrict.serialize()\r\n      assert(ceFullOtherContentTypeSerialized === null) // never executed\r\n    }, Error, 'Expected exception when serializing the current CloudEvent instance')\r\n    t.throws(function () {\r\n      const ceFullOtherContentTypeSerialized = CloudEvent.serializeEvent(ceFullOtherContentTypeJSONStrict, {\r\n        encoder: 'encoderToJSON'\r\n      })\r\n      assert(ceFullOtherContentTypeSerialized === null) // never executed\r\n    }, Error, 'Expected exception when serializing the current CloudEvent instance')\r\n    t.throws(function () {\r\n      const ceFullOtherContentTypeSerialized = CloudEvent.serializeEvent(ceFullOtherContentTypeJSONStrict, {\r\n        encodedData: true\r\n      })\r\n      assert(ceFullOtherContentTypeSerialized === null) // never executed\r\n    }, Error, 'Expected exception when serializing the current CloudEvent instance')\r\n\r\n    // when I try to serialize specifying right serialization options, expect success ...\r\n    // test different combinations of serialization options\r\n    // note that if given, encoder function has priority over encoded data\r\n    const cceFullOtherContentTypeSerialized1 = ceFullOtherContentTypeJSONStrict.serialize({\r\n      encoder: encoderToJSON\r\n    })\r\n    t.ok(cceFullOtherContentTypeSerialized1)\r\n    t.ok(CloudEvent.isValidEvent(ceFullOtherContentTypeJSONStrict))\r\n    const cceFullOtherContentTypeSerialized2 = ceFullOtherContentTypeJSONStrict.serialize({\r\n      encodedData: ceDataAsJSONString\r\n    })\r\n    t.ok(cceFullOtherContentTypeSerialized2)\r\n    t.ok(CloudEvent.isValidEvent(ceFullOtherContentTypeJSONStrict))\r\n    const fixedEncodedData = { fixed: 'encoded' }\r\n    const cceFullOtherContentTypeSerialized3 = ceFullOtherContentTypeJSONStrict.serialize({\r\n      encoder: encoderToJSON,\r\n      // encodedData: undefined\r\n      // encodedData: null\r\n      // encodedData: ceDataAsJSONString\r\n      encodedData: fixedEncodedData\r\n    })\r\n    t.ok(cceFullOtherContentTypeSerialized3)\r\n    t.ok(CloudEvent.isValidEvent(ceFullOtherContentTypeJSONStrict))\r\n    const cceFullOtherContentTypeSerialized4 = CloudEvent.serializeEvent(ceFullOtherContentTypeJSONStrict, {\r\n      encoder: encoderToJSON,\r\n      encodedData: fixedEncodedData,\r\n      onlyValid: false\r\n    })\r\n    t.ok(cceFullOtherContentTypeSerialized4)\r\n    t.ok(CloudEvent.isValidEvent(ceFullOtherContentTypeJSONStrict))\r\n    const cceFullOtherContentTypeSerialized5 = CloudEvent.serializeEvent(ceFullOtherContentTypeJSONStrict, {\r\n      encoder: encoderToJSON,\r\n      encodedData: fixedEncodedData,\r\n      onlyValid: true\r\n    })\r\n    t.ok(cceFullOtherContentTypeSerialized5)\r\n    t.ok(CloudEvent.isValidEvent(ceFullOtherContentTypeJSONStrict))\r\n\r\n    // the same for deserializtion ...\r\n  }\r\n})\r\n\r\n/** @test {CloudEvent} */\r\ntest('ensure the JSON Schema for a CloudEvent (static and for a normal instance) is available', (t) => {\r\n  t.plan(6)\r\n\r\n  const { CloudEvent } = require('../src/')\r\n  t.ok(CloudEvent)\r\n\r\n  // get JSON Schema from a static method\r\n  const jsonSchemaStatic = CloudEvent.getJSONSchema()\r\n  assert(jsonSchemaStatic !== null)\r\n  t.ok(jsonSchemaStatic)\r\n  t.strictEqual(typeof jsonSchemaStatic, 'object')\r\n\r\n  // create a sample CloudEvent instance ...\r\n  const ceFullStrict = new CloudEvent('1/full/sample-data/strict',\r\n    ceNamespace,\r\n    ceServerUrl,\r\n    ceCommonData, // data\r\n    ceCommonOptionsStrict,\r\n    ceCommonExtensions\r\n  )\r\n  assert(ceFullStrict !== null)\r\n  t.ok(ceFullStrict)\r\n  // get JSON Schema from that instance\r\n  const jsonSchema = ceFullStrict.schema\r\n  assert(jsonSchema !== null)\r\n  t.ok(jsonSchema)\r\n  t.strictEqual(typeof jsonSchema, 'object')\r\n})\r\n\r\n/** create some common data with nested attributes, for better reuse in tests */\r\nconst ceCommonNestedData = {\r\n  ...ceCommonData,\r\n  nested1: {\r\n    level1attribute: 'level1attributeValue',\r\n    nested2: {\r\n      level2attribute: 'level2attributeValue',\r\n      nested3: {\r\n        level3attribute: 'level3attributeValue'\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nconst { CloudEventTransformer: T } = require('../src/')\r\nconst ceNestedFullSerializedJson = `{\"id\":\"1/full/sample-data-nested/no-strict\",\"type\":\"com.github.smartiniOnGitHub.cloudeventjs.testevent\",\"source\":\"/test\",\"data\":{\"hello\":\"world\",\"year\":2019,\"nested1\":{\"level1attribute\":\"level1attributeValue\",\"nested2\":{\"level2attribute\":\"level2attributeValue\",\"nested3\":{\"level3attribute\":\"level3attributeValue\"}}}},\"specversion\":\"0.3\",\"datacontenttype\":\"application/json\",\"time\":\"${T.timestampToString(commonEventTime)}\",\"schemaurl\":\"http://my-schema.localhost.localdomain\",\"subject\":\"subject\",\"exampleExtension\":\"value\"}`\r\nconst ceNestedFullStrictSerializedJson = `{\"id\":\"1/full/sample-data-nested/strict\",\"type\":\"com.github.smartiniOnGitHub.cloudeventjs.testevent\",\"source\":\"/test\",\"data\":{\"hello\":\"world\",\"year\":2019,\"nested1\":{\"level1attribute\":\"level1attributeValue\",\"nested2\":{\"level2attribute\":\"level2attributeValue\",\"nested3\":{\"level3attribute\":\"level3attributeValue\"}}}},\"specversion\":\"0.3\",\"datacontenttype\":\"application/json\",\"time\":\"${T.timestampToString(commonEventTime)}\",\"schemaurl\":\"http://my-schema.localhost.localdomain\",\"subject\":\"subject\",\"com_github_smartiniOnGitHub_cloudevent\":{\"strict\":true},\"exampleExtension\":\"value\"}`\r\nconst ceFullOtherContentTypeSerializedJson = `{\"id\":\"1/full/sample-data-nested/no-strict\",\"type\":\"com.github.smartiniOnGitHub.cloudeventjs.testevent\",\"source\":\"/test\",\"data\":\"<data 'hello'='world' 'year'='2019' />\",\"specversion\":\"0.3\",\"datacontenttype\":\"application/xml\",\"time\":\"${T.timestampToString(commonEventTime)}\",\"exampleExtension\":\"value\",\"schemaurl\":\"http://my-schema.localhost.localdomain\"}`\r\nconst ceFullOtherContentTypeStrictSerializedJson = `{\"id\":\"1/full/sample-data-nested/strict\",\"type\":\"com.github.smartiniOnGitHub.cloudeventjs.testevent\",\"source\":\"/test\",\"data\":\"<data 'hello'='world' 'year'='2019' />\",\"specversion\":\"0.3\",\"datacontenttype\":\"application/xml\",\"time\":\"${T.timestampToString(commonEventTime)}\",\"exampleExtension\":\"value\",\"com_github_smartiniOnGitHub_cloudevent\":{\"strict\":true},\"schemaurl\":\"http://my-schema.localhost.localdomain\"}`\r\nconst ceFullOtherContentTypeSerializedBadJson = `{\"data\":\"<data 'hello'='world' 'year'='2019' />\",\"datacontenttype\":\"application/xml\",\"time\":\"${T.timestampToString(commonEventTime)}\",\"exampleExtension\":\"value\"}`\r\nconst ceFullOtherContentTypeStrictSerializedBadJson = `{\"data\":\"<data 'hello'='world' 'year'='2019' />\",\"datacontenttype\":\"application/xml\",\"time\":\"${T.timestampToString(commonEventTime)}\",\"exampleExtension\":\"value\",\"com_github_smartiniOnGitHub_cloudevent\":{\"strict\":true}}`\r\n\r\n/** @test {CloudEvent} */\r\ntest('serialize some CloudEvent instances to JSON with nested data, and ensure they are right', (t) => {\r\n  t.plan(52)\r\n\r\n  const { CloudEvent } = require('../src/')\r\n  // t.ok(CloudEvent)\r\n\r\n  {\r\n    const ceFull = new CloudEvent('1/full/sample-data-nested/no-strict',\r\n      ceNamespace,\r\n      ceServerUrl,\r\n      ceCommonNestedData, // data\r\n      ceCommonOptions,\r\n      ceCommonExtensions\r\n    )\r\n    assert(ceFull !== null)\r\n    t.ok(ceFull)\r\n    t.ok(ceFull.isValid())\r\n    t.ok(ceFull.validate().length === 0)\r\n    t.ok(ceFull.validate({ strict: false }).length === 0)\r\n    t.ok(ceFull.validate({ strict: true }).length === 0)\r\n    t.ok(CloudEvent.isValidEvent(ceFull))\r\n    t.ok(CloudEvent.validateEvent(ceFull).length === 0)\r\n    t.ok(CloudEvent.validateEvent(ceFull, { strict: false }).length === 0)\r\n    t.ok(CloudEvent.validateEvent(ceFull, { strict: true }).length === 0)\r\n\r\n    const ceFullSerializedStatic = CloudEvent.serializeEvent(ceFull)\r\n    t.ok(ceFullSerializedStatic)\r\n    const ceFullSerialized = ceFull.serialize()\r\n    t.ok(ceFullSerialized)\r\n    assert(ceFullSerializedStatic === ceFullSerialized)\r\n    t.strictSame(ceFullSerializedStatic, ceFullSerialized)\r\n    const ceSerialize = CloudEvent.serializeEvent\r\n    assert(ceSerialize !== null)\r\n    t.ok(ceSerialize)\r\n    const ceFullSerializedFunction = ceSerialize(ceFull)\r\n    t.ok(ceFullSerializedFunction)\r\n    t.strictSame(ceFullSerializedFunction, ceFullSerializedStatic)\r\n    t.strictSame(ceFullSerializedFunction, ceFullSerialized)\r\n\r\n    const ceFullSerializedOnlyValidFalse = ceSerialize(ceFull, { onlyValid: false })\r\n    t.ok(ceFullSerializedOnlyValidFalse)\r\n    const ceFullSerializedOnlyValidTrue = ceSerialize(ceFull, { onlyValid: true })\r\n    t.ok(ceFullSerializedOnlyValidTrue)\r\n\r\n    const ceFullSerializedComparison = ceNestedFullSerializedJson\r\n    t.strictSame(ceFullSerialized, ceFullSerializedComparison)\r\n    const ceFullDeserialized = JSON.parse(ceFullSerialized) // note that some fields (like dates) will be different when deserialized in this way ...\r\n    ceFullDeserialized.time = commonEventTime // quick fix for the Date/timestamp attribute in the deserialized object\r\n    ceFullDeserialized.datacontentencoding = undefined // quick fix for this not so common attribute in the deserialized object\r\n    t.same(ceFull, ceFullDeserialized)\r\n\r\n    // ensure payload data is a copy of event data\r\n    let dataShallowClone = ceFull.payload\r\n    // then ensure they are different object (references) ...\r\n    assert(dataShallowClone !== null)\r\n    assert(dataShallowClone !== ceFull.data) // they must be different object references\r\n    assert(dataShallowClone !== ceFull.payload) // they must be different object references, at any invocation\r\n    t.notEqual(dataShallowClone, ceFull.data)\r\n    t.notStrictEqual(dataShallowClone, ceFull.data)\r\n    t.notEqual(dataShallowClone, ceFull.payload)\r\n    dataShallowClone = 'changed: true' // reassign to test that data won't be affected by that change\r\n    t.notEqual(dataShallowClone, ceFull.data)\r\n    t.strictNotSame(dataShallowClone, ceFull.data)\r\n    t.notEqual(dataShallowClone, ceFull.payload)\r\n  }\r\n\r\n  {\r\n    // the same but with strict mode enabled ...\r\n    const ceFullStrict = new CloudEvent('1/full/sample-data-nested/strict',\r\n      ceNamespace,\r\n      ceServerUrl,\r\n      ceCommonNestedData, // data\r\n      ceCommonOptionsStrict,\r\n      ceCommonExtensions\r\n    )\r\n    assert(ceFullStrict !== null)\r\n    t.ok(ceFullStrict)\r\n    t.ok(ceFullStrict.isValid())\r\n    t.ok(ceFullStrict.validate().length === 0)\r\n    t.ok(ceFullStrict.validate({ strict: true }).length === 0)\r\n    t.ok(ceFullStrict.validate({ strict: false }).length === 0)\r\n    t.ok(CloudEvent.isValidEvent(ceFullStrict))\r\n    t.ok(CloudEvent.validateEvent(ceFullStrict).length === 0)\r\n    t.ok(CloudEvent.validateEvent(ceFullStrict, { strict: true }).length === 0)\r\n    t.ok(CloudEvent.validateEvent(ceFullStrict, { strict: false }).length === 0)\r\n\r\n    const ceFullStrictSerializedStatic = CloudEvent.serializeEvent(ceFullStrict)\r\n    t.ok(ceFullStrictSerializedStatic)\r\n    const ceFullStrictSerialized = ceFullStrict.serialize()\r\n    t.ok(ceFullStrictSerialized)\r\n    assert(ceFullStrictSerializedStatic === ceFullStrictSerialized)\r\n    t.strictSame(ceFullStrictSerializedStatic, ceFullStrictSerialized)\r\n    const ceSerialize = CloudEvent.serializeEvent\r\n    assert(ceSerialize !== null)\r\n    t.ok(ceSerialize)\r\n    const ceFullStrictSerializedFunction = ceSerialize(ceFullStrict)\r\n    t.ok(ceFullStrictSerializedFunction)\r\n    t.strictSame(ceFullStrictSerializedFunction, ceFullStrictSerializedStatic)\r\n    t.strictSame(ceFullStrictSerializedFunction, ceFullStrictSerialized)\r\n\r\n    const ceFullStrictSerializedOnlyValidFalse = ceSerialize(ceFullStrict, { onlyValid: false })\r\n    t.ok(ceFullStrictSerializedOnlyValidFalse)\r\n    const ceFullStrictSerializedOnlyValidTrue = ceSerialize(ceFullStrict, { onlyValid: true })\r\n    t.ok(ceFullStrictSerializedOnlyValidTrue)\r\n\r\n    const ceFullStrictSerializedComparison = ceNestedFullStrictSerializedJson\r\n    t.strictSame(ceFullStrictSerialized, ceFullStrictSerializedComparison)\r\n    const ceFullStrictDeserialized = JSON.parse(ceFullStrictSerialized) // note that some fields (like dates) will be different when deserialized in this way ...\r\n    ceFullStrictDeserialized.time = commonEventTime // quick fix for the Date/timestamp attribute in the deserialized object\r\n    ceFullStrictDeserialized.datacontentencoding = undefined // quick fix for this not so common attribute in the deserialized object\r\n    t.same(ceFullStrict, ceFullStrictDeserialized)\r\n\r\n    // ensure payload data is a copy of event data\r\n    let dataShallowCloneStrict = ceFullStrict.payload\r\n    // then ensure they are different object (references) ...\r\n    assert(dataShallowCloneStrict !== null)\r\n    assert(dataShallowCloneStrict !== ceFullStrict.data) // they must be different object references\r\n    assert(dataShallowCloneStrict !== ceFullStrict.payload) // they must be different object references, at any invocation\r\n    t.notEqual(dataShallowCloneStrict, ceFullStrict.data)\r\n    t.notStrictEqual(dataShallowCloneStrict, ceFullStrict.data)\r\n    t.notEqual(dataShallowCloneStrict, ceFullStrict.payload)\r\n    dataShallowCloneStrict = 'changed: true' // reassign to test that data won't be affected by that change\r\n    t.notEqual(dataShallowCloneStrict, ceFullStrict.data)\r\n    t.strictNotSame(dataShallowCloneStrict, ceFullStrict.data)\r\n    t.notEqual(dataShallowCloneStrict, ceFullStrict.payload)\r\n  }\r\n})\r\n\r\n/** @test {CloudEvent} */\r\ntest('deserialize generic strings (not JSON representation for an Object) into a CloudEvent instance, expected Errors', (t) => {\r\n  t.plan(10)\r\n\r\n  const { CloudEvent } = require('../src/') // get references via destructuring\r\n  t.ok(CloudEvent)\r\n\r\n  t.throws(function () {\r\n    const deserialized = CloudEvent.deserializeEvent()\r\n    assert(deserialized === null) // never executed\r\n  }, Error, 'Expected exception when deserializing an undefined reference')\r\n  t.throws(function () {\r\n    const deserialized = CloudEvent.deserializeEvent(undefined)\r\n    assert(deserialized === null) // never executed\r\n  }, Error, 'Expected exception when deserializing an undefined reference')\r\n  t.throws(function () {\r\n    const deserialized = CloudEvent.deserializeEvent(null)\r\n    assert(deserialized === null) // never executed\r\n  }, Error, 'Expected exception when deserializing a null reference')\r\n  t.throws(function () {\r\n    const deserialized = CloudEvent.deserializeEvent('')\r\n    assert(deserialized === null) // never executed\r\n  }, Error, 'Expected exception when deserializing an empty string')\r\n  t.throws(function () {\r\n    const deserialized = CloudEvent.deserializeEvent('sample string')\r\n    assert(deserialized === null) // never executed\r\n  }, Error, 'Expected exception when deserializing a string not representing an object (in JSON)')\r\n  t.throws(function () {\r\n    const deserialized = CloudEvent.deserializeEvent('{ sample string, not a valid json }')\r\n    assert(deserialized === null) // never executed\r\n  }, Error, 'Expected exception when deserializing a string not representing an object (in JSON)')\r\n  t.throws(function () {\r\n    const deserialized = CloudEvent.deserializeEvent('[ \"sample array/list\", \"of\", \"values\" ]')\r\n    assert(deserialized === null) // never executed\r\n  }, Error, 'Expected exception when deserializing a string representing an array (in JSON)')\r\n  t.throws(function () {\r\n    const deserialized = CloudEvent.deserializeEvent('{ sample string, not a valid json }', { onlyValid: false })\r\n    assert(deserialized === null) // never executed\r\n  }, Error, 'Expected exception when deserializing a string not representing an object (in JSON)')\r\n  t.throws(function () {\r\n    const deserialized = CloudEvent.deserializeEvent('{ sample string, not a valid json }', { onlyValid: true })\r\n    assert(deserialized === null) // never executed\r\n  }, Error, 'Expected exception when deserializing a string not representing an object (in JSON)')\r\n})\r\n\r\n/** @test {CloudEvent} */\r\ntest('deserialize some CloudEvent instances from JSON, and ensure built instances are right', (t) => {\r\n  t.plan(54)\r\n\r\n  const { CloudEvent, CloudEventValidator: V } = require('../src/') // get references via destructuring\r\n\r\n  {\r\n    const serialized = ceNestedFullSerializedJson\r\n    // console.log(`DEBUG - serialized cloudEvent details: serialized = '${serialized}'`)\r\n    t.ok(serialized)\r\n    t.ok(V.isString(serialized))\r\n\r\n    const ceDeserialized = CloudEvent.deserializeEvent(serialized)\r\n    assert(ceDeserialized !== null)\r\n    // console.log(`DEBUG - cloudEvent type: ${typeof ceDeserialized}`)\r\n    // console.log(`DEBUG - cloudEvent details: ceDeserialized = ${JSON.stringify(ceDeserialized)}`)\r\n    // console.log(`DEBUG - cloudEvent details: ${T.dumpObject(ceDeserialized, 'ceDeserialized')}`)\r\n    // console.log(`DEBUG - cloudEvent validation: ${ceDeserialized.validate()}`)\r\n    // console.log(`DEBUG - cloudEvent validation (strict): ${ceDeserialized.validate({ strict: true })}`)\r\n    t.ok(ceDeserialized)\r\n    t.ok(V.isClass(ceDeserialized, CloudEvent))\r\n    t.ok(ceDeserialized.isValid())\r\n    t.ok(ceDeserialized.validate().length === 0)\r\n    t.ok(ceDeserialized.validate({ strict: false }).length === 0)\r\n    t.ok(ceDeserialized.validate({ strict: true }).length === 0)\r\n    t.ok(CloudEvent.isValidEvent(ceDeserialized))\r\n    t.ok(CloudEvent.validateEvent(ceDeserialized).length === 0)\r\n    t.ok(CloudEvent.validateEvent(ceDeserialized, { strict: false }).length === 0)\r\n    t.ok(CloudEvent.validateEvent(ceDeserialized, { strict: true }).length === 0)\r\n    t.ok(CloudEvent.isCloudEvent(ceDeserialized))\r\n\r\n    // inspect content of deserialized CloudEvent, at least on some attributes\r\n    t.ok(ceDeserialized.time)\r\n    t.ok(V.isDate(ceDeserialized.time))\r\n    t.ok(V.isDateValid(ceDeserialized.time))\r\n    t.ok(V.isDatePast(ceDeserialized.time))\r\n    t.strictSame(ceDeserialized.time.getTime(), commonEventTime.getTime())\r\n    t.notStrictEqual(ceDeserialized.time, commonEventTime)\r\n    t.notEqual(ceDeserialized.time, commonEventTime)\r\n    // console.log(`DEBUG - cloudEvent data: ${T.dumpObject(ceDeserialized.data, 'ceDeserialized.data')}`)\r\n    // console.log(`DEBUG - cloudEvent payload: ${T.dumpObject(ceDeserialized.payload, 'ceDeserialized.payload')}`)\r\n    t.ok(ceDeserialized.data)\r\n    t.ok(V.isObject(ceDeserialized.data))\r\n    t.ok(ceDeserialized.payload)\r\n    t.ok(V.isObject(ceDeserialized.payload))\r\n    // then ensure the value of both are the same ...\r\n    t.strictSame(ceDeserialized.data, ceDeserialized.payload)\r\n    // then ensure they are different object (references) ...\r\n    t.notStrictEqual(ceDeserialized.data, ceDeserialized.payload)\r\n    t.notEqual(ceDeserialized.data, ceDeserialized.payload)\r\n  }\r\n\r\n  {\r\n    // the same but with strict mode enabled ...\r\n    const serialized = ceNestedFullStrictSerializedJson\r\n    // console.log(`DEBUG - serialized cloudEvent details: serialized = '${serialized}'`)\r\n    t.ok(serialized)\r\n    t.ok(V.isString(serialized))\r\n\r\n    const ceDeserialized = CloudEvent.deserializeEvent(serialized)\r\n    assert(ceDeserialized !== null)\r\n    // console.log(`DEBUG - cloudEvent type: ${typeof ceDeserialized}`)\r\n    // console.log(`DEBUG - cloudEvent details: ceDeserialized = ${JSON.stringify(ceDeserialized)}`)\r\n    // console.log(`DEBUG - cloudEvent details: ${T.dumpObject(ceDeserialized, 'ceDeserialized')}`)\r\n    // console.log(`DEBUG - cloudEvent validation: ${ceDeserialized.validate()}`)\r\n    // console.log(`DEBUG - cloudEvent validation (strict): ${ceDeserialized.validate({ strict: true })}`)\r\n    t.ok(ceDeserialized)\r\n    t.ok(V.isClass(ceDeserialized, CloudEvent))\r\n    t.ok(ceDeserialized.isValid())\r\n    t.ok(ceDeserialized.validate().length === 0)\r\n    t.ok(ceDeserialized.validate({ strict: false }).length === 0)\r\n    t.ok(ceDeserialized.validate({ strict: true }).length === 0)\r\n    t.ok(CloudEvent.isValidEvent(ceDeserialized))\r\n    t.ok(CloudEvent.validateEvent(ceDeserialized).length === 0)\r\n    t.ok(CloudEvent.validateEvent(ceDeserialized, { strict: false }).length === 0)\r\n    t.ok(CloudEvent.validateEvent(ceDeserialized, { strict: true }).length === 0)\r\n    t.ok(CloudEvent.isCloudEvent(ceDeserialized))\r\n\r\n    // inspect content of deserialized CloudEvent, at least on some attributes\r\n    t.ok(ceDeserialized.time)\r\n    t.ok(V.isDate(ceDeserialized.time))\r\n    t.ok(V.isDateValid(ceDeserialized.time))\r\n    t.ok(V.isDatePast(ceDeserialized.time))\r\n    t.strictSame(ceDeserialized.time.getTime(), commonEventTime.getTime())\r\n    t.notStrictEqual(ceDeserialized.time, commonEventTime)\r\n    t.notEqual(ceDeserialized.time, commonEventTime)\r\n    // console.log(`DEBUG - cloudEvent data: ${T.dumpObject(ceDeserialized.data, 'ceDeserialized.data')}`)\r\n    // console.log(`DEBUG - cloudEvent payload: ${T.dumpObject(ceDeserialized.payload, 'ceDeserialized.payload')}`)\r\n    t.ok(ceDeserialized.data)\r\n    t.ok(V.isObject(ceDeserialized.data))\r\n    t.ok(ceDeserialized.payload)\r\n    t.ok(V.isObject(ceDeserialized.payload))\r\n    // then ensure the value of both are the same ...\r\n    t.strictSame(ceDeserialized.data, ceDeserialized.payload)\r\n    // then ensure they are different object (references) ...\r\n    t.notStrictEqual(ceDeserialized.data, ceDeserialized.payload)\r\n    t.notEqual(ceDeserialized.data, ceDeserialized.payload)\r\n  }\r\n})\r\n\r\n/** @test {CloudEvent} */\r\ntest('deserialize a CloudEvent instance with a non default contenttype and empty/wrong deserialization options, expect error', (t) => {\r\n  t.plan(18)\r\n\r\n  const { CloudEvent, CloudEventValidator: V } = require('../src/') // get references via destructuring\r\n\r\n  {\r\n    const serialized = ceFullOtherContentTypeSerializedJson\r\n    // console.log(`DEBUG - serialized cloudEvent details: serialized = '${serialized}'`)\r\n    t.ok(serialized)\r\n    t.ok(V.isString(serialized))\r\n\r\n    t.throws(function () {\r\n      const ceFullOtherContentTypeDeserialized = CloudEvent.deserializeEvent(serialized)\r\n      assert(ceFullOtherContentTypeDeserialized === null) // never executed\r\n    }, Error, 'Expected exception when deserializing the current CloudEvent instance')\r\n    t.throws(function () {\r\n      const ceFullOtherContentTypeDeserialized = CloudEvent.deserializeEvent(serialized, {\r\n        decoder: 'decoderFromXmlSample' // bad decoder function\r\n      })\r\n      assert(ceFullOtherContentTypeDeserialized === null) // never executed\r\n    }, Error, 'Expected exception when deserializing the current CloudEvent instance')\r\n    t.throws(function () {\r\n      const ceFullOtherContentTypeDeserialized = CloudEvent.deserializeEvent(serialized, {\r\n        decodedData: true // bad decoded data\r\n      })\r\n      assert(ceFullOtherContentTypeDeserialized === null) // never executed\r\n    }, Error, 'Expected exception when deserializing the current CloudEvent instance')\r\n    t.throws(function () {\r\n      const ceFullOtherContentTypeDeserialized = CloudEvent.deserializeEvent(serialized, {\r\n        decodedData: ceDataAsXmlString,\r\n        onlyValid: false\r\n      })\r\n      assert(ceFullOtherContentTypeDeserialized === null) // bad assertion\r\n    }, Error, 'Expected exception due to a bad assertion')\r\n    t.throws(function () {\r\n      const ceFullOtherContentTypeDeserialized = CloudEvent.deserializeEvent(serialized, {\r\n        decodedData: ceDataAsXmlString,\r\n        onlyValid: true\r\n      })\r\n      assert(ceFullOtherContentTypeDeserialized === null) // bad assertion\r\n    }, Error, 'Expected exception due to a bad assertion')\r\n    t.throws(function () {\r\n      const ceFullOtherContentTypeDeserialized = CloudEvent.deserializeEvent(ceFullOtherContentTypeSerializedBadJson, {\r\n        decodedData: ceDataAsXmlString,\r\n        onlyValid: false\r\n      })\r\n      assert(ceFullOtherContentTypeDeserialized === null) // never executed\r\n    }, Error, 'Expected exception when deserializing the current CloudEvent instance')\r\n    t.throws(function () {\r\n      const ceFullOtherContentTypeDeserialized = CloudEvent.deserializeEvent(ceFullOtherContentTypeSerializedBadJson, {\r\n        decodedData: ceDataAsXmlString,\r\n        onlyValid: true\r\n      })\r\n      assert(ceFullOtherContentTypeDeserialized === null) // never executed\r\n    }, Error, 'Expected exception when deserializing the current CloudEvent instance')\r\n  }\r\n\r\n  {\r\n    // the same but with strict mode enabled ...\r\n    const serialized = ceFullOtherContentTypeStrictSerializedJson\r\n    // console.log(`DEBUG - serialized cloudEvent details: serialized = '${serialized}'`)\r\n    t.ok(serialized)\r\n    t.ok(V.isString(serialized))\r\n\r\n    t.throws(function () {\r\n      const ceFullOtherContentTypeDeserialized = CloudEvent.deserializeEvent(serialized, {\r\n        decoder: null,\r\n        decodedData: null\r\n      })\r\n      assert(ceFullOtherContentTypeDeserialized === null) // never executed\r\n    }, Error, 'Expected exception when deserializing the current CloudEvent instance')\r\n    t.throws(function () {\r\n      const ceFullOtherContentTypeDeserialized = CloudEvent.deserializeEvent(serialized, {\r\n        decoder: 'decoderFromXmlSample' // bad decoder function\r\n      })\r\n      assert(ceFullOtherContentTypeDeserialized === null) // never executed\r\n    }, Error, 'Expected exception when deserializing the current CloudEvent instance')\r\n    t.throws(function () {\r\n      const ceFullOtherContentTypeDeserialized = CloudEvent.deserializeEvent(serialized, {\r\n        decodedData: true // bad decoder data\r\n      })\r\n      assert(ceFullOtherContentTypeDeserialized === null) // never executed\r\n    }, Error, 'Expected exception when deserializing the current CloudEvent instance')\r\n    t.throws(function () {\r\n      const ceFullOtherContentTypeDeserialized = CloudEvent.deserializeEvent(serialized, {\r\n        decodedData: ceDataAsXmlString,\r\n        onlyValid: false\r\n      })\r\n      assert(ceFullOtherContentTypeDeserialized === null) // bad assertion\r\n    }, Error, 'Expected exception due to a bad assertion')\r\n    t.throws(function () {\r\n      const ceFullOtherContentTypeDeserialized = CloudEvent.deserializeEvent(serialized, {\r\n        decodedData: ceDataAsXmlString,\r\n        onlyValid: true\r\n      })\r\n      assert(ceFullOtherContentTypeDeserialized === null) // bad assertion\r\n    }, Error, 'Expected exception due to a bad assertion')\r\n    t.throws(function () {\r\n      const ceFullOtherContentTypeDeserialized = CloudEvent.deserializeEvent(ceFullOtherContentTypeStrictSerializedBadJson, {\r\n        decodedData: ceDataAsXmlString,\r\n        onlyValid: false\r\n      })\r\n      assert(ceFullOtherContentTypeDeserialized === null) // never executed\r\n    }, Error, 'Expected exception when deserializing the current CloudEvent instance')\r\n    t.throws(function () {\r\n      const ceFullOtherContentTypeDeserialized = CloudEvent.deserializeEvent(ceFullOtherContentTypeStrictSerializedBadJson, {\r\n        decodedData: ceDataAsXmlString,\r\n        onlyValid: true\r\n      })\r\n      assert(ceFullOtherContentTypeDeserialized === null) // never executed\r\n    }, Error, 'Expected exception when deserializing the current CloudEvent instance')\r\n  }\r\n})\r\n\r\n// sample decoding function, to use in tests here\r\nfunction decoderFromXmlSample (data) {\r\n  // return ceCommonData\r\n  // return data.toString()\r\n  return '<data \"decoded\"=\"Sample\" />'\r\n}\r\n\r\n/** @test {CloudEvent} */\r\ntest('deserialize a CloudEvent instance with a non default contenttype and right deserialization options, expect success', (t) => {\r\n  t.plan(18)\r\n\r\n  const { CloudEvent, CloudEventValidator: V } = require('../src/') // get references via destructuring\r\n  t.ok(V)\r\n  t.ok(decoderFromXmlSample)\r\n  t.ok(V.isFunction(decoderFromXmlSample))\r\n  t.ok(!V.ensureIsFunction(decoderFromXmlSample, 'decoderFromXmlSample')) // no error returned\r\n\r\n  {\r\n    const serialized = ceFullOtherContentTypeSerializedJson\r\n    // console.log(`DEBUG - serialized cloudEvent details: serialized = '${serialized}'`)\r\n    t.ok(serialized)\r\n    t.ok(V.isString(serialized))\r\n\r\n    // test different combinations of deserialization options\r\n    // note that if given, decoder function has priority over decoded data\r\n    const ceFullOtherContentTypeDeserialized1 = CloudEvent.deserializeEvent(serialized, {\r\n      decoder: decoderFromXmlSample\r\n    })\r\n    t.ok(ceFullOtherContentTypeDeserialized1)\r\n    const fixedDecodedData = '<data \"fixed\"=\"decoded\" />'\r\n    const ceFullOtherContentTypeDeserialized2 = CloudEvent.deserializeEvent(serialized, {\r\n      decodedData: fixedDecodedData\r\n    })\r\n    t.ok(ceFullOtherContentTypeDeserialized2)\r\n    const ceFullOtherContentTypeDeserialized3 = CloudEvent.deserializeEvent(serialized, {\r\n      decoder: decoderFromXmlSample,\r\n      // decodedData: undefined\r\n      // decodedData: null\r\n      // decodedData: ceCommonData\r\n      decodedData: fixedDecodedData\r\n    })\r\n    t.ok(ceFullOtherContentTypeDeserialized3)\r\n    const ceFullOtherContentTypeDeserialized4 = CloudEvent.deserializeEvent(serialized, {\r\n      decoder: decoderFromXmlSample,\r\n      decodedData: fixedDecodedData,\r\n      onlyValid: false\r\n    })\r\n    t.ok(ceFullOtherContentTypeDeserialized4)\r\n    const ceFullOtherContentTypeDeserialized5 = CloudEvent.deserializeEvent(serialized, {\r\n      decoder: decoderFromXmlSample,\r\n      decodedData: fixedDecodedData,\r\n      onlyValid: true\r\n    })\r\n    t.ok(ceFullOtherContentTypeDeserialized5)\r\n  }\r\n\r\n  {\r\n    // the same but with strict mode enabled ...\r\n    const serialized = ceFullOtherContentTypeStrictSerializedJson\r\n    // console.log(`DEBUG - serialized cloudEvent details: serialized = '${serialized}'`)\r\n    t.ok(serialized)\r\n    t.ok(V.isString(serialized))\r\n\r\n    // test different combinations of deserialization options\r\n    // note that if given, decoder function has priority over decoded data\r\n    const ceFullOtherContentTypeDeserialized1 = CloudEvent.deserializeEvent(serialized, {\r\n      decoder: decoderFromXmlSample\r\n    })\r\n    t.ok(ceFullOtherContentTypeDeserialized1)\r\n    const fixedDecodedData = '<data \"fixed\"=\"decoded\" />'\r\n    const ceFullOtherContentTypeDeserialized2 = CloudEvent.deserializeEvent(serialized, {\r\n      decodedData: fixedDecodedData\r\n    })\r\n    t.ok(ceFullOtherContentTypeDeserialized2)\r\n    const ceFullOtherContentTypeDeserialized3 = CloudEvent.deserializeEvent(serialized, {\r\n      decoder: decoderFromXmlSample,\r\n      // decodedData: undefined\r\n      // decodedData: null\r\n      // decodedData: ceCommonData\r\n      decodedData: fixedDecodedData\r\n    })\r\n    t.ok(ceFullOtherContentTypeDeserialized3)\r\n    const ceFullOtherContentTypeDeserialized4 = CloudEvent.deserializeEvent(serialized, {\r\n      decoder: decoderFromXmlSample,\r\n      decodedData: fixedDecodedData,\r\n      onlyValid: false\r\n    })\r\n    t.ok(ceFullOtherContentTypeDeserialized4)\r\n    const ceFullOtherContentTypeDeserialized5 = CloudEvent.deserializeEvent(serialized, {\r\n      decoder: decoderFromXmlSample,\r\n      decodedData: fixedDecodedData,\r\n      onlyValid: true\r\n    })\r\n    t.ok(ceFullOtherContentTypeDeserialized5)\r\n  }\r\n})\r\n\r\n/** @test {CloudEvent} */\r\ntest('serialize and deserialize a big CloudEvent instance (more than 64 KB)', (t) => {\r\n  t.plan(55)\r\n\r\n  const { CloudEvent } = require('../src/') // get references via destructuring\r\n  t.ok(CloudEvent)\r\n\r\n  t.ok(ceBigString)\r\n  t.strictSame(ceBigString.length, ceBigStringLength)\r\n\r\n  {\r\n    const ceFull = new CloudEvent('1/full/sample-data-nested/no-strict',\r\n      ceNamespace,\r\n      ceServerUrl,\r\n      { random: ceBigString }, // data\r\n      ceCommonOptions,\r\n      ceCommonExtensions\r\n    )\r\n    assert(ceFull !== null)\r\n    t.ok(ceFull)\r\n    t.ok(ceFull.isValid())\r\n    t.ok(ceFull.validate().length === 0)\r\n    t.ok(ceFull.validate({ strict: false }).length === 0)\r\n    t.ok(ceFull.validate({ strict: true }).length === 0)\r\n    t.ok(CloudEvent.isValidEvent(ceFull))\r\n    t.ok(CloudEvent.validateEvent(ceFull).length === 0)\r\n    t.ok(CloudEvent.validateEvent(ceFull, { strict: false }).length === 0)\r\n    t.ok(CloudEvent.validateEvent(ceFull, { strict: true }).length === 0)\r\n\r\n    // with defaults\r\n    const ceFullSerializedStatic = CloudEvent.serializeEvent(ceFull)\r\n    t.ok(ceFullSerializedStatic)\r\n    const ceFullDeserializedStatic = CloudEvent.deserializeEvent(ceFullSerializedStatic)\r\n    t.ok(ceFullDeserializedStatic)\r\n    const ceFullSerialized = ceFull.serialize()\r\n    t.ok(ceFullSerialized)\r\n    const ceFullDeserialized = CloudEvent.deserializeEvent(ceFullSerialized)\r\n    t.ok(ceFullDeserialized)\r\n    assert(ceFullSerializedStatic === ceFullSerialized)\r\n    t.strictSame(ceFullSerializedStatic, ceFullSerialized)\r\n\r\n    // set some flags\r\n    const ceFullSerializedOnlyValidFalse = CloudEvent.serializeEvent(ceFull, { onlyValid: false, onlyIfLessThan64KB: false })\r\n    t.ok(ceFullSerializedOnlyValidFalse)\r\n    const ceFullDeserializedOnlyValidFalse = CloudEvent.deserializeEvent(ceFullSerializedOnlyValidFalse)\r\n    t.ok(ceFullDeserializedOnlyValidFalse)\r\n    const ceFullSerializedOnlyValidTrue = CloudEvent.serializeEvent(ceFull, { onlyValid: true, onlyIfLessThan64KB: false })\r\n    t.ok(ceFullSerializedOnlyValidTrue)\r\n    const ceFullDeserializedOnlyValidTrue = CloudEvent.deserializeEvent(ceFullSerializedOnlyValidTrue)\r\n    t.ok(ceFullDeserializedOnlyValidTrue)\r\n    t.strictSame(ceFullSerializedOnlyValidFalse, ceFullSerializedOnlyValidTrue)\r\n\r\n    // enable the flag to return the serialized string only if it's less than 64 KB, expected errors here\r\n    t.throws(function () {\r\n      const serialized = CloudEvent.serializeEvent(ceFull, { onlyValid: false, onlyIfLessThan64KB: true })\r\n      assert(serialized === null) // never executed\r\n    }, Error, 'Expected exception when serializing a Cloudevent bigger than 64 KB (with the flag to forbid it enabled)')\r\n    t.throws(function () {\r\n      const serialized = CloudEvent.serializeEvent(ceFull, { onlyValid: true, onlyIfLessThan64KB: true })\r\n      assert(serialized === null) // never executed\r\n    }, Error, 'Expected exception when serializing a Cloudevent bigger than 64 KB (with the flag to forbid it enabled)')\r\n    // deserialize instances just serialized, but now with the flag enabled, so expect errors here\r\n    t.throws(function () {\r\n      const deserialized = CloudEvent.deserializeEvent(ceFullSerializedOnlyValidFalse, { onlyValid: false, onlyIfLessThan64KB: true })\r\n      assert(deserialized === null) // never executed\r\n    }, Error, 'Expected exception when deserializing a Cloudevent bigger than 64 KB (with the flag to forbid it enabled)')\r\n    t.throws(function () {\r\n      const deserialized = CloudEvent.deserializeEvent(ceFullSerializedOnlyValidTrue, { onlyValid: true, onlyIfLessThan64KB: true })\r\n      assert(deserialized === null) // never executed\r\n    }, Error, 'Expected exception when deserializing a Cloudevent bigger than 64 KB (with the flag to forbid it enabled)')\r\n  }\r\n\r\n  {\r\n    const ceFullBadBig = new CloudEvent(null,\r\n      ceNamespace,\r\n      ceServerUrl,\r\n      { random: ceBigString }, // data\r\n      ceCommonOptions,\r\n      ceCommonExtensions\r\n    )\r\n    assert(ceFullBadBig !== null)\r\n    t.ok(ceFullBadBig)\r\n    const serialized = CloudEvent.serializeEvent(ceFullBadBig, { onlyValid: false, onlyIfLessThan64KB: false })\r\n    t.throws(function () {\r\n      const deserialized = CloudEvent.deserializeEvent(serialized, { onlyValid: true })\r\n      assert(deserialized === null) // never executed\r\n    }, Error, 'Expected exception when deserializing a not valid big Cloudevent, with related flag enabled')\r\n    t.throws(function () {\r\n      const deserialized = CloudEvent.deserializeEvent(serialized, { onlyValid: false, onlyIfLessThan64KB: true })\r\n      assert(deserialized === null) // never executed\r\n    }, Error, 'Expected exception when deserializing a not valid big Cloudevent, with related flag enabled')\r\n  }\r\n\r\n  {\r\n    // the same but with strict mode enabled ...\r\n    const ceFullStrict = new CloudEvent('1/full/sample-data-nested/strict',\r\n      ceNamespace,\r\n      ceServerUrl,\r\n      { random: ceBigString }, // data\r\n      ceCommonOptionsStrict,\r\n      ceCommonExtensions\r\n    )\r\n    assert(ceFullStrict !== null)\r\n    t.ok(ceFullStrict)\r\n    t.ok(ceFullStrict.isValid())\r\n    t.ok(ceFullStrict.validate().length === 0)\r\n    t.ok(ceFullStrict.validate({ strict: false }).length === 0)\r\n    t.ok(ceFullStrict.validate({ strict: true }).length === 0)\r\n    t.ok(CloudEvent.isValidEvent(ceFullStrict))\r\n    t.ok(CloudEvent.validateEvent(ceFullStrict).length === 0)\r\n    t.ok(CloudEvent.validateEvent(ceFullStrict, { strict: false }).length === 0)\r\n    t.ok(CloudEvent.validateEvent(ceFullStrict, { strict: true }).length === 0)\r\n\r\n    // with defaults\r\n    const ceFullSerializedStatic = CloudEvent.serializeEvent(ceFullStrict)\r\n    t.ok(ceFullSerializedStatic)\r\n    const ceFullDeserializedStatic = CloudEvent.deserializeEvent(ceFullSerializedStatic)\r\n    t.ok(ceFullDeserializedStatic)\r\n    const ceFullSerialized = ceFullStrict.serialize()\r\n    t.ok(ceFullSerialized)\r\n    const ceFullDeserialized = CloudEvent.deserializeEvent(ceFullSerialized)\r\n    t.ok(ceFullDeserialized)\r\n    assert(ceFullSerializedStatic === ceFullSerialized)\r\n    t.strictSame(ceFullSerializedStatic, ceFullSerialized)\r\n\r\n    // set some flags\r\n    const ceFullSerializedOnlyValidFalse = CloudEvent.serializeEvent(ceFullStrict, { onlyValid: false, onlyIfLessThan64KB: false })\r\n    t.ok(ceFullSerializedOnlyValidFalse)\r\n    const ceFullDeserializedOnlyValidFalse = CloudEvent.deserializeEvent(ceFullSerializedOnlyValidFalse)\r\n    t.ok(ceFullDeserializedOnlyValidFalse)\r\n    const ceFullSerializedOnlyValidTrue = CloudEvent.serializeEvent(ceFullStrict, { onlyValid: true, onlyIfLessThan64KB: false })\r\n    t.ok(ceFullSerializedOnlyValidTrue)\r\n    const ceFullDeserializedOnlyValidTrue = CloudEvent.deserializeEvent(ceFullSerializedOnlyValidTrue)\r\n    t.ok(ceFullDeserializedOnlyValidTrue)\r\n    t.strictSame(ceFullSerializedOnlyValidFalse, ceFullSerializedOnlyValidTrue)\r\n\r\n    // enable the flag to return the serialized string only if it's less than 64 KB, expected errors here\r\n    t.throws(function () {\r\n      const serialized = CloudEvent.serializeEvent(ceFullStrict, { onlyValid: false, onlyIfLessThan64KB: true })\r\n      assert(serialized === null) // never executed\r\n    }, Error, 'Expected exception when serializing a Cloudevent bigger than 64 KB (with the flag to forbid it enabled)')\r\n    t.throws(function () {\r\n      const serialized = CloudEvent.serializeEvent(ceFullStrict, { onlyValid: true, onlyIfLessThan64KB: true })\r\n      assert(serialized === null) // never executed\r\n    }, Error, 'Expected exception when serializing a Cloudevent bigger than 64 KB (with the flag to forbid it enabled)')\r\n    // deserialize instances just serialized, but now with the flag enabled, so expect errors here\r\n    t.throws(function () {\r\n      const deserialized = CloudEvent.deserializeEvent(ceFullSerializedOnlyValidFalse, { onlyValid: false, onlyIfLessThan64KB: true })\r\n      assert(deserialized === null) // never executed\r\n    }, Error, 'Expected exception when deserializing a Cloudevent bigger than 64 KB (with the flag to forbid it enabled)')\r\n    t.throws(function () {\r\n      const deserialized = CloudEvent.deserializeEvent(ceFullSerializedOnlyValidTrue, { onlyValid: true, onlyIfLessThan64KB: true })\r\n      assert(deserialized === null) // never executed\r\n    }, Error, 'Expected exception when deserializing a Cloudevent bigger than 64 KB (with the flag to forbid it enabled)')\r\n  }\r\n\r\n  {\r\n    // the same but with strict mode enabled ...\r\n    const ceFullBadBigStrict = new CloudEvent('1/full/sample-data/strict',\r\n      ceNamespace,\r\n      ceServerUrl,\r\n      { random: ceBigString }, // data\r\n      ceCommonOptionsStrict,\r\n      ceCommonExtensions\r\n    )\r\n    assert(ceFullBadBigStrict !== null)\r\n    t.ok(ceFullBadBigStrict)\r\n    const serialized = CloudEvent.serializeEvent(ceFullBadBigStrict, { onlyValid: false, onlyIfLessThan64KB: false })\r\n    ceFullBadBigStrict.id = null // remove some mandatory attribute now, to let deserialization fail\r\n    t.throws(function () {\r\n      const deserialized = CloudEvent.deserializeEvent(serialized, { onlyValid: true })\r\n      assert(deserialized === null) // never executed\r\n    }, Error, 'Expected exception when deserializing a not valid big Cloudevent, with related flag enabled')\r\n    t.throws(function () {\r\n      const deserialized = CloudEvent.deserializeEvent(serialized, { onlyValid: false, onlyIfLessThan64KB: true })\r\n      assert(deserialized === null) // never executed\r\n    }, Error, 'Expected exception when deserializing a not valid big Cloudevent, with related flag enabled')\r\n  }\r\n})\r\n\r\n// sample encoding function, to use in tests here\r\nfunction encoderBigSample () {\r\n  return `<data encoder=\"${ceBigString}\" />`\r\n}\r\n\r\n// sample decoding function, to use in tests here\r\nfunction decoderBigSample () {\r\n  return `<data decoded=\"${ceBigString}\" />`\r\n}\r\n\r\n/** @test {CloudEvent} */\r\ntest('serialize and deserialize a big CloudEvent instance with a non default contenttype (more than 64 KB)', (t) => {\r\n  t.plan(54)\r\n\r\n  const { CloudEvent } = require('../src/') // get references via destructuring\r\n  t.ok(CloudEvent)\r\n\r\n  t.ok(ceBigString)\r\n  t.strictSame(ceBigString.length, ceBigStringLength)\r\n\r\n  {\r\n    // create an instance with non default contenttype (other options default): expected success ...\r\n    // when I try to serialize specifying right serialization options, expect success ...\r\n    const ceFullOtherContentType = new CloudEvent('1/non-default-contenttype/sample-data/no-strict',\r\n      ceNamespace,\r\n      ceServerUrl,\r\n      { random: ceBigString }, // data\r\n      {\r\n        ...ceCommonOptions,\r\n        datacontenttype: 'application/xml'\r\n      },\r\n      ceCommonExtensions\r\n    )\r\n    assert(ceFullOtherContentType !== null)\r\n    t.ok(ceFullOtherContentType)\r\n    t.ok(ceFullOtherContentType.isValid())\r\n    // test different combinations of serialization options\r\n    // note that if given, encoder function has priority over encoded data\r\n    const cceFullOtherContentTypeSerialized1 = ceFullOtherContentType.serialize({\r\n      encoder: encoderBigSample\r\n    })\r\n    t.ok(cceFullOtherContentTypeSerialized1)\r\n    t.ok(CloudEvent.isValidEvent(ceFullOtherContentType))\r\n    const cceFullOtherContentTypeSerialized2 = ceFullOtherContentType.serialize({\r\n      encodedData: `<data \"random\"=\"${ceBigString}\" />`\r\n    })\r\n    t.ok(cceFullOtherContentTypeSerialized2)\r\n    t.ok(CloudEvent.isValidEvent(ceFullOtherContentType))\r\n    const fixedEncodedData = `<data \"fixed\"=\"${ceBigString}\" />`\r\n    const cceFullOtherContentTypeSerialized3 = ceFullOtherContentType.serialize({\r\n      encoder: encoderBigSample,\r\n      encodedData: fixedEncodedData\r\n    })\r\n    t.ok(cceFullOtherContentTypeSerialized3)\r\n    t.ok(CloudEvent.isValidEvent(ceFullOtherContentType))\r\n    const cceFullOtherContentTypeSerialized4 = CloudEvent.serializeEvent(ceFullOtherContentType, {\r\n      encoder: encoderBigSample,\r\n      encodedData: fixedEncodedData,\r\n      onlyValid: false\r\n    })\r\n    t.ok(cceFullOtherContentTypeSerialized4)\r\n    t.ok(CloudEvent.isValidEvent(ceFullOtherContentType))\r\n    const cceFullOtherContentTypeSerialized5 = CloudEvent.serializeEvent(ceFullOtherContentType, {\r\n      encoder: encoderBigSample,\r\n      encodedData: fixedEncodedData,\r\n      onlyValid: true\r\n    })\r\n    t.ok(cceFullOtherContentTypeSerialized5)\r\n    t.ok(CloudEvent.isValidEvent(ceFullOtherContentType))\r\n\r\n    // set some flags\r\n    const ceFullSerializedOnlyValidFalse = CloudEvent.serializeEvent(ceFullOtherContentType, {\r\n      encoder: encoderBigSample, onlyValid: false, onlyIfLessThan64KB: false\r\n    })\r\n    t.ok(ceFullSerializedOnlyValidFalse)\r\n    const ceFullDeserializedOnlyValidFalse = CloudEvent.deserializeEvent(ceFullSerializedOnlyValidFalse, {\r\n      decoder: decoderBigSample\r\n    })\r\n    t.ok(ceFullDeserializedOnlyValidFalse)\r\n    const ceFullSerializedOnlyValidTrue = CloudEvent.serializeEvent(ceFullOtherContentType, {\r\n      encoder: encoderBigSample, onlyValid: true, onlyIfLessThan64KB: false\r\n    })\r\n    t.ok(ceFullSerializedOnlyValidTrue)\r\n    const ceFullDeserializedOnlyValidTrue = CloudEvent.deserializeEvent(ceFullSerializedOnlyValidTrue, {\r\n      decoder: decoderBigSample\r\n    })\r\n    t.ok(ceFullDeserializedOnlyValidTrue)\r\n    t.strictSame(ceFullSerializedOnlyValidFalse, ceFullSerializedOnlyValidTrue)\r\n\r\n    // enable the flag to return the serialized string only if it's less than 64 KB, expected errors here\r\n    t.throws(function () {\r\n      const serialized = CloudEvent.serializeEvent(ceFullOtherContentType, {\r\n        encoder: encoderBigSample, onlyValid: false, onlyIfLessThan64KB: true\r\n      })\r\n      assert(serialized === null) // never executed\r\n    }, Error, 'Expected exception when serializing a Cloudevent bigger than 64 KB (with the flag to forbid it enabled)')\r\n    t.throws(function () {\r\n      const serialized = CloudEvent.serializeEvent(ceFullOtherContentType, {\r\n        encoder: encoderBigSample, onlyValid: true, onlyIfLessThan64KB: true\r\n      })\r\n      assert(serialized === null) // never executed\r\n    }, Error, 'Expected exception when serializing a Cloudevent bigger than 64 KB (with the flag to forbid it enabled)')\r\n    // deserialize instances just serialized, but now with the flag enabled, so expect errors here\r\n    t.throws(function () {\r\n      const deserialized = CloudEvent.deserializeEvent(ceFullSerializedOnlyValidFalse, {\r\n        decoder: decoderBigSample, onlyValid: false, onlyIfLessThan64KB: true\r\n      })\r\n      assert(deserialized === null) // never executed\r\n    }, Error, 'Expected exception when deserializing a Cloudevent bigger than 64 KB (with the flag to forbid it enabled)')\r\n    t.throws(function () {\r\n      const deserialized = CloudEvent.deserializeEvent(ceFullSerializedOnlyValidTrue, {\r\n        decoder: decoderBigSample, onlyValid: true, onlyIfLessThan64KB: true\r\n      })\r\n      assert(deserialized === null) // never executed\r\n    }, Error, 'Expected exception when deserializing a Cloudevent bigger than 64 KB (with the flag to forbid it enabled)')\r\n  }\r\n\r\n  {\r\n    // bad because no id\r\n    const ceFullBadBig = new CloudEvent(null,\r\n      ceNamespace,\r\n      ceServerUrl,\r\n      { random: ceBigString }, // data\r\n      {\r\n        ...ceCommonOptions,\r\n        datacontenttype: 'application/xml'\r\n      },\r\n      ceCommonExtensions\r\n    )\r\n    assert(ceFullBadBig !== null)\r\n    t.ok(ceFullBadBig)\r\n    t.ok(!ceFullBadBig.isValid())\r\n    const serialized = CloudEvent.serializeEvent(ceFullBadBig, {\r\n      encoder: encoderBigSample, onlyValid: false, onlyIfLessThan64KB: false\r\n    })\r\n    t.throws(function () {\r\n      const deserialized = CloudEvent.deserializeEvent(serialized, {\r\n        decoder: decoderBigSample, onlyValid: true\r\n      })\r\n      assert(deserialized === null) // never executed\r\n    }, Error, 'Expected exception when deserializing a not valid big Cloudevent, with related flag enabled')\r\n    t.throws(function () {\r\n      const deserialized = CloudEvent.deserializeEvent(serialized, {\r\n        decoder: decoderBigSample, onlyValid: false, onlyIfLessThan64KB: true\r\n      })\r\n      assert(deserialized === null) // never executed\r\n    }, Error, 'Expected exception when deserializing a not valid big Cloudevent, with related flag enabled')\r\n  }\r\n\r\n  {\r\n    // the same but with strict mode enabled ...\r\n    // bad because bad data type\r\n    const ceFullOtherContentTypeBadStrict = new CloudEvent('1/non-default-contenttype/bad-data/strict',\r\n      ceNamespace,\r\n      ceServerUrl,\r\n      1234567890, // data\r\n      // Symbol('test-no-object-nor-string'), // data\r\n      {\r\n        ...ceCommonOptionsStrict,\r\n        datacontenttype: 'application/xml'\r\n      },\r\n      ceCommonExtensions\r\n    )\r\n    assert(ceFullOtherContentTypeBadStrict !== null)\r\n    t.ok(ceFullOtherContentTypeBadStrict)\r\n    t.ok(!ceFullOtherContentTypeBadStrict.isValid())\r\n\r\n    const ceFullOtherContentTypeStrict = new CloudEvent('1/non-default-contenttype/sample-data/strict',\r\n      ceNamespace,\r\n      ceServerUrl,\r\n      ceBigString, // data\r\n      {\r\n        ...ceCommonOptionsStrict,\r\n        datacontenttype: 'application/xml'\r\n      },\r\n      ceCommonExtensions\r\n    )\r\n    assert(ceFullOtherContentTypeStrict !== null)\r\n    t.ok(ceFullOtherContentTypeStrict)\r\n    t.ok(ceFullOtherContentTypeStrict.isValid())\r\n    // test different combinations of serialization options\r\n    // note that if given, encoder function has priority over encoded data\r\n    const cceFullOtherContentTypeSerialized1 = ceFullOtherContentTypeStrict.serialize({\r\n      encoder: encoderBigSample\r\n    })\r\n    t.ok(cceFullOtherContentTypeSerialized1)\r\n    t.ok(CloudEvent.isValidEvent(ceFullOtherContentTypeStrict))\r\n    const cceFullOtherContentTypeSerialized2 = ceFullOtherContentTypeStrict.serialize({\r\n      encodedData: `<data \"random\"=\"${ceBigString}\" />`\r\n    })\r\n    t.ok(cceFullOtherContentTypeSerialized2)\r\n    t.ok(CloudEvent.isValidEvent(ceFullOtherContentTypeStrict))\r\n    const fixedEncodedData = `<data \"fixed\"=\"${ceBigString}\" />`\r\n    const cceFullOtherContentTypeSerialized3 = ceFullOtherContentTypeStrict.serialize({\r\n      encoder: encoderBigSample,\r\n      encodedData: fixedEncodedData\r\n    })\r\n    t.ok(cceFullOtherContentTypeSerialized3)\r\n    t.ok(CloudEvent.isValidEvent(ceFullOtherContentTypeStrict))\r\n    const cceFullOtherContentTypeSerialized4 = CloudEvent.serializeEvent(ceFullOtherContentTypeStrict, {\r\n      encoder: encoderBigSample,\r\n      encodedData: fixedEncodedData,\r\n      onlyValid: false\r\n    })\r\n    t.ok(cceFullOtherContentTypeSerialized4)\r\n    t.ok(CloudEvent.isValidEvent(ceFullOtherContentTypeStrict))\r\n    const cceFullOtherContentTypeSerialized5 = CloudEvent.serializeEvent(ceFullOtherContentTypeStrict, {\r\n      encoder: encoderBigSample,\r\n      encodedData: fixedEncodedData,\r\n      onlyValid: true\r\n    })\r\n    t.ok(cceFullOtherContentTypeSerialized5)\r\n    t.ok(CloudEvent.isValidEvent(ceFullOtherContentTypeStrict))\r\n\r\n    // set some flags\r\n    const ceFullSerializedOnlyValidFalse = CloudEvent.serializeEvent(ceFullOtherContentTypeStrict, {\r\n      encoder: encoderBigSample, onlyValid: false, onlyIfLessThan64KB: false\r\n    })\r\n    t.ok(ceFullSerializedOnlyValidFalse)\r\n    const ceFullDeserializedOnlyValidFalse = CloudEvent.deserializeEvent(ceFullSerializedOnlyValidFalse, {\r\n      decoder: decoderBigSample\r\n    })\r\n    t.ok(ceFullDeserializedOnlyValidFalse)\r\n    const ceFullSerializedOnlyValidTrue = CloudEvent.serializeEvent(ceFullOtherContentTypeStrict, {\r\n      encoder: encoderBigSample, onlyValid: true, onlyIfLessThan64KB: false\r\n    })\r\n    t.ok(ceFullSerializedOnlyValidTrue)\r\n    const ceFullDeserializedOnlyValidTrue = CloudEvent.deserializeEvent(ceFullSerializedOnlyValidTrue, {\r\n      decoder: decoderBigSample\r\n    })\r\n    t.ok(ceFullDeserializedOnlyValidTrue)\r\n    t.strictSame(ceFullSerializedOnlyValidFalse, ceFullSerializedOnlyValidTrue)\r\n\r\n    // enable the flag to return the serialized string only if it's less than 64 KB, expected errors here\r\n    t.throws(function () {\r\n      const serialized = CloudEvent.serializeEvent(ceFullOtherContentTypeStrict, {\r\n        encoder: encoderBigSample, onlyValid: false, onlyIfLessThan64KB: true\r\n      })\r\n      assert(serialized === null) // never executed\r\n    }, Error, 'Expected exception when serializing a Cloudevent bigger than 64 KB (with the flag to forbid it enabled)')\r\n    t.throws(function () {\r\n      const serialized = CloudEvent.serializeEvent(ceFullOtherContentTypeStrict, {\r\n        encoder: encoderBigSample, onlyValid: true, onlyIfLessThan64KB: true\r\n      })\r\n      assert(serialized === null) // never executed\r\n    }, Error, 'Expected exception when serializing a Cloudevent bigger than 64 KB (with the flag to forbid it enabled)')\r\n    // deserialize instances just serialized, but now with the flag enabled, so expect errors here\r\n    t.throws(function () {\r\n      const deserialized = CloudEvent.deserializeEvent(ceFullSerializedOnlyValidFalse, {\r\n        decoder: decoderBigSample, onlyValid: false, onlyIfLessThan64KB: true\r\n      })\r\n      assert(deserialized === null) // never executed\r\n    }, Error, 'Expected exception when deserializing a Cloudevent bigger than 64 KB (with the flag to forbid it enabled)')\r\n    t.throws(function () {\r\n      const deserialized = CloudEvent.deserializeEvent(ceFullSerializedOnlyValidTrue, {\r\n        decoder: decoderBigSample, onlyValid: true, onlyIfLessThan64KB: true\r\n      })\r\n      assert(deserialized === null) // never executed\r\n    }, Error, 'Expected exception when deserializing a Cloudevent bigger than 64 KB (with the flag to forbid it enabled)')\r\n  }\r\n\r\n  {\r\n    const ceFullBadBigStrict = new CloudEvent('1/full/sample-data/strict',\r\n      ceNamespace,\r\n      ceServerUrl,\r\n      { random: ceBigString }, // data\r\n      {\r\n        ...ceCommonOptionsStrict,\r\n        datacontenttype: 'application/xml'\r\n      },\r\n      ceCommonExtensions\r\n    )\r\n    assert(ceFullBadBigStrict !== null)\r\n    t.ok(ceFullBadBigStrict)\r\n    const serialized = CloudEvent.serializeEvent(ceFullBadBigStrict, {\r\n      encoder: encoderBigSample, onlyValid: false, onlyIfLessThan64KB: false\r\n    })\r\n    ceFullBadBigStrict.id = null // remove some mandatory attribute now, to let deserialization fail\r\n    t.throws(function () {\r\n      const deserialized = CloudEvent.deserializeEvent(serialized, {\r\n        decoder: decoderBigSample, onlyValid: true\r\n      })\r\n      assert(deserialized === null) // never executed\r\n    }, Error, 'Expected exception when deserializing a not valid big Cloudevent, with related flag enabled')\r\n    t.throws(function () {\r\n      const deserialized = CloudEvent.deserializeEvent(serialized, {\r\n        decoder: decoderBigSample, onlyValid: false, onlyIfLessThan64KB: true\r\n      })\r\n      assert(deserialized === null) // never executed\r\n    }, Error, 'Expected exception when deserializing a not valid big Cloudevent, with related flag enabled')\r\n  }\r\n})\r\n\r\n/** @test {CloudEvent} */\r\ntest('create and deserialize some CloudEvent instances with datacontentencoding specified, and ensure they are right', (t) => {\r\n  t.plan(120)\r\n\r\n  const { CloudEvent, CloudEventValidator: V } = require('../src/')\r\n  // t.ok(CloudEvent)\r\n\r\n  const ceOptionsWithDataEncoding = { ...ceCommonOptions, datacontentencoding: 'Base64' }\r\n  const ceOptionsWithDataEncodingNotSupported = { ...ceCommonOptions, datacontentencoding: 'Custom encoding' }\r\n  const ceDataAsString = 'Hello World, 2019'\r\n  const ceDataEncoded = 'SGVsbG8gV29ybGQsIDIwMTk='\r\n\r\n  {\r\n    const ceFull = new CloudEvent('1/full/sample-data-nested/no-strict',\r\n      ceNamespace,\r\n      ceServerUrl,\r\n      ceDataAsString, // data\r\n      ceOptionsWithDataEncoding,\r\n      ceCommonExtensions\r\n    )\r\n    t.ok(ceFull)\r\n    t.ok(CloudEvent.isValidEvent(ceFull, { strict: false }))\r\n    t.ok(CloudEvent.isValidEvent(ceFull, { strict: true }))\r\n    t.strictSame(CloudEvent.validateEvent(ceFull, { strict: false }).length, 0)\r\n    t.strictSame(CloudEvent.validateEvent(ceFull, { strict: true }).length, 0)\r\n    t.strictSame(ceFull.data, ceDataAsString)\r\n    t.notStrictSame(ceFull.data, ceDataEncoded)\r\n    t.strictSame(T.stringToBase64(ceDataAsString), ceDataEncoded)\r\n    t.strictSame(T.stringFromBase64(T.stringToBase64(ceDataAsString)), ceDataAsString)\r\n\r\n    const ceFullSerializedStatic = CloudEvent.serializeEvent(ceFull)\r\n    t.ok(ceFullSerializedStatic)\r\n    const ceFullSerialized = ceFull.serialize()\r\n    t.ok(ceFullSerialized)\r\n    t.strictSame(ceFullSerializedStatic, ceFullSerialized)\r\n    const ceSerialize = CloudEvent.serializeEvent\r\n    t.ok(ceSerialize)\r\n    const ceFullSerializedFunction = ceSerialize(ceFull)\r\n    t.ok(ceFullSerializedFunction)\r\n    t.strictSame(ceFullSerializedFunction, ceFullSerializedStatic)\r\n    t.strictSame(ceFullSerializedFunction, ceFullSerialized)\r\n    const ceFullSerializedOnlyValidFalse = ceSerialize(ceFull, { onlyValid: false })\r\n    t.ok(ceFullSerializedOnlyValidFalse)\r\n    const ceFullSerializedOnlyValidTrue = ceSerialize(ceFull, { onlyValid: true })\r\n    t.ok(ceFullSerializedOnlyValidTrue)\r\n\r\n    const ceDeserialized = CloudEvent.deserializeEvent(ceFullSerializedStatic)\r\n    // console.log(`DEBUG - cloudEvent details: ${T.dumpObject(ceDeserialized, 'ceDeserialized')}`)\r\n    // console.log(`DEBUG - cloudEvent validation: ${ceDeserialized.validate()}`)\r\n    // console.log(`DEBUG - cloudEvent validation (strict): ${ceDeserialized.validate({ strict: true })}`)\r\n    t.ok(ceDeserialized)\r\n    t.ok(V.isClass(ceDeserialized, CloudEvent))\r\n    t.ok(ceDeserialized.isValid())\r\n    t.ok(ceDeserialized.validate().length === 0)\r\n    t.ok(ceDeserialized.validate({ strict: false }).length === 0)\r\n    t.ok(ceDeserialized.validate({ strict: true }).length === 0)\r\n    t.ok(CloudEvent.isValidEvent(ceDeserialized))\r\n    t.ok(CloudEvent.validateEvent(ceDeserialized).length === 0)\r\n    t.ok(CloudEvent.validateEvent(ceDeserialized, { strict: false }).length === 0)\r\n    t.ok(CloudEvent.validateEvent(ceDeserialized, { strict: true }).length === 0)\r\n    t.ok(CloudEvent.isCloudEvent(ceDeserialized))\r\n\r\n    // inspect content of deserialized CloudEvent, at least on some attributes\r\n    t.ok(ceDeserialized.time)\r\n    t.ok(V.isDate(ceDeserialized.time))\r\n    t.ok(V.isDateValid(ceDeserialized.time))\r\n    t.ok(V.isDatePast(ceDeserialized.time))\r\n    t.strictSame(ceDeserialized.time.getTime(), commonEventTime.getTime())\r\n    t.notStrictEqual(ceDeserialized.time, commonEventTime)\r\n    t.notEqual(ceDeserialized.time, commonEventTime)\r\n    // console.log(`DEBUG - cloudEvent data: ${T.dumpObject(ceDeserialized.data, 'ceDeserialized.data')}`)\r\n    // console.log(`DEBUG - cloudEvent payload: ${T.dumpObject(ceDeserialized.payload, 'ceDeserialized.payload')}`)\r\n    t.ok(ceDeserialized.data)\r\n    t.ok(V.isString(ceDeserialized.data))\r\n    t.ok(ceDeserialized.payload)\r\n    t.ok(V.isString(ceDeserialized.payload))\r\n    // then ensure the value of both are the same ...\r\n    t.strictSame(ceDeserialized.data, ceDeserialized.payload)\r\n    // and that they are the same of initial value ...\r\n    t.strictSame(ceDeserialized.data, ceFull.data)\r\n    t.notStrictSame(ceDeserialized.data, ceDataEncoded)\r\n    // then ensure they are different object (references) ...\r\n    // not needed here because is a string, and payload returns a copy of it, so comparison here will be equals ...\r\n\r\n    {\r\n      const serialized = ceFullSerializedStatic\r\n      // console.log(`DEBUG - serialized cloudEvent details: serialized = '${serialized}'`)\r\n      t.ok(serialized)\r\n      t.ok(V.isString(serialized))\r\n      // some checks on serialized instance\r\n      const ceFullDeserializedJSON = JSON.parse(ceFullSerializedStatic) // note that some fields (like dates) will be different when deserialized in this way ...\r\n      ceFullDeserializedJSON.time = commonEventTime // quick fix for the Date/timestamp attribute in the deserialized object\r\n      // ceFullDeserializedJSON.datacontentencoding = undefined // quick fix for this not so common attribute in the deserialized object\r\n      // console.log(`DEBUG - deserialized cloudEvent: data = '${ceFullDeserializedJSON.data}'`)\r\n      // next tests are so because here deserialization is done with standard JSON, and not with ce specific method ...\r\n      t.notStrictSame(ceFullDeserializedJSON, ceFull)\r\n      t.notStrictSame(ceFullDeserializedJSON.data, ceFull.data)\r\n      t.strictSame(ceFullDeserializedJSON.data, ceDataEncoded)\r\n    }\r\n    {\r\n      // test with not supported data (not a string representation)\r\n      const serialized = ceFullSerializedStatic.replace(ceDataEncoded, '{}')\r\n      // console.log(`DEBUG - serialized cloudEvent details: serialized = '${serialized}'`)\r\n      // some checks on serialized instance, but using deserialization methods\r\n      t.throws(function () {\r\n        const ceDeserialized = CloudEvent.deserializeEvent(serialized)\r\n        assert(ceDeserialized === undefined) // never executed\r\n      }, Error, 'Expected exception when creating a CloudEvent with datacontentencoding set and data not a string')\r\n    }\r\n    {\r\n      // test with a not supported datacontentencoding\r\n      // update serialized with bad data\r\n      const serialized = ceFullSerializedStatic.replace('Base64', 'Custom encoding')\r\n      // console.log(`DEBUG - serialized cloudEvent details: serialized = '${serialized}'`)\r\n      // some checks on serialized instance, but using deserialization methods\r\n      t.throws(function () {\r\n        const ceDeserialized = CloudEvent.deserializeEvent(serialized)\r\n        assert(ceDeserialized === undefined) // never executed\r\n      }, Error, 'Expected exception when creating a CloudEvent with datacontentencoding not supported')\r\n    }\r\n    {\r\n      // test with a not supported datacontentencoding\r\n      const ceFull = new CloudEvent('1/full/sample-data-nested/no-strict',\r\n        ceNamespace,\r\n        ceServerUrl,\r\n        ceDataAsString, // data\r\n        ceOptionsWithDataEncodingNotSupported,\r\n        ceCommonExtensions\r\n      )\r\n      t.ok(ceFull)\r\n      t.ok(CloudEvent.isValidEvent(ceFull, { strict: false }))\r\n      t.ok(CloudEvent.isValidEvent(ceFull, { strict: true }))\r\n      t.strictSame(CloudEvent.validateEvent(ceFull, { strict: false }).length, 0)\r\n      t.strictSame(CloudEvent.validateEvent(ceFull, { strict: true }).length, 0)\r\n      t.strictSame(ceFull.data, ceDataAsString)\r\n      t.notStrictSame(ceFull.data, ceDataEncoded)\r\n      t.strictSame(T.stringToBase64(ceDataAsString), ceDataEncoded)\r\n      t.strictSame(T.stringFromBase64(T.stringToBase64(ceDataAsString)), ceDataAsString)\r\n      const ceFullSerializedStatic = CloudEvent.serializeEvent(ceFull)\r\n      t.ok(ceFullSerializedStatic)\r\n    }\r\n  }\r\n\r\n  {\r\n    // the same but with strict mode enabled ...\r\n    const ceFullStrict = new CloudEvent('1/full/sample-data-nested/strict',\r\n      ceNamespace,\r\n      ceServerUrl,\r\n      ceDataAsString, // data\r\n      { ...ceOptionsWithDataEncoding, strict: true },\r\n      ceCommonExtensions\r\n    )\r\n    t.ok(ceFullStrict)\r\n    t.ok(CloudEvent.isValidEvent(ceFullStrict, { strict: false }))\r\n    t.ok(CloudEvent.isValidEvent(ceFullStrict, { strict: true }))\r\n    t.strictSame(CloudEvent.validateEvent(ceFullStrict, { strict: false }).length, 0)\r\n    t.strictSame(CloudEvent.validateEvent(ceFullStrict, { strict: true }).length, 0)\r\n    t.strictSame(ceFullStrict.data, ceDataAsString)\r\n    t.notStrictSame(ceFullStrict.data, ceDataEncoded)\r\n    t.strictSame(T.stringToBase64(ceDataAsString), ceDataEncoded)\r\n    t.strictSame(T.stringFromBase64(T.stringToBase64(ceDataAsString)), ceDataAsString)\r\n\r\n    const ceFullSerializedStatic = CloudEvent.serializeEvent(ceFullStrict)\r\n    t.ok(ceFullSerializedStatic)\r\n    const ceFullSerialized = ceFullStrict.serialize()\r\n    t.ok(ceFullSerialized)\r\n    t.strictSame(ceFullSerializedStatic, ceFullSerialized)\r\n    const ceSerialize = CloudEvent.serializeEvent\r\n    t.ok(ceSerialize)\r\n    const ceFullSerializedFunction = ceSerialize(ceFullStrict)\r\n    t.ok(ceFullSerializedFunction)\r\n    t.strictSame(ceFullSerializedFunction, ceFullSerializedStatic)\r\n    t.strictSame(ceFullSerializedFunction, ceFullSerialized)\r\n    const ceFullSerializedOnlyValidFalse = ceSerialize(ceFullStrict, { onlyValid: false })\r\n    t.ok(ceFullSerializedOnlyValidFalse)\r\n    const ceFullSerializedOnlyValidTrue = ceSerialize(ceFullStrict, { onlyValid: true })\r\n    t.ok(ceFullSerializedOnlyValidTrue)\r\n\r\n    const ceDeserialized = CloudEvent.deserializeEvent(ceFullSerializedStatic)\r\n    // console.log(`DEBUG - cloudEvent details: ${T.dumpObject(ceDeserialized, 'ceDeserialized')}`)\r\n    // console.log(`DEBUG - cloudEvent validation: ${ceDeserialized.validate()}`)\r\n    // console.log(`DEBUG - cloudEvent validation (strict): ${ceDeserialized.validate({ strict: true })}`)\r\n    t.ok(ceDeserialized)\r\n    t.ok(V.isClass(ceDeserialized, CloudEvent))\r\n    t.ok(ceDeserialized.isValid())\r\n    t.ok(ceDeserialized.validate().length === 0)\r\n    t.ok(ceDeserialized.validate({ strict: false }).length === 0)\r\n    t.ok(ceDeserialized.validate({ strict: true }).length === 0)\r\n    t.ok(CloudEvent.isValidEvent(ceDeserialized))\r\n    t.ok(CloudEvent.validateEvent(ceDeserialized).length === 0)\r\n    t.ok(CloudEvent.validateEvent(ceDeserialized, { strict: false }).length === 0)\r\n    t.ok(CloudEvent.validateEvent(ceDeserialized, { strict: true }).length === 0)\r\n    t.ok(CloudEvent.isCloudEvent(ceDeserialized))\r\n\r\n    // inspect content of deserialized CloudEvent, at least on some attributes\r\n    t.ok(ceDeserialized.time)\r\n    t.ok(V.isDate(ceDeserialized.time))\r\n    t.ok(V.isDateValid(ceDeserialized.time))\r\n    t.ok(V.isDatePast(ceDeserialized.time))\r\n    t.strictSame(ceDeserialized.time.getTime(), commonEventTime.getTime())\r\n    t.notStrictEqual(ceDeserialized.time, commonEventTime)\r\n    t.notEqual(ceDeserialized.time, commonEventTime)\r\n    // console.log(`DEBUG - cloudEvent data: ${T.dumpObject(ceDeserialized.data, 'ceDeserialized.data')}`)\r\n    // console.log(`DEBUG - cloudEvent payload: ${T.dumpObject(ceDeserialized.payload, 'ceDeserialized.payload')}`)\r\n    t.ok(ceDeserialized.data)\r\n    t.ok(V.isString(ceDeserialized.data))\r\n    t.ok(ceDeserialized.payload)\r\n    t.ok(V.isString(ceDeserialized.payload))\r\n    // then ensure the value of both are the same ...\r\n    t.strictSame(ceDeserialized.data, ceDeserialized.payload)\r\n    // and that they are the same of initial value ...\r\n    t.strictSame(ceDeserialized.data, ceFullStrict.data)\r\n    t.notStrictSame(ceDeserialized.data, ceDataEncoded)\r\n    // then ensure they are different object (references) ...\r\n    // not needed here because is a string, and payload returns a copy of it, so comparison here will be equals ...\r\n\r\n    {\r\n      const serialized = ceFullSerializedStatic\r\n      // console.log(`DEBUG - serialized cloudEvent details: serialized = '${serialized}'`)\r\n      t.ok(serialized)\r\n      t.ok(V.isString(serialized))\r\n      // some checks on serialized instance\r\n      const ceFullDeserializedJSON = JSON.parse(ceFullSerializedStatic) // note that some fields (like dates) will be different when deserialized in this way ...\r\n      ceFullDeserializedJSON.time = commonEventTime // quick fix for the Date/timestamp attribute in the deserialized object\r\n      // ceFullDeserializedJSON.datacontentencoding = undefined // quick fix for this not so common attribute in the deserialized object\r\n      // console.log(`DEBUG - deserialized cloudEvent: data = '${ceFullDeserializedJSON.data}'`)\r\n      // next tests are so because here deserialization is done with standard JSON, and not with ce specific method ...\r\n      t.notStrictSame(ceFullDeserializedJSON, ceFullStrict)\r\n      t.notStrictSame(ceFullDeserializedJSON.data, ceFullStrict.data)\r\n      t.strictSame(ceFullDeserializedJSON.data, ceDataEncoded)\r\n    }\r\n    {\r\n      // test with not supported data (not a string representation)\r\n      const serialized = ceFullSerializedStatic.replace(ceDataEncoded, '')\r\n      // console.log(`DEBUG - serialized cloudEvent details: serialized = '${serialized}'`)\r\n      // some checks on serialized instance, but using deserialization methods\r\n      t.throws(function () {\r\n        const ceDeserialized = CloudEvent.deserializeEvent(serialized)\r\n        assert(ceDeserialized === undefined) // never executed\r\n      }, Error, 'Expected exception when creating a CloudEvent with datacontentencoding set and data not a string')\r\n    }\r\n    {\r\n      // test with a not supported datacontentencoding\r\n      const serialized = ceFullSerializedStatic.replace('Base64', 'Custom encoding')\r\n      // console.log(`DEBUG - serialized cloudEvent details: serialized = '${serialized}'`)\r\n      // some checks on serialized instance, but using deserialization methods\r\n      t.throws(function () {\r\n        const ceDeserialized = CloudEvent.deserializeEvent(serialized)\r\n        assert(ceDeserialized === undefined) // never executed\r\n      }, Error, 'Expected exception when creating a CloudEvent with datacontentencoding not supported')\r\n    }\r\n    {\r\n      // test with a not supported datacontentencoding\r\n      const ceFull = new CloudEvent('1/full/sample-data-nested/strict',\r\n        ceNamespace,\r\n        ceServerUrl,\r\n        ceDataAsString, // data\r\n        { ...ceOptionsWithDataEncodingNotSupported, strict: true },\r\n        ceCommonExtensions\r\n      )\r\n      t.ok(ceFull)\r\n      t.ok(CloudEvent.isValidEvent(ceFull, { strict: false }))\r\n      t.ok(CloudEvent.isValidEvent(ceFull, { strict: true }))\r\n      t.strictSame(CloudEvent.validateEvent(ceFull, { strict: false }).length, 0)\r\n      t.strictSame(CloudEvent.validateEvent(ceFull, { strict: true }).length, 0)\r\n      t.strictSame(ceFull.data, ceDataAsString)\r\n      t.notStrictSame(ceFull.data, ceDataEncoded)\r\n      t.strictSame(T.stringToBase64(ceDataAsString), ceDataEncoded)\r\n      t.strictSame(T.stringFromBase64(T.stringToBase64(ceDataAsString)), ceDataAsString)\r\n      const ceFullSerializedStatic = CloudEvent.serializeEvent(ceFull)\r\n      t.ok(ceFullSerializedStatic)\r\n    }\r\n  }\r\n})\r\n",
    "static": true,
    "longname": "/Users/martinis/work/prove/cloudevent.js/test/cloudevent-serialization.test.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 179,
    "kind": "test",
    "name": "test0",
    "testId": 0,
    "memberof": "test/cloudevent-serialization.test.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/cloudevent-serialization.test.js~test0",
    "access": null,
    "description": "ensure serialization functions exists (check only the static method here)",
    "lineNumber": 22,
    "testTargets": [
      "CloudEvent"
    ]
  },
  {
    "__docId__": 180,
    "kind": "test",
    "name": "test1",
    "testId": 1,
    "memberof": "test/cloudevent-serialization.test.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/cloudevent-serialization.test.js~test1",
    "access": null,
    "description": "serialize some CloudEvent instances to JSON, and ensure they are right",
    "lineNumber": 82,
    "testTargets": [
      "CloudEvent"
    ]
  },
  {
    "__docId__": 181,
    "kind": "test",
    "name": "test2",
    "testId": 2,
    "memberof": "test/cloudevent-serialization.test.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/cloudevent-serialization.test.js~test2",
    "access": null,
    "description": "serialize a CloudEvent instance with a non default contenttype and empty serialization options, expect error",
    "lineNumber": 256,
    "testTargets": [
      "CloudEvent"
    ]
  },
  {
    "__docId__": 182,
    "kind": "test",
    "name": "test3",
    "testId": 3,
    "memberof": "test/cloudevent-serialization.test.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/cloudevent-serialization.test.js~test3",
    "access": null,
    "description": "serialize a CloudEvent instance with a non default contenttype and right serialization options, expect success",
    "lineNumber": 468,
    "testTargets": [
      "CloudEvent"
    ]
  },
  {
    "__docId__": 183,
    "kind": "test",
    "name": "test4",
    "testId": 4,
    "memberof": "test/cloudevent-serialization.test.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/cloudevent-serialization.test.js~test4",
    "access": null,
    "description": "serialize a CloudEvent instance with a non default contenttype (but in the JSON-like family) and right serialization options, expect success",
    "lineNumber": 595,
    "testTargets": [
      "CloudEvent"
    ]
  },
  {
    "__docId__": 184,
    "kind": "test",
    "name": "test5",
    "testId": 5,
    "memberof": "test/cloudevent-serialization.test.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/cloudevent-serialization.test.js~test5",
    "access": null,
    "description": "ensure the JSON Schema for a CloudEvent (static and for a normal instance) is available",
    "lineNumber": 818,
    "testTargets": [
      "CloudEvent"
    ]
  },
  {
    "__docId__": 185,
    "kind": "test",
    "name": "test6",
    "testId": 6,
    "memberof": "test/cloudevent-serialization.test.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/cloudevent-serialization.test.js~test6",
    "access": null,
    "description": "serialize some CloudEvent instances to JSON with nested data, and ensure they are right",
    "lineNumber": 870,
    "testTargets": [
      "CloudEvent"
    ]
  },
  {
    "__docId__": 186,
    "kind": "test",
    "name": "test7",
    "testId": 7,
    "memberof": "test/cloudevent-serialization.test.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/cloudevent-serialization.test.js~test7",
    "access": null,
    "description": "deserialize generic strings (not JSON representation for an Object) into a CloudEvent instance, expected Errors",
    "lineNumber": 999,
    "testTargets": [
      "CloudEvent"
    ]
  },
  {
    "__docId__": 187,
    "kind": "test",
    "name": "test8",
    "testId": 8,
    "memberof": "test/cloudevent-serialization.test.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/cloudevent-serialization.test.js~test8",
    "access": null,
    "description": "deserialize some CloudEvent instances from JSON, and ensure built instances are right",
    "lineNumber": 1044,
    "testTargets": [
      "CloudEvent"
    ]
  },
  {
    "__docId__": 188,
    "kind": "test",
    "name": "test9",
    "testId": 9,
    "memberof": "test/cloudevent-serialization.test.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/cloudevent-serialization.test.js~test9",
    "access": null,
    "description": "deserialize a CloudEvent instance with a non default contenttype and empty/wrong deserialization options, expect error",
    "lineNumber": 1144,
    "testTargets": [
      "CloudEvent"
    ]
  },
  {
    "__docId__": 189,
    "kind": "test",
    "name": "test10",
    "testId": 10,
    "memberof": "test/cloudevent-serialization.test.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/cloudevent-serialization.test.js~test10",
    "access": null,
    "description": "deserialize a CloudEvent instance with a non default contenttype and right deserialization options, expect success",
    "lineNumber": 1266,
    "testTargets": [
      "CloudEvent"
    ]
  },
  {
    "__docId__": 190,
    "kind": "test",
    "name": "test11",
    "testId": 11,
    "memberof": "test/cloudevent-serialization.test.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/cloudevent-serialization.test.js~test11",
    "access": null,
    "description": "serialize and deserialize a big CloudEvent instance (more than 64 KB)",
    "lineNumber": 1356,
    "testTargets": [
      "CloudEvent"
    ]
  },
  {
    "__docId__": 191,
    "kind": "test",
    "name": "test12",
    "testId": 12,
    "memberof": "test/cloudevent-serialization.test.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/cloudevent-serialization.test.js~test12",
    "access": null,
    "description": "serialize and deserialize a big CloudEvent instance with a non default contenttype (more than 64 KB)",
    "lineNumber": 1546,
    "testTargets": [
      "CloudEvent"
    ]
  },
  {
    "__docId__": 192,
    "kind": "test",
    "name": "test13",
    "testId": 13,
    "memberof": "test/cloudevent-serialization.test.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/cloudevent-serialization.test.js~test13",
    "access": null,
    "description": "create and deserialize some CloudEvent instances with datacontentencoding specified, and ensure they are right",
    "lineNumber": 1829,
    "testTargets": [
      "CloudEvent"
    ]
  },
  {
    "__docId__": 193,
    "kind": "testFile",
    "name": "test/cloudevent.test.js",
    "content": "/*\r\n * Copyright 2018 the original author or authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n'use strict'\r\n\r\nconst assert = require('assert').strict\r\nconst test = require('tap').test\r\n\r\n// import some common test data\r\nconst {\r\n  // commonEventTime,\r\n  ceCommonOptions,\r\n  ceCommonOptionsStrict,\r\n  ceCommonExtensions,\r\n  ceExtensionStrict,\r\n  ceNamespace,\r\n  ceServerUrl,\r\n  ceCommonData,\r\n  ceMapData\r\n} = require('./common-test-data')\r\n\r\n/** @test {CloudEvent} */\r\ntest('ensure CloudEvent class (and related Validator and Transformer classes) are exported by the library', (t) => {\r\n  t.plan(20)\r\n\r\n  const { CloudEvent, CloudEventValidator: V, CloudEventTransformer: T } = require('../src/') // get references via destructuring\r\n  t.ok(CloudEvent)\r\n  // optional, using some standard Node.js assert statements, as a sample\r\n  assert(CloudEvent !== null)\r\n  assert.strictEqual(typeof CloudEvent, 'function')\r\n  assert(new CloudEvent() instanceof CloudEvent)\r\n  assert.strictEqual(CloudEvent.mediaType(), 'application/cloudevents+json')\r\n  t.ok(V)\r\n  t.strictEqual(typeof CloudEvent, 'function')\r\n  t.strictEqual(typeof V, 'function')\r\n  t.strictEqual(typeof T, 'function')\r\n  t.ok(V.isFunction(CloudEvent))\r\n  t.ok(V.isFunction(V))\r\n  t.ok(V.isFunction(T))\r\n  t.strictEqual(typeof CloudEvent, 'function')\r\n  t.strictEqual(new CloudEvent() instanceof CloudEvent, true)\r\n  t.strictEqual(CloudEvent.mediaType(), 'application/cloudevents+json')\r\n\r\n  {\r\n    // create an instance with only mandatory arguments (no strict mode, but doesn't matter in this case): expected success ...\r\n    const ceMinimal = new CloudEvent('1', // id\r\n      ceNamespace, // type\r\n      '/', // source\r\n      {} // data (empty) // optional, but useful the same in this sample usage\r\n    )\r\n    t.ok(ceMinimal)\r\n    // console.log(`DEBUG - cloudEvent details: ceMinimal = ${JSON.stringify(ceMinimal)}`)\r\n    // console.log(`DEBUG - cloudEvent details: ${T.dumpObject(ceMinimal, 'ceMinimal')}`)\r\n\r\n    // check that created instances belongs to the right base class\r\n    t.strictEqual(typeof ceMinimal, 'object')\r\n    t.ok(V.isClass(ceMinimal, CloudEvent))\r\n  }\r\n\r\n  {\r\n    // create an instance with only mandatory arguments but null data (and strict mode): expected success ...\r\n    const ceMinimalStrict = new CloudEvent('1-strict', // id\r\n      ceNamespace, // type\r\n      '/', // source\r\n      null // data // optional, but useful the same in this sample usage\r\n    )\r\n    t.ok(ceMinimalStrict)\r\n\r\n    // check that created instances belongs to the right base class\r\n    t.strictEqual(typeof ceMinimalStrict, 'object')\r\n    t.ok(V.isClass(ceMinimalStrict, CloudEvent))\r\n\r\n    t.strictEqual(typeof ceMinimalStrict.data, 'object') // data is wrapped in an object, so even when null it's an object\r\n    t.ok(CloudEvent.isValidEvent(ceMinimalStrict))\r\n\r\n    // set ceMinimalStrict.data to null, to ensure validation is good the same\r\n    ceMinimalStrict.data = null\r\n    t.ok(CloudEvent.isValidEvent(ceMinimalStrict))\r\n  }\r\n})\r\n\r\n/** @test {CloudEvent} */\r\ntest('ensure isValid and validate works good on undefined and null objects', (t) => {\r\n  t.plan(7)\r\n  const { CloudEvent } = require('../src/')\r\n  t.ok(CloudEvent)\r\n\r\n  // undefined\r\n  t.notOk()\r\n  t.notOk(CloudEvent.isValidEvent())\r\n  t.strictSame(CloudEvent.validateEvent(), [new Error('CloudEvent undefined or null')])\r\n\r\n  // null\r\n  t.notOk(null)\r\n  t.notOk(CloudEvent.isValidEvent(null))\r\n  t.strictSame(CloudEvent.validateEvent(null), [new Error('CloudEvent undefined or null')])\r\n})\r\n\r\n/** @test {CloudEvent} */\r\ntest('create some CloudEvent instances (empty, without minimal arguments set or not set) and ensure they are different objects', (t) => {\r\n  t.plan(13)\r\n  const { CloudEvent } = require('../src/')\r\n  t.ok(CloudEvent)\r\n\r\n  // note that when creating an instance with an undefined mandatory argument (without a default value), but with strict flag disabled: expected success ...\r\n  // note that null values are not handled by default values, only undefined values ...\r\n\r\n  {\r\n    // create an instance without mandatory arguments (but no strict mode): expected success ...\r\n    const ceEmpty = new CloudEvent()\r\n    t.ok(ceEmpty)\r\n    t.ok(!CloudEvent.isValidEvent(ceEmpty))\r\n    // t.strictSame(CloudEvent.validateEvent(ceEmpty), []) // temp, to see the error during development ...\r\n    t.strictSame(CloudEvent.validateEvent(ceEmpty).length, 3) // simplify comparison of results, check only the  number of expected errors ...\r\n    // the same but using normal instance methods, to ensure they works good ...\r\n    t.ok(!ceEmpty.isValid())\r\n    t.strictSame(ceEmpty.validate().length, 3) // simplify comparison of results, check only the  number of expected errors ...\r\n    t.ok(!ceEmpty.isStrict)\r\n    t.strictSame(ceEmpty.validate({ strict: true }).length, 5) // simplify comparison of results, check only the  number of expected errors ...\r\n  }\r\n\r\n  {\r\n    // create an instance without mandatory arguments (but with strict mode): expected failure ...\r\n    let ceEmpty2 = null\r\n    try {\r\n      ceEmpty2 = new CloudEvent(undefined, undefined, undefined, undefined, { strict: true })\r\n      assert(ceEmpty2 === null) // never executed\r\n    } catch (e) {\r\n      t.ok(e) // expected error here\r\n      t.ok(!CloudEvent.isValidEvent(ceEmpty2))\r\n      t.strictSame(CloudEvent.validateEvent(ceEmpty2), [new Error('CloudEvent undefined or null')])\r\n      // the same but using normal instance methods, to ensure they works good ... no because here instance is null\r\n    }\r\n    t.equal(ceEmpty2, null)\r\n    // the same test, but in a shorter form ...\r\n    t.throws(function () {\r\n      const ce = new CloudEvent(undefined, undefined, undefined, undefined, { strict: true })\r\n      assert(ce === null) // never executed\r\n    }, Error, 'Expected exception when creating a CloudEvent without mandatory arguments with strict flag enabled')\r\n  }\r\n})\r\n\r\n/** @test {CloudEvent} */\r\ntest('create some CloudEvent instances (with minimal fields set) and ensure they are different objects', (t) => {\r\n  t.plan(41)\r\n  const { CloudEvent } = require('../src/')\r\n  t.ok(CloudEvent)\r\n\r\n  // t.notSame(CloudEvent.isValidEvent, CloudEvent.validateEvent)\r\n  t.strictNotSame(CloudEvent.isValidEvent, CloudEvent.validateEvent)\r\n\r\n  {\r\n    // create an instance with only mandatory arguments (no strict mode, but doesn't matter in this case): expected success ...\r\n    const ceMinimal = new CloudEvent('1', // id\r\n      ceNamespace, // type\r\n      '/', // source\r\n      {} // data (empty) // optional, but useful the same in this sample usage\r\n    )\r\n    t.ok(ceMinimal)\r\n    // console.log(`DEBUG - cloudEvent details: ceMinimal = ${JSON.stringify(ceMinimal)}`)\r\n    // console.log(`DEBUG - cloudEvent details: ${T.dumpObject(ceMinimal, 'ceMinimal')}`)\r\n    // console.log(`DEBUG - cloudEvent details: ${ceMinimal}`) // implicit call of its toString method ...\r\n    t.ok(CloudEvent.isValidEvent(ceMinimal))\r\n    t.strictSame(CloudEvent.validateEvent(ceMinimal), [])\r\n    // t.strictSame(CloudEvent.validateEvent(ceEmpty), []) // temp, to see the error during development ...\r\n    t.strictSame(CloudEvent.validateEvent(ceMinimal).length, 0) // simplify comparison of results, check only the  number of expected errors ...\r\n    // create another instance, similar\r\n    // the same but using normal instance methods, to ensure they works good ...\r\n    t.ok(ceMinimal.isValid())\r\n    t.strictSame(ceMinimal.validate(), [])\r\n    t.strictSame(ceMinimal.validate().length, 0) // simplify comparison of results, check only the  number of expected errors ...\r\n    t.ok(!ceMinimal.isStrict)\r\n    const ceMinimal2 = new CloudEvent('2', // id\r\n      ceNamespace, // type\r\n      '/', // source\r\n      {} // data (empty) // optional, but useful the same in this sample usage\r\n    )\r\n    t.ok(ceMinimal2)\r\n    t.ok(CloudEvent.isValidEvent(ceMinimal2)) // using default strict mode in the event\r\n    t.ok(CloudEvent.isValidEvent(ceMinimal2, { strict: false })) // same of previous but using strict mode in validation options\r\n    t.strictSame(CloudEvent.validateEvent(ceMinimal2), [])\r\n    t.strictSame(CloudEvent.validateEvent(ceMinimal2).length, 0)\r\n    // the same but using normal instance methods, to ensure they works good ...\r\n    t.ok(ceMinimal2.isValid()) // using default strict mode in the event\r\n    t.ok(ceMinimal2.isValid({ strict: false })) // same of previous but using strict mode in validation options\r\n    t.strictSame(ceMinimal2.validate(), [])\r\n    t.strictSame(ceMinimal2.validate().length, 0)\r\n    // then ensure they are different (have different values inside) ...\r\n    assert(ceMinimal !== ceMinimal2) // they must be different object references\r\n    t.notSame(ceMinimal, ceMinimal2)\r\n    t.strictNotSame(ceMinimal, ceMinimal2)\r\n  }\r\n\r\n  {\r\n    // create an instance with a mandatory argument undefined (but no strict mode): expected success ...\r\n    // note that undefined arguments will be handled by default arguments, so all will be good the same here ...\r\n    const ceMinimalMandatoryUndefinedNoStrict = new CloudEvent(undefined, undefined, undefined, undefined, { strict: false })\r\n    assert(ceMinimalMandatoryUndefinedNoStrict !== null)\r\n    t.ok(ceMinimalMandatoryUndefinedNoStrict)\r\n    t.ok(!CloudEvent.isValidEvent(ceMinimalMandatoryUndefinedNoStrict)) // using default strict mode in the event\r\n    t.ok(!CloudEvent.isValidEvent(ceMinimalMandatoryUndefinedNoStrict, { strict: false })) // same of previous but using strict mode in validation options\r\n    t.strictSame(CloudEvent.validateEvent(ceMinimalMandatoryUndefinedNoStrict, { strict: false }).length, 3)\r\n    t.ok(!CloudEvent.isValidEvent(ceMinimalMandatoryUndefinedNoStrict, { strict: true })) // the same but validate with strict mode enabled ...\r\n    // the same but using normal instance methods, to ensure they works good ...\r\n    t.ok(!ceMinimalMandatoryUndefinedNoStrict.isValid()) // using default strict mode in the event\r\n    t.ok(!ceMinimalMandatoryUndefinedNoStrict.isValid({ strict: false })) // same of previous but using strict mode in validation options\r\n    t.strictSame(ceMinimalMandatoryUndefinedNoStrict.validate({ strict: false }).length, 3)\r\n    t.ok(!ceMinimalMandatoryUndefinedNoStrict.isValid({ strict: true })) // the same but validate with strict mode enabled ...\r\n\r\n    // the same but with strict mode: expected exception ...\r\n    t.throws(function () {\r\n      const ceMinimalMandatoryUndefinedStrict = new CloudEvent(undefined, undefined, undefined, undefined, { strict: true })\r\n      assert(ceMinimalMandatoryUndefinedStrict === null) // never executed\r\n    }, Error, 'Expected exception when creating a CloudEvent without mandatory arguments with strict flag enabled')\r\n  }\r\n\r\n  {\r\n    // create an instance with a mandatory argument null (but no strict mode): expected success ...\r\n    // note that only undefined arguments will be assigned a default value (if set), so all will be good the same here ...\r\n    const ceMinimalMandatoryNullNoStrict = new CloudEvent(null, null, null, null, { strict: false })\r\n    assert(ceMinimalMandatoryNullNoStrict !== null)\r\n    t.ok(ceMinimalMandatoryNullNoStrict)\r\n    t.ok(!CloudEvent.isValidEvent(ceMinimalMandatoryNullNoStrict)) // using default strict mode in the event\r\n    t.ok(!CloudEvent.isValidEvent(ceMinimalMandatoryNullNoStrict, { strict: false })) // same of previous but using strict mode in validation options\r\n    t.strictSame(CloudEvent.validateEvent(ceMinimalMandatoryNullNoStrict, { strict: false }).length, 3)\r\n    t.ok(!CloudEvent.isValidEvent(ceMinimalMandatoryNullNoStrict, { strict: true })) // the same but validate with strict mode enabled ...\r\n    // the same but using normal instance methods, to ensure they works good ...\r\n    t.ok(!ceMinimalMandatoryNullNoStrict.isValid()) // using default strict mode in the event\r\n    t.ok(!ceMinimalMandatoryNullNoStrict.isValid({ strict: false })) // same of previous but using strict mode in validation options\r\n    t.strictSame(ceMinimalMandatoryNullNoStrict.validate({ strict: false }).length, 3)\r\n    t.ok(!ceMinimalMandatoryNullNoStrict.isValid({ strict: true })) // the same but validate with strict mode enabled ...\r\n\r\n    // the same but with strict mode: expected exception ...\r\n    t.throws(function () {\r\n      const ceMinimalMandatoryNullStrict = new CloudEvent(null, null, null, null, { strict: true })\r\n      assert(ceMinimalMandatoryNullStrict === null) // never executed\r\n    }, Error, 'Expected exception when creating a CloudEvent without mandatory arguments with strict flag enabled')\r\n  }\r\n})\r\n\r\n/** @test {CloudEvent} */\r\ntest('ensure strict mode is managed in the right way', (t) => {\r\n  t.plan(16)\r\n  const { CloudEvent } = require('../src/')\r\n  t.ok(CloudEvent)\r\n\r\n  t.ok(!CloudEvent.setStrictExtensionInEvent()) // ok but no return value\r\n  t.ok(!CloudEvent.setStrictExtensionInEvent(undefined, undefined)) // ok but no return value\r\n  t.throws(function () {\r\n    CloudEvent.setStrictExtensionInEvent(null, true)\r\n    assert(true) // never executed\r\n  }, TypeError, 'Expected exception when setting a strict extension flag into a null object')\r\n  t.ok(!CloudEvent.setStrictExtensionInEvent({}, false)) // ok but no return value\r\n  t.ok(!CloudEvent.setStrictExtensionInEvent({}, true)) // ok but no return value\r\n  t.throws(function () {\r\n    CloudEvent.setStrictExtensionInEvent({}, 'bad flag')\r\n    assert(true) // never executed\r\n  }, TypeError, 'Expected exception when setting a bad strict extension flag into an object')\r\n\r\n  t.ok(!CloudEvent.getStrictExtensionOfEvent()) // ok but false return value\r\n  t.ok(!CloudEvent.getStrictExtensionOfEvent(undefined)) // ok but false return value\r\n  t.throws(function () {\r\n    CloudEvent.getStrictExtensionOfEvent(null)\r\n    assert(true) // never executed\r\n  }, TypeError, 'Expected exception when getting a strict extension flag from a null object')\r\n  t.ok(!CloudEvent.getStrictExtensionOfEvent({})) // ok but false return value\r\n  t.ok(!CloudEvent.getStrictExtensionOfEvent({ com_github_smartiniOnGitHub_cloudevent: {} })) // ok but false return value\r\n  t.throws(function () {\r\n    CloudEvent.getStrictExtensionOfEvent({ com_github_smartiniOnGitHub_cloudevent: 'bad value' })\r\n    assert(true) // never executed\r\n  }, TypeError, 'Expected exception when getting a strict extension flag from a wrong property for my custom extensions object')\r\n  t.ok(!CloudEvent.getStrictExtensionOfEvent({ com_github_smartiniOnGitHub_cloudevent: { strict: false } })) // ok but false return value\r\n  t.ok(CloudEvent.getStrictExtensionOfEvent({ com_github_smartiniOnGitHub_cloudevent: { strict: true } })) // ok and true return value\r\n  t.throws(function () {\r\n    CloudEvent.getStrictExtensionOfEvent({ com_github_smartiniOnGitHub_cloudevent: { strict: 'bad flag' } })\r\n    assert(true) // never executed\r\n  }, TypeError, 'Expected exception when getting a bad strict extension flag from my custom extensions object')\r\n})\r\n\r\n/** @test {CloudEvent} */\r\ntest('ensure extensions are managed in the right way', (t) => {\r\n  t.plan(19)\r\n  const { CloudEvent } = require('../src/')\r\n  t.ok(CloudEvent)\r\n\r\n  const sampleExtensions = { exampleExtension: 'value' }\r\n  const sampleExtensionsWithStandardProperties = { ...sampleExtensions, id: 'myId' }\r\n\r\n  t.ok(!CloudEvent.setExtensionsInEvent()) // ok but no return value\r\n  t.ok(!CloudEvent.setExtensionsInEvent(undefined, undefined)) // ok but no return value\r\n  t.throws(function () {\r\n    CloudEvent.setExtensionsInEvent(null, sampleExtensions)\r\n    assert(true) // never executed\r\n  }, TypeError, 'Expected exception when setting extensions into a null object')\r\n  t.ok(!CloudEvent.setExtensionsInEvent({}, sampleExtensions)) // ok but no return value\r\n  t.throws(function () {\r\n    CloudEvent.setExtensionsInEvent({}, 'bad extension')\r\n    assert(true) // never executed\r\n  }, TypeError, 'Expected exception when setting bad extensions into an object')\r\n\r\n  t.notOk(CloudEvent.getExtensionsOfEvent()) // null as return value\r\n  t.notOk(CloudEvent.getExtensionsOfEvent(undefined)) // null as return value\r\n  t.throws(function () {\r\n    CloudEvent.getExtensionsOfEvent(null)\r\n    assert(true) // never executed\r\n  }, TypeError, 'Expected exception when getting extensions from a null object')\r\n  t.notOk(CloudEvent.getExtensionsOfEvent({})) // null as return value\r\n  t.ok(CloudEvent.getExtensionsOfEvent(sampleExtensions))\r\n  t.throws(function () {\r\n    CloudEvent.getExtensionsOfEvent('bad extension')\r\n    assert(true) // never executed\r\n  }, TypeError, 'Expected exception when getting bad extensions')\r\n\r\n  // ensure no instance will be created if extensions contains standard properties, but only in strict mode\r\n  const ceFull = new CloudEvent('1/full',\r\n    ceNamespace,\r\n    ceServerUrl,\r\n    ceCommonData,\r\n    ceCommonOptions,\r\n    sampleExtensionsWithStandardProperties\r\n  )\r\n  t.ok(ceFull)\r\n  t.ok(CloudEvent.isValidEvent(ceFull))\r\n  t.ok(CloudEvent.isValidEvent(ceFull, { strict: false }))\r\n  t.strictSame(CloudEvent.validateEvent(ceFull), [])\r\n  t.strictSame(CloudEvent.validateEvent(ceFull).length, 0)\r\n  t.throws(function () {\r\n    const ceFullStrict = new CloudEvent('1/full-strict',\r\n      ceNamespace,\r\n      ceServerUrl,\r\n      ceCommonData,\r\n      ceCommonOptionsStrict,\r\n      sampleExtensionsWithStandardProperties\r\n    )\r\n    assert(ceFullStrict === undefined) // never executed\r\n  }, Error, 'Expected exception when creating a CloudEvent with extensions containing standard prioperties, in strict mode')\r\n  // ensure no instance will be created if extensions are defined but empty (not valid in strict mode)\r\n  t.throws(function () {\r\n    const ceFullStrictEmptyExtensions = new CloudEvent('1/full-strict',\r\n      ceNamespace,\r\n      ceServerUrl,\r\n      ceCommonData,\r\n      ceCommonOptionsStrict,\r\n      {} // defined but empty extensions (null or undefined would be good otherwise)\r\n    )\r\n    assert(ceFullStrictEmptyExtensions === undefined) // never executed\r\n  }, Error, 'Expected exception when creating a CloudEvent with extensions defined but empty, in strict mode')\r\n})\r\n\r\n/** @test {CloudEvent} */\r\ntest('create two CloudEvent instances with all arguments (mandatory and optional arguments) and ensure they are different objects', (t) => {\r\n  t.plan(21)\r\n  const { CloudEvent } = require('../src/')\r\n  t.ok(CloudEvent)\r\n\r\n  // create an instance with some common options, but with strict flag disabled: expected success ...\r\n  const ceFull1 = new CloudEvent('1/full',\r\n    ceNamespace,\r\n    ceServerUrl,\r\n    ceCommonData,\r\n    ceCommonOptions,\r\n    ceCommonExtensions\r\n  )\r\n  t.ok(ceFull1)\r\n  t.ok(CloudEvent.isValidEvent(ceFull1))\r\n  t.ok(CloudEvent.isValidEvent(ceFull1, { strict: false }))\r\n  t.strictSame(CloudEvent.validateEvent(ceFull1), [])\r\n  t.strictSame(CloudEvent.validateEvent(ceFull1).length, 0)\r\n  // the same but using normal instance methods, to ensure they works good ...\r\n  t.ok(ceFull1.isValid())\r\n  t.ok(ceFull1.isValid({ strict: false }))\r\n  t.strictSame(ceFull1.validate(), [])\r\n  t.strictSame(ceFull1.validate().length, 0)\r\n\r\n  // create another instance with all fields equals: expected success ...\r\n  const ceFull1Clone = new CloudEvent('1/full', // should be '2/full/no-strict' ...\r\n    ceNamespace,\r\n    ceServerUrl,\r\n    ceCommonData,\r\n    ceCommonOptions,\r\n    ceCommonExtensions\r\n  )\r\n  t.ok(ceFull1Clone)\r\n  t.ok(CloudEvent.isValidEvent(ceFull1Clone))\r\n  t.ok(CloudEvent.isValidEvent(ceFull1Clone, { strict: false }))\r\n  t.strictSame(CloudEvent.validateEvent(ceFull1Clone), [])\r\n  t.strictSame(CloudEvent.validateEvent(ceFull1Clone).length, 0)\r\n  // the same but using normal instance methods, to ensure they works good ...\r\n  t.ok(ceFull1Clone.isValid())\r\n  t.ok(ceFull1Clone.isValid({ strict: false }))\r\n  t.strictSame(ceFull1Clone.validate(), [])\r\n  t.strictSame(ceFull1Clone.validate().length, 0)\r\n\r\n  // then ensure they are different objects ...\r\n  assert(ceFull1 !== ceFull1Clone) // they must be different object references\r\n  t.same(ceFull1, ceFull1Clone)\r\n  t.strictSame(ceFull1, ceFull1Clone)\r\n})\r\n\r\n/** @test {CloudEvent} */\r\ntest('create CloudEvent instances with different kind of data attribute, and ensure the validation is right', (t) => {\r\n  t.plan(81)\r\n  const { CloudEvent } = require('../src/')\r\n  t.ok(CloudEvent)\r\n\r\n  {\r\n    // create an instance with undefined data attribute, but with strict flag disabled: expected success ...\r\n    // note that null values are not handled by default values, only undefined values ...\r\n    const ceFullDataUndefined = new CloudEvent('1/full/undefined-data/no-strict',\r\n      ceNamespace,\r\n      ceServerUrl,\r\n      undefined, // data\r\n      ceCommonOptions,\r\n      ceCommonExtensions\r\n    )\r\n    assert(ceFullDataUndefined !== null)\r\n    t.ok(ceFullDataUndefined)\r\n    t.ok(CloudEvent.isValidEvent(ceFullDataUndefined))\r\n    t.ok(CloudEvent.isValidEvent(ceFullDataUndefined, { strict: false }))\r\n    t.strictSame(CloudEvent.validateEvent(ceFullDataUndefined), [])\r\n    t.strictSame(CloudEvent.validateEvent(ceFullDataUndefined, { strict: false }).length, 0)\r\n    // the same but using normal instance methods, to ensure they works good ...\r\n    t.ok(ceFullDataUndefined.isValid())\r\n    t.ok(ceFullDataUndefined.isValid({ strict: false }))\r\n    t.strictSame(ceFullDataUndefined.validate(), [])\r\n    t.strictSame(ceFullDataUndefined.validate({ strict: false }).length, 0)\r\n    // the same but with strict mode enabled ...\r\n    const ceFullDataUndefinedStrict = new CloudEvent('1/full/undefined-data/strict',\r\n      ceNamespace,\r\n      ceServerUrl,\r\n      undefined, // data\r\n      ceCommonOptionsStrict,\r\n      ceCommonExtensions\r\n    )\r\n    assert(ceFullDataUndefinedStrict !== null)\r\n    t.ok(ceFullDataUndefinedStrict)\r\n    t.ok(CloudEvent.isValidEvent(ceFullDataUndefinedStrict))\r\n    t.ok(CloudEvent.isValidEvent(ceFullDataUndefinedStrict, { strict: true }))\r\n    t.strictSame(CloudEvent.validateEvent(ceFullDataUndefinedStrict), [])\r\n    t.strictSame(CloudEvent.validateEvent(ceFullDataUndefinedStrict, { strict: true }).length, 0)\r\n    // the same but using normal instance methods, to ensure they works good ...\r\n    t.ok(ceFullDataUndefinedStrict.isValid())\r\n    t.ok(ceFullDataUndefinedStrict.isValid({ strict: true }))\r\n    t.strictSame(ceFullDataUndefinedStrict.validate(), [])\r\n    t.strictSame(ceFullDataUndefinedStrict.validate({ strict: true }).length, 0)\r\n  }\r\n\r\n  {\r\n    // create an instance with null data attribute, but with strict flag disabled: expected success ...\r\n    // note that null values are not handled by default values, only undefined values ...\r\n    const ceFullDataNull = new CloudEvent('1/full/null-data/no-strict',\r\n      ceNamespace,\r\n      ceServerUrl,\r\n      null, // data\r\n      ceCommonOptions,\r\n      ceCommonExtensions\r\n    )\r\n    assert(ceFullDataNull !== null)\r\n    t.ok(ceFullDataNull)\r\n    t.ok(CloudEvent.isValidEvent(ceFullDataNull))\r\n    t.ok(CloudEvent.isValidEvent(ceFullDataNull, { strict: false }))\r\n    t.strictSame(CloudEvent.validateEvent(ceFullDataNull), [])\r\n    t.strictSame(CloudEvent.validateEvent(ceFullDataNull, { strict: false }).length, 0)\r\n    // the same but using normal instance methods, to ensure they works good ...\r\n    t.ok(ceFullDataNull.isValid())\r\n    t.ok(ceFullDataNull.isValid({ strict: false }))\r\n    t.strictSame(ceFullDataNull.validate(), [])\r\n    t.strictSame(ceFullDataNull.validate({ strict: false }).length, 0)\r\n    // the same but with strict mode enabled ...\r\n    const ceFullDataNullStrict = new CloudEvent('1/full/null-data/strict',\r\n      ceNamespace,\r\n      ceServerUrl,\r\n      null, // data\r\n      ceCommonOptionsStrict,\r\n      ceCommonExtensions\r\n    )\r\n    assert(ceFullDataNullStrict !== null)\r\n    t.ok(ceFullDataNullStrict)\r\n    t.ok(CloudEvent.isValidEvent(ceFullDataNullStrict))\r\n    t.ok(CloudEvent.isValidEvent(ceFullDataNullStrict, { strict: true }))\r\n    t.strictSame(CloudEvent.validateEvent(ceFullDataNullStrict), [])\r\n    t.strictSame(CloudEvent.validateEvent(ceFullDataNullStrict, { strict: true }).length, 0)\r\n    // the same but using normal instance methods, to ensure they works good ...\r\n    t.ok(ceFullDataNullStrict.isValid())\r\n    t.ok(ceFullDataNullStrict.isValid({ strict: true }))\r\n    t.strictSame(ceFullDataNullStrict.validate(), [])\r\n    t.strictSame(ceFullDataNullStrict.validate({ strict: true }).length, 0)\r\n  }\r\n\r\n  {\r\n    // create an instance with a string data attribute, but with strict flag disabled: expected success ...\r\n    const ceFullDataString = new CloudEvent('1/full/string-data/no-strict',\r\n      ceNamespace,\r\n      ceServerUrl,\r\n      'data as a string, bad here', // data\r\n      ceCommonOptions,\r\n      ceCommonExtensions\r\n    )\r\n    assert(ceFullDataString !== null)\r\n    t.ok(ceFullDataString)\r\n    // data type errors handled only in strict mode currently ...\r\n    t.ok(CloudEvent.isValidEvent(ceFullDataString))\r\n    t.ok(CloudEvent.isValidEvent(ceFullDataString, { strict: false })) // good the same\r\n    t.ok(!CloudEvent.isValidEvent(ceFullDataString, { strict: true })) // bad here (right)\r\n    t.strictSame(CloudEvent.validateEvent(ceFullDataString), [])\r\n    t.strictSame(CloudEvent.validateEvent(ceFullDataString, { strict: false }).length, 0) // good the same\r\n    t.strictSame(CloudEvent.validateEvent(ceFullDataString, { strict: true }).length, 1) // bad here (right)\r\n    // the same but using normal instance methods, to ensure they works good ...\r\n    t.ok(ceFullDataString.isValid())\r\n    t.ok(ceFullDataString.isValid({ strict: false }))\r\n    t.ok(!ceFullDataString.isValid({ strict: true }))\r\n    t.strictSame(ceFullDataString.validate(), [])\r\n    t.strictSame(ceFullDataString.validate({ strict: false }).length, 0)\r\n    t.strictSame(ceFullDataString.validate({ strict: true }).length, 1)\r\n    // the same but with strict mode enabled ...\r\n    const ceFullDataStringStrict = new CloudEvent('1/full/string-data/strict',\r\n      ceNamespace,\r\n      ceServerUrl,\r\n      'data as a string, bad here', // data\r\n      ceCommonOptionsStrict,\r\n      ceCommonExtensions\r\n    )\r\n    assert(ceFullDataStringStrict !== null)\r\n    t.ok(ceFullDataStringStrict)\r\n    // data type errors handled only in strict mode currently ...\r\n    // note that in the following lines even if I force 'strict: false' he won't be used because already set in the object instance ...\r\n    t.ok(!CloudEvent.isValidEvent(ceFullDataStringStrict))\r\n    t.ok(!CloudEvent.isValidEvent(ceFullDataStringStrict, { strict: true }))\r\n    t.ok(!CloudEvent.isValidEvent(ceFullDataStringStrict, { strict: false }))\r\n    t.strictSame(CloudEvent.validateEvent(ceFullDataStringStrict).length, 1)\r\n    t.strictSame(CloudEvent.validateEvent(ceFullDataStringStrict, { strict: true }).length, 1)\r\n    t.strictSame(CloudEvent.validateEvent(ceFullDataStringStrict, { strict: false }).length, 1)\r\n    // the same but using normal instance methods, to ensure they works good ...\r\n    t.ok(!ceFullDataStringStrict.isValid())\r\n    t.ok(!ceFullDataStringStrict.isValid({ strict: true }))\r\n    t.ok(!ceFullDataStringStrict.isValid({ strict: false }))\r\n    t.strictSame(ceFullDataStringStrict.validate().length, 1)\r\n    t.strictSame(ceFullDataStringStrict.validate({ strict: true }).length, 1)\r\n    t.strictSame(ceFullDataStringStrict.validate({ strict: false }).length, 1)\r\n  }\r\n\r\n  {\r\n    // create an instance with a sample Map data attribute, but with strict flag disabled: expected success ...\r\n    // note that null values are not handled by default values, only undefined values ...\r\n    const ceFullDataMap = new CloudEvent('1/full/map-data/no-strict',\r\n      ceNamespace,\r\n      ceServerUrl,\r\n      ceMapData, // data\r\n      ceCommonOptions,\r\n      ceCommonExtensions\r\n    )\r\n    assert(ceFullDataMap !== null)\r\n    t.ok(ceFullDataMap)\r\n    t.ok(CloudEvent.isValidEvent(ceFullDataMap))\r\n    t.ok(CloudEvent.isValidEvent(ceFullDataMap, { strict: false }))\r\n    t.strictSame(CloudEvent.validateEvent(ceFullDataMap), []) // data type errors handled only in strict mode currently ...\r\n    t.strictSame(CloudEvent.validateEvent(ceFullDataMap, { strict: false }).length, 0) // data type errors handled only in strict mode currently ...\r\n    // the same but using normal instance methods, to ensure they works good ...\r\n    t.ok(ceFullDataMap.isValid())\r\n    t.ok(ceFullDataMap.isValid({ strict: false }))\r\n    t.strictSame(ceFullDataMap.validate(), []) // data type errors handled only in strict mode currently ...\r\n    t.strictSame(ceFullDataMap.validate({ strict: false }).length, 0) // data type errors handled only in strict mode currently ...\r\n    // the same but with strict mode enabled ...\r\n    const ceFullDataMapStrict = new CloudEvent('1/full/map-data/strict',\r\n      ceNamespace,\r\n      ceServerUrl,\r\n      ceMapData, // data\r\n      ceCommonOptionsStrict,\r\n      ceCommonExtensions\r\n    )\r\n    assert(ceFullDataMapStrict !== null)\r\n    t.ok(ceFullDataMapStrict)\r\n    t.ok(CloudEvent.isValidEvent(ceFullDataMapStrict))\r\n    t.ok(CloudEvent.isValidEvent(ceFullDataMapStrict, { strict: true }))\r\n    t.strictSame(CloudEvent.validateEvent(ceFullDataMapStrict).length, 0) // data type errors handled only in strict mode currently ...\r\n    t.strictSame(CloudEvent.validateEvent(ceFullDataMapStrict, { strict: true }).length, 0) // data type errors handled only in strict mode currently ...\r\n    // the same but using normal instance methods, to ensure they works good ...\r\n    t.ok(ceFullDataMapStrict.isValid())\r\n    t.ok(ceFullDataMapStrict.isValid({ strict: true }))\r\n    t.strictSame(ceFullDataMapStrict.validate().length, 0) // data type errors handled only in strict mode currently ...\r\n    t.strictSame(ceFullDataMapStrict.validate({ strict: true }).length, 0) // data type errors handled only in strict mode currently ...\r\n  }\r\n})\r\n\r\n/** @test {CloudEvent} */\r\ntest('ensure a CloudEvent/subclass instance is seen as a CloudEvent instance, but not other objects', (t) => {\r\n  t.plan(36)\r\n\r\n  const { CloudEvent, CloudEventValidator: V } = require('../src/') // get references via destructuring\r\n  t.ok(CloudEvent)\r\n\r\n  /** create some classes, for better reuse in following tests */\r\n  class NotCESubclass {\r\n  }\r\n  class CESubclass extends CloudEvent {\r\n  }\r\n\r\n  {\r\n    // check that an undefined object is not seen as a CloudEvent\r\n    const ceObject = undefined\r\n    t.strictEqual(ceObject, undefined)\r\n    t.strictEqual(ceObject instanceof CloudEvent, false)\r\n    t.ok(!V.isClass(ceObject, CloudEvent))\r\n    t.throws(function () {\r\n      const isCloudEvent = !CloudEvent.isCloudEvent(ceObject)\r\n      assert(isCloudEvent === undefined) // never executed\r\n    }, Error, 'Expected exception when calling \\'CloudEvent.isCloudEvent\\' with an undefined or null argument')\r\n  }\r\n\r\n  {\r\n    // check that a null object is not seen as a CloudEvent\r\n    const ceObject = null\r\n    t.strictEqual(typeof ceObject, 'object')\r\n    t.strictEqual(ceObject, null)\r\n    t.strictEqual(ceObject instanceof CloudEvent, false)\r\n    t.ok(!V.isClass(ceObject, CloudEvent))\r\n    t.throws(function () {\r\n      const isCloudEvent = !CloudEvent.isCloudEvent(ceObject)\r\n      assert(isCloudEvent === null) // never executed\r\n    }, Error, 'Expected exception when calling \\'CloudEvent.isCloudEvent\\' with an undefined or null argument')\r\n  }\r\n\r\n  {\r\n    // check that a generic object is not seen as a CloudEvent\r\n    const ceObject = {}\r\n    t.strictEqual(typeof ceObject, 'object')\r\n    t.strictEqual(ceObject instanceof CloudEvent, false)\r\n    t.ok(!V.isClass(ceObject, CloudEvent))\r\n    t.ok(!CloudEvent.isCloudEvent(ceObject))\r\n    t.ok(V.isStringNotEmpty(ceObject.toString()))\r\n  }\r\n\r\n  {\r\n    // check that even an empty instance belongs to the right base class\r\n    const ceEmpty = new CloudEvent()\r\n    t.strictEqual(typeof ceEmpty, 'object')\r\n    t.strictEqual(ceEmpty instanceof CloudEvent, true)\r\n    t.ok(!V.isClass(ceEmpty, NotCESubclass))\r\n    t.ok(V.isClass(ceEmpty, CloudEvent))\r\n    t.ok(!V.isClass(ceEmpty, CESubclass))\r\n    t.ok(CloudEvent.isCloudEvent(ceEmpty))\r\n    t.ok(V.isStringNotEmpty(ceEmpty.toString()))\r\n\r\n    // check that a subclass instance is seen as a CloudEvent\r\n    const ceEmptySubclass = new CESubclass()\r\n    t.strictEqual(typeof ceEmptySubclass, 'object')\r\n    t.strictEqual(ceEmptySubclass instanceof CloudEvent, true)\r\n    t.ok(!V.isClass(ceEmptySubclass, NotCESubclass))\r\n    t.ok(V.isClass(ceEmptySubclass, CloudEvent))\r\n    t.ok(V.isClass(ceEmptySubclass, CESubclass))\r\n    t.ok(CloudEvent.isCloudEvent(ceEmptySubclass))\r\n    t.ok(V.isStringNotEmpty(ceEmptySubclass.toString()))\r\n\r\n    // check that a class instance outside CloudEvent class hierarchy is not seen as a CloudEvent\r\n    const ceEmptyNoSubclass = new NotCESubclass()\r\n    t.strictEqual(typeof ceEmptyNoSubclass, 'object')\r\n    t.strictEqual(ceEmptyNoSubclass instanceof CloudEvent, false)\r\n    t.ok(V.isClass(ceEmptyNoSubclass, NotCESubclass))\r\n    t.ok(!V.isClass(ceEmptyNoSubclass, CloudEvent))\r\n    t.ok(!V.isClass(ceEmptyNoSubclass, CESubclass))\r\n    t.ok(!CloudEvent.isCloudEvent(ceEmptyNoSubclass))\r\n    t.ok(V.isStringNotEmpty(ceEmptyNoSubclass.toString()))\r\n  }\r\n})\r\n\r\n/** @test {CloudEvent} */\r\ntest('ensure CloudEvent and objects are merged in the right way', (t) => {\r\n  t.plan(14)\r\n\r\n  const { CloudEvent, CloudEventValidator: V, CloudEventTransformer: T } = require('../src/') // get references via destructuring\r\n  t.ok(V.isFunction(CloudEvent))\r\n  t.ok(V.isFunction(V))\r\n  t.ok(V.isFunction(T))\r\n  t.ok(V.isFunction(T.mergeObjects))\r\n\r\n  {\r\n    const base = new CloudEvent()\r\n    const obj = T.mergeObjects(base)\r\n    t.ok(V.isObject(obj))\r\n    t.strictSame(Object.getPrototypeOf(obj), Object.getPrototypeOf(base))\r\n  }\r\n  {\r\n    const base = new CloudEvent('1', // id\r\n      ceNamespace,\r\n      ceServerUrl,\r\n      {} // data (empty) // optional, but useful the same in this sample usage\r\n    )\r\n    t.ok(base)\r\n    t.ok(base.isValid({ strict: false })) // strict false here because base is missing some attribute, for the test\r\n    t.ok(!base.isStrict)\r\n    const obj = T.mergeObjects(base, { data: ceCommonData }, ceCommonOptions, ceExtensionStrict)\r\n    // console.log(`DEBUG - merged details: ${T.dumpObject(obj, 'obj')}`)\r\n    t.ok(obj)\r\n    t.ok(V.isObject(obj))\r\n    t.strictSame(Object.getPrototypeOf(obj), Object.getPrototypeOf(base))\r\n    t.ok(obj.isValid({ strict: true }))\r\n    t.ok(obj.isStrict)\r\n  }\r\n})\r\n\r\n/** @test {CloudEvent} */\r\ntest('ensure CloudEvent with datacontentencoding are managed in the right way', (t) => {\r\n  t.plan(72)\r\n\r\n  const { CloudEvent, CloudEventValidator: V, CloudEventTransformer: T } = require('../src/') // get references via destructuring\r\n\r\n  const ceOptionsWithDataEncoding = { ...ceCommonOptions, datacontentencoding: 'Base64' }\r\n  const ceDataAsString = 'Hello World, 2019'\r\n  const ceDataEncoded = 'SGVsbG8gV29ybGQsIDIwMTk='\r\n\r\n  {\r\n    // datacontentencoding bad (not a string), and data bad (not as a string), expect validation errors ...\r\n    const ceFull = new CloudEvent('1/full',\r\n      ceNamespace,\r\n      ceServerUrl,\r\n      ceCommonData,\r\n      { ...ceCommonOptions, datacontentencoding: {} },\r\n      ceCommonExtensions\r\n    )\r\n    t.ok(ceFull)\r\n    t.ok(!CloudEvent.isValidEvent(ceFull, { strict: false }))\r\n    t.ok(!CloudEvent.isValidEvent(ceFull, { strict: true }))\r\n    t.strictSame(CloudEvent.validateEvent(ceFull, { strict: false }).length, 1)\r\n    t.strictSame(CloudEvent.validateEvent(ceFull, { strict: true }).length, 2)\r\n    t.ok(V.isObject(ceFull.data))\r\n    t.notStrictSame(ceFull.data, ceDataAsString)\r\n    t.strictSame(T.stringFromBase64(ceDataEncoded), ceDataAsString)\r\n    t.strictSame(T.stringFromBase64(T.stringToBase64(ceDataAsString)), ceDataAsString)\r\n  }\r\n  {\r\n    // datacontentencoding good, but data not as a string here, expect validation errors ...\r\n    const ceFull = new CloudEvent('1/full',\r\n      ceNamespace,\r\n      ceServerUrl,\r\n      ceCommonData,\r\n      ceOptionsWithDataEncoding,\r\n      ceCommonExtensions\r\n    )\r\n    t.ok(ceFull)\r\n    t.ok(CloudEvent.isValidEvent(ceFull, { strict: false }))\r\n    t.ok(!CloudEvent.isValidEvent(ceFull, { strict: true }))\r\n    t.strictSame(CloudEvent.validateEvent(ceFull, { strict: false }).length, 0)\r\n    t.strictSame(CloudEvent.validateEvent(ceFull, { strict: true }).length, 1)\r\n    t.ok(V.isObject(ceFull.data))\r\n    t.notStrictSame(ceFull.data, ceDataAsString)\r\n    t.strictSame(T.stringFromBase64(ceDataEncoded), ceDataAsString)\r\n    t.strictSame(T.stringFromBase64(T.stringToBase64(ceDataAsString)), ceDataAsString)\r\n  }\r\n  {\r\n    // datacontentencoding custom (so not supported), and data as a string here (good), expect no validation errors ...\r\n    const ceFull = new CloudEvent('1/full',\r\n      ceNamespace,\r\n      ceServerUrl,\r\n      ceDataAsString,\r\n      { ...ceCommonOptions, datacontentencoding: 'Custom encoding' },\r\n      ceCommonExtensions\r\n    )\r\n    t.ok(ceFull)\r\n    t.ok(CloudEvent.isValidEvent(ceFull, { strict: false }))\r\n    t.ok(CloudEvent.isValidEvent(ceFull, { strict: true }))\r\n    t.strictSame(CloudEvent.validateEvent(ceFull, { strict: false }).length, 0)\r\n    t.strictSame(CloudEvent.validateEvent(ceFull, { strict: true }).length, 0)\r\n    t.ok(V.isString(ceFull.data))\r\n    t.strictSame(ceFull.data, ceDataAsString)\r\n    t.strictSame(T.stringFromBase64(ceDataEncoded), ceDataAsString)\r\n    t.strictSame(T.stringFromBase64(T.stringToBase64(ceDataAsString)), ceDataAsString)\r\n  }\r\n  {\r\n    // datacontentencoding good, and data as a string here (good), expect no validation errors ...\r\n    const ceFull = new CloudEvent('1/full',\r\n      ceNamespace,\r\n      ceServerUrl,\r\n      ceDataAsString,\r\n      ceOptionsWithDataEncoding,\r\n      ceCommonExtensions\r\n    )\r\n    t.ok(ceFull)\r\n    t.ok(CloudEvent.isValidEvent(ceFull, { strict: false }))\r\n    t.ok(CloudEvent.isValidEvent(ceFull, { strict: true }))\r\n    t.strictSame(CloudEvent.validateEvent(ceFull, { strict: false }).length, 0)\r\n    t.strictSame(CloudEvent.validateEvent(ceFull, { strict: true }).length, 0)\r\n    t.ok(V.isString(ceFull.data))\r\n    t.strictSame(ceFull.data, ceDataAsString)\r\n    t.strictSame(T.stringFromBase64(ceDataEncoded), ceDataAsString)\r\n    t.strictSame(T.stringFromBase64(T.stringToBase64(ceDataAsString)), ceDataAsString)\r\n  }\r\n\r\n  // the same but with strict mode ...\r\n  // note that in this case validation will use the strict flag set into ce instance ...\r\n  {\r\n    // datacontentencoding bad (not a string), and data bad (not as a string), expect validation errors ...\r\n    const ceFull = new CloudEvent('1/full-strict',\r\n      ceNamespace,\r\n      ceServerUrl,\r\n      ceCommonData,\r\n      { ...ceCommonOptions, datacontentencoding: {}, strict: true },\r\n      ceCommonExtensions\r\n    )\r\n    t.ok(ceFull)\r\n    t.ok(!CloudEvent.isValidEvent(ceFull, { strict: false }))\r\n    t.ok(!CloudEvent.isValidEvent(ceFull, { strict: true }))\r\n    t.strictSame(CloudEvent.validateEvent(ceFull, { strict: false }).length, 2)\r\n    t.strictSame(CloudEvent.validateEvent(ceFull, { strict: true }).length, 2)\r\n    t.ok(V.isObject(ceFull.data))\r\n    t.notStrictSame(ceFull.data, ceDataAsString)\r\n    t.strictSame(T.stringFromBase64(ceDataEncoded), ceDataAsString)\r\n    t.strictSame(T.stringFromBase64(T.stringToBase64(ceDataAsString)), ceDataAsString)\r\n  }\r\n  {\r\n    // datacontentencoding good, but data not as a string here, expect validation errors ...\r\n    const ceFull = new CloudEvent('1/full-strict',\r\n      ceNamespace,\r\n      ceServerUrl,\r\n      ceCommonData,\r\n      { ...ceOptionsWithDataEncoding, strict: true },\r\n      ceCommonExtensions\r\n    )\r\n    t.ok(ceFull)\r\n    t.ok(!CloudEvent.isValidEvent(ceFull, { strict: false }))\r\n    t.ok(!CloudEvent.isValidEvent(ceFull, { strict: true }))\r\n    t.strictSame(CloudEvent.validateEvent(ceFull, { strict: false }).length, 1)\r\n    t.strictSame(CloudEvent.validateEvent(ceFull, { strict: true }).length, 1)\r\n    t.ok(V.isObject(ceFull.data))\r\n    t.notStrictSame(ceFull.data, ceDataAsString)\r\n    t.strictSame(T.stringFromBase64(ceDataEncoded), ceDataAsString)\r\n    t.strictSame(T.stringFromBase64(T.stringToBase64(ceDataAsString)), ceDataAsString)\r\n  }\r\n  {\r\n    // datacontentencoding custom (so not supported), and data as a string here (good), expect no validation errors ...\r\n    const ceFull = new CloudEvent('1/full-strict',\r\n      ceNamespace,\r\n      ceServerUrl,\r\n      ceDataAsString,\r\n      { ...ceCommonOptions, datacontentencoding: 'Custom encoding', strict: true },\r\n      ceCommonExtensions\r\n    )\r\n    t.ok(ceFull)\r\n    t.ok(CloudEvent.isValidEvent(ceFull, { strict: false }))\r\n    t.ok(CloudEvent.isValidEvent(ceFull, { strict: true }))\r\n    t.strictSame(CloudEvent.validateEvent(ceFull, { strict: false }).length, 0)\r\n    t.strictSame(CloudEvent.validateEvent(ceFull, { strict: true }).length, 0)\r\n    t.ok(V.isString(ceFull.data))\r\n    t.strictSame(ceFull.data, ceDataAsString)\r\n    t.strictSame(T.stringFromBase64(ceDataEncoded), ceDataAsString)\r\n    t.strictSame(T.stringFromBase64(T.stringToBase64(ceDataAsString)), ceDataAsString)\r\n  }\r\n  {\r\n    // datacontentencoding good, and data as a string here (good), expect no validation errors ...\r\n    const ceFull = new CloudEvent('1/full-strict',\r\n      ceNamespace,\r\n      ceServerUrl,\r\n      ceDataAsString,\r\n      { ...ceOptionsWithDataEncoding, strict: true },\r\n      ceCommonExtensions\r\n    )\r\n    t.ok(ceFull)\r\n    t.ok(CloudEvent.isValidEvent(ceFull, { strict: false }))\r\n    t.ok(CloudEvent.isValidEvent(ceFull, { strict: true }))\r\n    t.strictSame(CloudEvent.validateEvent(ceFull, { strict: false }).length, 0)\r\n    t.strictSame(CloudEvent.validateEvent(ceFull, { strict: true }).length, 0)\r\n    t.ok(V.isString(ceFull.data))\r\n    t.strictSame(ceFull.data, ceDataAsString)\r\n    t.strictSame(T.stringFromBase64(ceDataEncoded), ceDataAsString)\r\n    t.strictSame(T.stringFromBase64(T.stringToBase64(ceDataAsString)), ceDataAsString)\r\n  }\r\n})\r\n",
    "static": true,
    "longname": "/Users/martinis/work/prove/cloudevent.js/test/cloudevent.test.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 194,
    "kind": "test",
    "name": "test14",
    "testId": 14,
    "memberof": "test/cloudevent.test.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/cloudevent.test.js~test14",
    "access": null,
    "description": "ensure CloudEvent class (and related Validator and Transformer classes) are exported by the library",
    "lineNumber": 36,
    "testTargets": [
      "CloudEvent"
    ]
  },
  {
    "__docId__": 195,
    "kind": "test",
    "name": "test15",
    "testId": 15,
    "memberof": "test/cloudevent.test.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/cloudevent.test.js~test15",
    "access": null,
    "description": "ensure isValid and validate works good on undefined and null objects",
    "lineNumber": 96,
    "testTargets": [
      "CloudEvent"
    ]
  },
  {
    "__docId__": 196,
    "kind": "test",
    "name": "test16",
    "testId": 16,
    "memberof": "test/cloudevent.test.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/cloudevent.test.js~test16",
    "access": null,
    "description": "create some CloudEvent instances (empty, without minimal arguments set or not set) and ensure they are different objects",
    "lineNumber": 113,
    "testTargets": [
      "CloudEvent"
    ]
  },
  {
    "__docId__": 197,
    "kind": "test",
    "name": "test17",
    "testId": 17,
    "memberof": "test/cloudevent.test.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/cloudevent.test.js~test17",
    "access": null,
    "description": "create some CloudEvent instances (with minimal fields set) and ensure they are different objects",
    "lineNumber": 157,
    "testTargets": [
      "CloudEvent"
    ]
  },
  {
    "__docId__": 198,
    "kind": "test",
    "name": "test18",
    "testId": 18,
    "memberof": "test/cloudevent.test.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/cloudevent.test.js~test18",
    "access": null,
    "description": "ensure strict mode is managed in the right way",
    "lineNumber": 255,
    "testTargets": [
      "CloudEvent"
    ]
  },
  {
    "__docId__": 199,
    "kind": "test",
    "name": "test19",
    "testId": 19,
    "memberof": "test/cloudevent.test.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/cloudevent.test.js~test19",
    "access": null,
    "description": "ensure extensions are managed in the right way",
    "lineNumber": 294,
    "testTargets": [
      "CloudEvent"
    ]
  },
  {
    "__docId__": 200,
    "kind": "test",
    "name": "test20",
    "testId": 20,
    "memberof": "test/cloudevent.test.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/cloudevent.test.js~test20",
    "access": null,
    "description": "create two CloudEvent instances with all arguments (mandatory and optional arguments) and ensure they are different objects",
    "lineNumber": 364,
    "testTargets": [
      "CloudEvent"
    ]
  },
  {
    "__docId__": 201,
    "kind": "test",
    "name": "test21",
    "testId": 21,
    "memberof": "test/cloudevent.test.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/cloudevent.test.js~test21",
    "access": null,
    "description": "create CloudEvent instances with different kind of data attribute, and ensure the validation is right",
    "lineNumber": 414,
    "testTargets": [
      "CloudEvent"
    ]
  },
  {
    "__docId__": 202,
    "kind": "test",
    "name": "test22",
    "testId": 22,
    "memberof": "test/cloudevent.test.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/cloudevent.test.js~test22",
    "access": null,
    "description": "ensure a CloudEvent/subclass instance is seen as a CloudEvent instance, but not other objects",
    "lineNumber": 599,
    "testTargets": [
      "CloudEvent"
    ]
  },
  {
    "__docId__": 203,
    "kind": "test",
    "name": "test23",
    "testId": 23,
    "memberof": "test/cloudevent.test.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/cloudevent.test.js~test23",
    "access": null,
    "description": "ensure CloudEvent and objects are merged in the right way",
    "lineNumber": 680,
    "testTargets": [
      "CloudEvent"
    ]
  },
  {
    "__docId__": 204,
    "kind": "test",
    "name": "test24",
    "testId": 24,
    "memberof": "test/cloudevent.test.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/cloudevent.test.js~test24",
    "access": null,
    "description": "ensure CloudEvent with datacontentencoding are managed in the right way",
    "lineNumber": 715,
    "testTargets": [
      "CloudEvent"
    ]
  },
  {
    "__docId__": 205,
    "kind": "testFile",
    "name": "test/index.test.js",
    "content": "/*\r\n * Copyright 2018 the original author or authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n'use strict'\r\n\r\nconst assert = require('assert').strict\r\nconst test = require('tap').test\r\n\r\n/** @test {CloudEvent} */\r\ntest('ensure objects exported by index script, exists and are of the right type', (t) => {\r\n  t.plan(25)\r\n\r\n  {\r\n    const CloudEventExports = require('../src/') // reference the library\r\n    assert(CloudEventExports !== null)\r\n    assert.strictEqual(typeof CloudEventExports, 'object')\r\n    t.ok(CloudEventExports)\r\n    t.strictEqual(typeof CloudEventExports, 'object')\r\n    const CloudEventClass = CloudEventExports.CloudEvent // reference the implementation class\r\n    t.ok(CloudEventClass)\r\n    t.strictEqual(typeof CloudEventClass, 'function')\r\n    const CloudEventValidator = CloudEventExports.CloudEventValidator // reference the validator class\r\n    t.ok(CloudEventValidator)\r\n    t.strictEqual(typeof CloudEventValidator, 'function')\r\n    const CloudEventTransformer = CloudEventExports.CloudEventTransformer // reference the transformer class\r\n    t.ok(CloudEventTransformer)\r\n    t.strictEqual(typeof CloudEventTransformer, 'function')\r\n    const JSONBatchClass = CloudEventExports.JSONBatch // reference the implementation class\r\n    t.ok(JSONBatchClass)\r\n    t.strictEqual(typeof JSONBatchClass, 'function')\r\n  }\r\n\r\n  {\r\n    const { CloudEvent: CEClass, JSONBatch: JSONBClass, CloudEventValidator: V, CloudEventTransformer: T } = require('../src/') // get references via destructuring\r\n    // const { CloudEvent, JSONBatch, CloudEventValidator: V, CloudEventTransformer: T } = require('../src/') // get references via destructuring\r\n    t.strictEqual(typeof CEClass, 'function')\r\n    t.strictEqual(typeof V.isClass, 'function')\r\n    t.strictEqual(typeof T.dumpObject, 'function')\r\n    t.strictEqual(typeof JSONBClass, 'function')\r\n    t.ok(V.isFunction(CEClass))\r\n    t.ok(V.isFunction(V.isClass))\r\n    t.ok(V.isFunction(T.dumpObject))\r\n    t.ok(V.isFunction(JSONBClass))\r\n\r\n    const { CloudEvent, JSONBatch } = require('../src/') // get references via destructuring\r\n    t.ok(CloudEvent)\r\n    t.strictEqual(typeof CloudEvent, 'function')\r\n    t.ok(JSONBatch)\r\n    t.strictEqual(typeof JSONBatch, 'function')\r\n\r\n    // create an instance with only mandatory arguments (no strict mode, but doesn't matter in this case): expected success ...\r\n    const ceMinimal = new CEClass('1', // id\r\n      'com.github.smartiniOnGitHub.cloudeventjs.testevent', // type\r\n      '/', // source\r\n      {} // data (empty) // optional, but useful the same in this sample usage\r\n    )\r\n    t.ok(ceMinimal)\r\n    // console.log(`DEBUG - cloudEvent details: ceMinimal = ${JSON.stringify(ceMinimal)}`)\r\n    // console.log(`DEBUG - cloudEvent details: ${T.dumpObject(ceMinimal, 'ceMinimal')}`)\r\n\r\n    // check that created instances belongs to the right base class\r\n    t.ok(V.isClass(ceMinimal, CloudEvent))\r\n    t.ok(V.isClass(ceMinimal, CEClass))\r\n  }\r\n})\r\n",
    "static": true,
    "longname": "/Users/martinis/work/prove/cloudevent.js/test/index.test.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 206,
    "kind": "test",
    "name": "test25",
    "testId": 25,
    "memberof": "test/index.test.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/index.test.js~test25",
    "access": null,
    "description": "ensure objects exported by index script, exists and are of the right type",
    "lineNumber": 22,
    "testTargets": [
      "CloudEvent"
    ]
  },
  {
    "__docId__": 207,
    "kind": "testFile",
    "name": "test/jsonbatch-serialization.test.js",
    "content": "/*\r\n * Copyright 2018 the original author or authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n'use strict'\r\n\r\nconst assert = require('assert').strict\r\nconst test = require('tap').test\r\n\r\n// import some common test data\r\nconst {\r\n  ceCommonOptions,\r\n  ceCommonOptionsStrict,\r\n  ceCommonExtensions,\r\n  ceNamespace,\r\n  ceServerUrl,\r\n  ceCommonData\r\n} = require('./common-test-data')\r\n\r\n/** create a sample string big (more than 64 KB) */\r\nconst ceBigStringLength = 100000\r\nconst ceBigString = getRandomString(ceBigStringLength) // a random string with n chars\r\n\r\n// sample function to calculate a random string, given the length, to use in tests here\r\nfunction getRandomString (length) {\r\n  let str = Math.random().toString(36).substr(2)\r\n  while (str.length < length) {\r\n    str += Math.random().toString(36).substr(2)\r\n  }\r\n  return str.substr(0, length)\r\n}\r\n\r\n/** @test {CloudEvent} */\r\ntest('ensure serialization functions exists (check only the static method here)', (t) => {\r\n  t.plan(12)\r\n\r\n  {\r\n    const { CloudEvent, JSONBatch } = require('../src/') // get references via destructuring\r\n    t.ok(CloudEvent)\r\n    t.ok(JSONBatch)\r\n    // optional, using some standard Node.js assert statements, as a sample\r\n    assert(CloudEvent !== null)\r\n    assert.strictEqual(typeof CloudEvent, 'function')\r\n    assert(new CloudEvent() instanceof CloudEvent)\r\n    assert.strictEqual(CloudEvent.mediaType(), 'application/cloudevents+json')\r\n    assert(JSONBatch !== null)\r\n    assert.strictEqual(typeof JSONBatch, 'function')\r\n    assert.strictEqual(JSONBatch.mediaType(), 'application/cloudevents-batch+json')\r\n    t.strictEqual(typeof CloudEvent, 'function')\r\n    t.strictEqual(new CloudEvent() instanceof CloudEvent, true)\r\n    t.strictEqual(CloudEvent.mediaType(), 'application/cloudevents+json')\r\n    t.strictEqual(typeof JSONBatch, 'function')\r\n    t.throws(function () {\r\n      const batch = new JSONBatch()\r\n      assert(batch === null) // never executed\r\n    }, Error, 'Expected exception when creating a JSONBatch instance')\r\n    t.strictEqual(JSONBatch.mediaType(), 'application/cloudevents-batch+json')\r\n\r\n    const batchSerialize = JSONBatch.serializeEvents\r\n    assert(batchSerialize !== null)\r\n    assert(typeof batchSerialize === 'function')\r\n    t.ok(batchSerialize)\r\n    t.strictEqual(typeof batchSerialize, 'function')\r\n\r\n    const batchDeserialize = JSONBatch.deserializeEvents\r\n    assert(batchDeserialize !== null)\r\n    assert(typeof batchDeserialize === 'function')\r\n    t.ok(batchDeserialize)\r\n    t.strictEqual(typeof batchDeserialize, 'function')\r\n  }\r\n})\r\n\r\n/** @test {JSONBatch} */\r\ntest('ensure serialization functions works good on undefined and null arguments, and even on empty and bad ones', (t) => {\r\n  t.plan(20)\r\n  const { JSONBatch } = require('../src/')\r\n  t.ok(JSONBatch)\r\n\r\n  // in following tests to simplify comparison of results, check only the  number of expected errors ...\r\n  {\r\n    // undefined\r\n    const arg = undefined\r\n    t.notOk(arg)\r\n    t.throws(function () {\r\n      const ser = JSONBatch.serializeEvents(arg)\r\n      assert(ser === null) // never executed\r\n    }, Error, 'JSONBatch undefined or null')\r\n    t.throws(function () {\r\n      const deser = JSONBatch.deserializeEvents(arg)\r\n      assert(deser === null) // never executed\r\n    }, Error, 'Missing or wrong serialized data ...')\r\n  }\r\n  {\r\n    // null\r\n    const arg = null\r\n    t.notOk(arg)\r\n    t.throws(function () {\r\n      const ser = JSONBatch.serializeEvents(arg)\r\n      assert(ser === null) // never executed\r\n    }, Error, 'JSONBatch undefined or null')\r\n    t.throws(function () {\r\n      const deser = JSONBatch.deserializeEvents(arg)\r\n      assert(deser === null) // never executed\r\n    }, Error, 'Missing or wrong serialized data ...')\r\n  }\r\n  {\r\n    // empty array\r\n    const arg = []\r\n    t.strictSame(JSONBatch.serializeEvents(arg), '[]')\r\n    t.throws(function () {\r\n      const deser = JSONBatch.deserializeEvents(arg)\r\n      assert(deser === null) // never executed\r\n    }, Error, 'Missing or wrong serialized data ...')\r\n    // deserialize a string containing only an empty array\r\n    const deser = JSONBatch.deserializeEvents(JSON.stringify(arg))\r\n    t.ok(deser && deser.length === 0 && JSONBatch.isJSONBatch(deser))\r\n  }\r\n  {\r\n    // empty array with prettyPrint enabled\r\n    const arg = []\r\n    const ser = JSONBatch.serializeEvents(arg, { prettyPrint: true })\r\n    const expectedSer = '[\\n]'\r\n    t.strictSame(ser, expectedSer)\r\n    // deserialize a string containing only an empty array\r\n    const deser = JSONBatch.deserializeEvents(expectedSer)\r\n    t.ok(deser && deser.length === 0 && JSONBatch.isJSONBatch(deser))\r\n  }\r\n  {\r\n    // empty object (not a CloudEvent/subclass instance)\r\n    const arg = {}\r\n    t.throws(function () {\r\n      const ser = JSONBatch.serializeEvents(arg)\r\n      assert(ser === null) // never executed\r\n    }, TypeError, 'The given batch is not a JSONBatch')\r\n    t.throws(function () {\r\n      const deser = JSONBatch.deserializeEvents(arg)\r\n      assert(deser === null) // never executed\r\n    }, Error, 'Missing or wrong serialized data ...')\r\n  }\r\n  {\r\n    // bad object type\r\n    const arg = 'Sample string'\r\n    t.throws(function () {\r\n      const ser = JSONBatch.serializeEvents(arg)\r\n      assert(ser === null) // never executed\r\n    }, TypeError, 'The given batch is not a JSONBatch')\r\n    t.throws(function () {\r\n      const deser = JSONBatch.deserializeEvents(arg)\r\n      assert(deser === null) // never executed\r\n    }, TypeError, 'The given string is not an array representation')\r\n  }\r\n  {\r\n    // bad object type\r\n    const arg = 1234567890\r\n    t.throws(function () {\r\n      const ser = JSONBatch.serializeEvents(arg)\r\n      assert(ser === null) // never executed\r\n    }, TypeError, 'The given batch is not a JSONBatch')\r\n    t.throws(function () {\r\n      const deser = JSONBatch.deserializeEvents(arg)\r\n      assert(deser === null) // never executed\r\n    }, Error, 'Missing or wrong serialized data ...')\r\n  }\r\n  {\r\n    // bad object type\r\n    const arg = new Date()\r\n    t.throws(function () {\r\n      const ser = JSONBatch.serializeEvents(arg)\r\n      assert(ser === null) // never executed\r\n    }, TypeError, 'The given batch is not a JSONBatch')\r\n    t.throws(function () {\r\n      const deser = JSONBatch.deserializeEvents(arg)\r\n      assert(deser === null) // never executed\r\n    }, Error, 'Missing or wrong serialized data ...')\r\n  }\r\n})\r\n\r\n/** @test {CloudEvent} */\r\ntest('ensure serialization functions works in the right way', (t) => {\r\n  t.plan(19)\r\n  const { CloudEvent, JSONBatch } = require('../src/')\r\n  t.ok(JSONBatch)\r\n\r\n  const ceFull = new CloudEvent('1/full',\r\n    ceNamespace,\r\n    ceServerUrl,\r\n    // ceCommonData,\r\n    'sample data', // data as string, to let this ce instance have some strict validation errors\r\n    ceCommonOptions,\r\n    // ceCommonExtensions\r\n    {} // extensions as empty object, to let this ce instance have some strict validation errors\r\n  )\r\n  const ceFullStrict = new CloudEvent('1/full-strict',\r\n    ceNamespace,\r\n    ceServerUrl,\r\n    ceCommonData,\r\n    ceCommonOptionsStrict,\r\n    ceCommonExtensions\r\n  )\r\n  // test even when a bad (not valid) instance is inside the array\r\n  const ceFullBad = new CloudEvent(null,\r\n    ceNamespace,\r\n    ceServerUrl,\r\n    // ceCommonData, // data\r\n    { random: ceBigString }, // data\r\n    ceCommonOptions,\r\n    ceCommonExtensions\r\n  )\r\n  // define an array containing different CloudEvent instances, and even other objects ...\r\n  const arr = [\r\n    undefined,\r\n    null,\r\n    'string',\r\n    1234567890,\r\n    false,\r\n    true,\r\n    ceFull,\r\n    new Date(),\r\n    {},\r\n    [],\r\n    ceFullStrict,\r\n    null,\r\n    undefined,\r\n    ceFullBad\r\n  ]\r\n\r\n  // in following tests to simplify comparison of results, do only some brief checks ...\r\n  const ser = JSONBatch.serializeEvents(arr, { prettyPrint: true, logError: true })\r\n  // console.log(`DEBUG: serialized JSONBatch (prettyPrint enabled) = ${ser}`)\r\n  assert(ser !== null)\r\n  t.ok(ser)\r\n\r\n  t.throws(function () {\r\n    const serNoBig = JSONBatch.serializeEvents(arr, {\r\n      // prettyPrint: true,\r\n      logError: true,\r\n      throwError: true,\r\n      // onlyValid: true, // commented otherwise it will be filtered out by getEvents ...\r\n      onlyIfLessThan64KB: true // to force throw here ...\r\n    })\r\n    assert(serNoBig === null) // never executed\r\n  }, Error, 'No serialization here due to selected flags (and a big instance) ...')\r\n\r\n  const events = JSONBatch.getEvents(arr, {\r\n    onlyValid: true,\r\n    strict: false\r\n  })\r\n  // console.log(`DEBUG: events JSONBatch length = ${events.length}, summary: ${events}`)\r\n  // console.log(`DEBUG: events JSONBatch length = ${events.length}, details: ${JSON.stringify(events)}`)\r\n  assert(events !== null)\r\n  t.ok(events)\r\n  t.strictSame(events.length, 2)\r\n\r\n  const deser = JSONBatch.deserializeEvents(ser, {\r\n    logError: true,\r\n    throwError: true,\r\n    onlyValid: true // sample, to filter out not valid serialized instances ...\r\n    // onlyIfLessThan64KB: true // to force throw here ...\r\n  })\r\n  // console.log(`DEBUG: deserialized JSONBatch length = ${deser.length}, summary: ${deser}`)\r\n  // console.log(`DEBUG: deserialized JSONBatch length = ${deser.length}, details: ${JSON.stringify(deser)}`)\r\n  assert(deser !== null)\r\n  t.ok(deser)\r\n  t.strictSame(deser.length, 2)\r\n\r\n  // ensure events and deser contains similar CloudEvent instances\r\n  t.strictSame(events.length, deser.length)\r\n  events.forEach((e, i) => t.ok(e.id === deser[i].id)) // this count events.length tests ...\r\n  events.forEach((e, i) => t.ok(e.isStrict === deser[i].isStrict)) // this count events.length tests ...\r\n\r\n  t.throws(function () {\r\n    const deserNoWrongArray = JSONBatch.deserializeEvents('[,]', {})\r\n    assert(deserNoWrongArray === null) // never executed\r\n  }, Error, 'No deserialization here due to selected flags (and a bad deserialization string) ...')\r\n\r\n  const deserNoWrong = JSONBatch.deserializeEvents('[\"x\"]', {})\r\n  assert(deserNoWrong !== null)\r\n  t.ok(deserNoWrong)\r\n  t.strictSame(deserNoWrong.length, 0)\r\n\r\n  t.throws(function () {\r\n    const deserNoWrongArrayRaiseError = JSONBatch.deserializeEvents('[,]', {\r\n      logError: true,\r\n      throwError: true\r\n    })\r\n    assert(deserNoWrongArrayRaiseError === null) // never executed\r\n  }, Error, 'No deserialization here due to selected flags (and a bad deserialization string) ...')\r\n\r\n  const eventsEvenBad = JSONBatch.getEvents(arr, {})\r\n  const serEventsEvenBad = JSONBatch.serializeEvents(eventsEvenBad, {})\r\n  const deserStrict = JSONBatch.deserializeEvents(serEventsEvenBad, {\r\n    onlyValid: true, // sample, to filter out not valid serialized instances ...\r\n    // onlyIfLessThan64KB: true, // to force throw here ...\r\n    strict: true // to force strict validation ...\r\n  })\r\n  assert(deserStrict !== null)\r\n  t.ok(deserStrict)\r\n  t.strictSame(deserStrict.length, 1)\r\n\r\n  t.throws(function () {\r\n    const deserStrictRaiseError = JSONBatch.deserializeEvents(serEventsEvenBad, {\r\n      logError: true,\r\n      throwError: true,\r\n      onlyValid: true, // sample, to filter out not valid serialized instances ...\r\n      // onlyIfLessThan64KB: true, // to force throw here ...\r\n      strict: true // to force strict validation ...\r\n    })\r\n    assert(deserStrictRaiseError === null) // never executed\r\n  }, Error, 'No deserialization here due to selected flags (and errors in deserialization content) ...')\r\n})\r\n",
    "static": true,
    "longname": "/Users/martinis/work/prove/cloudevent.js/test/jsonbatch-serialization.test.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 208,
    "kind": "test",
    "name": "test26",
    "testId": 26,
    "memberof": "test/jsonbatch-serialization.test.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/jsonbatch-serialization.test.js~test26",
    "access": null,
    "description": "ensure serialization functions exists (check only the static method here)",
    "lineNumber": 46,
    "testTargets": [
      "CloudEvent"
    ]
  },
  {
    "__docId__": 209,
    "kind": "test",
    "name": "test27",
    "testId": 27,
    "memberof": "test/jsonbatch-serialization.test.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/jsonbatch-serialization.test.js~test27",
    "access": null,
    "description": "ensure serialization functions works good on undefined and null arguments, and even on empty and bad ones",
    "lineNumber": 86,
    "testTargets": [
      "JSONBatch"
    ]
  },
  {
    "__docId__": 210,
    "kind": "test",
    "name": "test28",
    "testId": 28,
    "memberof": "test/jsonbatch-serialization.test.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/jsonbatch-serialization.test.js~test28",
    "access": null,
    "description": "ensure serialization functions works in the right way",
    "lineNumber": 191,
    "testTargets": [
      "CloudEvent"
    ]
  },
  {
    "__docId__": 211,
    "kind": "testFile",
    "name": "test/jsonbatch.test.js",
    "content": "/*\r\n * Copyright 2018 the original author or authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n'use strict'\r\n\r\nconst assert = require('assert').strict\r\nconst test = require('tap').test\r\n\r\n// import some common test data\r\nconst {\r\n  ceCommonOptions,\r\n  ceCommonOptionsStrict,\r\n  ceCommonExtensions,\r\n  ceNamespace,\r\n  ceServerUrl,\r\n  ceCommonData\r\n} = require('./common-test-data')\r\n\r\n/** @test {CloudEvent} */\r\ntest('ensure CloudEvent and JSONBatch class (and related Validator and Transformer classes) are exported by the library', (t) => {\r\n  t.plan(26)\r\n\r\n  const { CloudEvent, JSONBatch, CloudEventValidator: V, CloudEventTransformer: T } = require('../src/') // get references via destructuring\r\n  t.ok(CloudEvent)\r\n  t.ok(JSONBatch)\r\n  // optional, using some standard Node.js assert statements, as a sample\r\n  assert(CloudEvent !== null)\r\n  assert.strictEqual(typeof CloudEvent, 'function')\r\n  assert(new CloudEvent() instanceof CloudEvent)\r\n  assert.strictEqual(CloudEvent.mediaType(), 'application/cloudevents+json')\r\n  assert(JSONBatch !== null)\r\n  assert.strictEqual(typeof JSONBatch, 'function')\r\n  assert.strictEqual(JSONBatch.mediaType(), 'application/cloudevents-batch+json')\r\n  t.ok(V)\r\n  t.strictEqual(typeof CloudEvent, 'function')\r\n  t.strictEqual(typeof JSONBatch, 'function')\r\n  t.strictEqual(typeof V, 'function')\r\n  t.strictEqual(typeof T, 'function')\r\n  t.ok(V.isFunction(CloudEvent))\r\n  t.ok(V.isFunction(JSONBatch))\r\n  t.ok(V.isFunction(V))\r\n  t.ok(V.isFunction(T))\r\n  t.strictEqual(typeof CloudEvent, 'function')\r\n  t.strictEqual(new CloudEvent() instanceof CloudEvent, true)\r\n  t.strictEqual(CloudEvent.mediaType(), 'application/cloudevents+json')\r\n  t.strictEqual(typeof JSONBatch, 'function')\r\n  t.strictEqual(JSONBatch.mediaType(), 'application/cloudevents-batch+json')\r\n\r\n  t.throws(function () {\r\n    const jsonBatch = new JSONBatch()\r\n    assert(jsonBatch === null) // never executed\r\n  }, Error, 'Expected exception when creating a JSONBatch instance')\r\n\r\n  {\r\n    // create an instance with only mandatory arguments (no strict mode, but doesn't matter in this case): expected success ...\r\n    const ceMinimal = new CloudEvent('1', // id\r\n      ceNamespace, // type\r\n      '/', // source\r\n      {} // data (empty) // optional, but useful the same in this sample usage\r\n    )\r\n    t.ok(ceMinimal)\r\n    // console.log(`DEBUG - cloudEvent details: ceMinimal = ${JSON.stringify(ceMinimal)}`)\r\n    // console.log(`DEBUG - cloudEvent details: ${T.dumpObject(ceMinimal, 'ceMinimal')}`)\r\n\r\n    // check that created instances belongs to the right base class\r\n    t.strictEqual(typeof ceMinimal, 'object')\r\n    t.ok(V.isClass(ceMinimal, CloudEvent))\r\n  }\r\n\r\n  {\r\n    // create an instance with only mandatory arguments but null data (and strict mode): expected success ...\r\n    const ceMinimalStrict = new CloudEvent('1-strict', // id\r\n      ceNamespace, // type\r\n      '/', // source\r\n      null // data // optional, but useful the same in this sample usage\r\n    )\r\n    t.ok(ceMinimalStrict)\r\n\r\n    // check that created instances belongs to the right base class\r\n    t.strictEqual(typeof ceMinimalStrict, 'object')\r\n    t.ok(V.isClass(ceMinimalStrict, CloudEvent))\r\n\r\n    t.strictEqual(typeof ceMinimalStrict.data, 'object') // data is wrapped in an object, so even when null it's an object\r\n    t.ok(CloudEvent.isValidEvent(ceMinimalStrict))\r\n\r\n    // set ceMinimalStrict.data to null, to ensure validation is good the same\r\n    ceMinimalStrict.data = null\r\n    t.ok(CloudEvent.isValidEvent(ceMinimalStrict))\r\n  }\r\n})\r\n\r\n/** @test {JSONBatch} */\r\ntest('ensure isValid and validate works good on undefined and null arguments, and even on empty and bad ones', (t) => {\r\n  t.plan(23)\r\n  const { JSONBatch } = require('../src/')\r\n  t.ok(JSONBatch)\r\n\r\n  // in following tests to simplify comparison of results, check only the  number of expected errors ...\r\n  {\r\n    // undefined\r\n    const arg = undefined\r\n    t.notOk(arg)\r\n    t.notOk(JSONBatch.isValidBatch())\r\n    t.strictSame(JSONBatch.validateBatch(), [new Error('JSONBatch undefined or null')])\r\n    t.strictSame(JSONBatch.validateBatch(arg).length, 1)\r\n    t.strictSame(JSONBatch.validateBatch(arg, { strict: true }).length, 1)\r\n  }\r\n  {\r\n    // null\r\n    const arg = null\r\n    t.notOk(arg)\r\n    t.notOk(JSONBatch.isValidBatch(arg))\r\n    t.strictSame(JSONBatch.validateBatch(arg), [new Error('JSONBatch undefined or null')])\r\n    t.strictSame(JSONBatch.validateBatch(arg).length, 1)\r\n    t.strictSame(JSONBatch.validateBatch(arg, { strict: true }).length, 1)\r\n  }\r\n  {\r\n    // empty array\r\n    const arg = []\r\n    t.strictSame(JSONBatch.validateBatch(arg), [])\r\n    t.strictSame(JSONBatch.validateBatch(arg).length, 0)\r\n    t.strictSame(JSONBatch.validateBatch(arg, { strict: true }).length, 0)\r\n  }\r\n  {\r\n    // empty object (not a CloudEvent/subclass instance)\r\n    const arg = {}\r\n    t.strictSame(JSONBatch.validateBatch(arg), [new TypeError(\"The argument 'batch' must be an array or a CloudEvent instance (or a subclass), instead got a 'object'\")])\r\n    t.strictSame(JSONBatch.validateBatch(arg).length, 1)\r\n    t.strictSame(JSONBatch.validateBatch(arg, { strict: true }).length, 1)\r\n  }\r\n  {\r\n    // bad object type\r\n    const arg = 'Sample string'\r\n    t.strictSame(JSONBatch.validateBatch(arg).length, 1)\r\n    t.strictSame(JSONBatch.validateBatch(arg, { strict: true }).length, 1)\r\n  }\r\n  {\r\n    // bad object type\r\n    const arg = 1234567890\r\n    t.strictSame(JSONBatch.validateBatch(arg).length, 1)\r\n    t.strictSame(JSONBatch.validateBatch(arg, { strict: true }).length, 1)\r\n  }\r\n  {\r\n    // bad object type\r\n    const arg = new Date()\r\n    t.strictSame(JSONBatch.validateBatch(arg).length, 1)\r\n    t.strictSame(JSONBatch.validateBatch(arg, { strict: true }).length, 1)\r\n  }\r\n})\r\n\r\n/** @test {JSONBatch} */\r\ntest('ensure isValid and validate works good on array and related items', (t) => {\r\n  t.plan(39)\r\n  const { CloudEvent, JSONBatch, CloudEventValidator: V } = require('../src/')\r\n  t.ok(CloudEvent)\r\n  t.ok(JSONBatch)\r\n  t.ok(V)\r\n\r\n  const empty = []\r\n  t.ok(empty)\r\n  t.ok(JSONBatch.isJSONBatch(empty))\r\n  t.ok(JSONBatch.isValidBatch(empty))\r\n  t.strictSame(JSONBatch.validateBatch(empty, { strict: false }).length, 0)\r\n  t.strictSame(JSONBatch.validateBatch(empty, { strict: true }).length, 0)\r\n  t.strictSame(JSONBatch.getEvents(empty, { onlyValid: false, strict: false }).length, 0)\r\n  t.strictSame(JSONBatch.getEvents(empty, { onlyValid: true, strict: false }).length, 0)\r\n  t.strictSame(JSONBatch.getEvents(empty, { onlyValid: true, strict: true }).length, 0)\r\n  t.strictSame(JSONBatch.getEvents(empty, { onlyValid: false, strict: true }).length, 0)\r\n\r\n  const ceFull = new CloudEvent('1/full',\r\n    ceNamespace,\r\n    ceServerUrl,\r\n    // ceCommonData,\r\n    'sample data', // data as string, to let this ce instance have some strict validation errors\r\n    ceCommonOptions,\r\n    // ceCommonExtensions\r\n    {} // extensions as empty object, to let this ce instance have some strict validation errors\r\n  )\r\n  t.ok(ceFull)\r\n  t.ok(CloudEvent.isValidEvent(ceFull))\r\n  t.ok(CloudEvent.isValidEvent(ceFull, { strict: false }))\r\n  t.notOk(CloudEvent.isValidEvent(ceFull, { strict: true })) // expected errors here\r\n  t.strictSame(CloudEvent.validateEvent(ceFull), [])\r\n  t.strictSame(CloudEvent.validateEvent(ceFull).length, 0)\r\n  t.notOk(JSONBatch.isJSONBatch(ceFull))\r\n\r\n  const ceFullStrict = new CloudEvent('1/full-strict',\r\n    ceNamespace,\r\n    ceServerUrl,\r\n    ceCommonData,\r\n    ceCommonOptionsStrict,\r\n    ceCommonExtensions\r\n  )\r\n  t.ok(ceFullStrict)\r\n  t.ok(CloudEvent.isValidEvent(ceFull))\r\n  t.ok(CloudEvent.isValidEvent(ceFullStrict, { strict: false }))\r\n  t.ok(CloudEvent.isValidEvent(ceFullStrict, { strict: true }))\r\n  t.strictSame(CloudEvent.validateEvent(ceFullStrict, { strict: false }).length, 0)\r\n  t.strictSame(CloudEvent.validateEvent(ceFullStrict, { strict: true }).length, 0)\r\n  t.notOk(JSONBatch.isJSONBatch(ceFullStrict))\r\n\r\n  // define an array containing different CloudEvent instances, and even other objects ...\r\n  const arr = [\r\n    undefined,\r\n    null,\r\n    'string',\r\n    1234567890,\r\n    false,\r\n    true,\r\n    ceFull,\r\n    new Date(),\r\n    {},\r\n    [],\r\n    ceFullStrict,\r\n    null,\r\n    undefined\r\n  ]\r\n  t.ok(arr)\r\n  t.strictSame(arr.length, 13)\r\n  t.strictSame(arr.filter((i) => V.isDefinedAndNotNull(i)).length, 9) // number of not null items\r\n\r\n  // in following tests to simplify comparison of results, check only the  number of expected errors ...\r\n  t.ok(JSONBatch.isJSONBatch(arr))\r\n  t.notOk(JSONBatch.isValidBatch(arr)) // it has some validation error (on its content)\r\n  t.strictSame(JSONBatch.validateBatch(arr, { strict: false }).length, 7)\r\n  t.strictSame(JSONBatch.validateBatch(arr, { strict: true }).length, 8)\r\n  t.strictSame(JSONBatch.getEvents(arr, { onlyValid: false, strict: false }).length, 2) // no filtering\r\n  t.strictSame(JSONBatch.getEvents(arr, { onlyValid: true, strict: false }).length, 2) // both are valid\r\n  t.strictSame(JSONBatch.getEvents(arr, { onlyValid: true, strict: true }).length, 1) // only one is valid in strict mode\r\n  t.strictSame(JSONBatch.getEvents(arr, { onlyValid: false, strict: true }).length, 2) // strict true with onlyValid false makes no filtering\r\n\r\n  // additional test, ensure that all instances returned (only valid), are CloudEvent instances\r\n  const eventsGot = JSONBatch.getEvents(arr, { onlyValid: true, strict: false })\r\n  t.ok(eventsGot.every((i) => CloudEvent.isCloudEvent(i)))\r\n  // test with other instances returned (filtered in a different way)\r\n  t.ok(JSONBatch.getEvents(arr, { onlyValid: false, strict: false }).every((i) => CloudEvent.isCloudEvent(i)))\r\n})\r\n\r\n/** @test {JSONBatch} */\r\ntest('ensure isValid and validate works good on plain object and even CloudEvent instance and CloudEvent subclasses and not', (t) => {\r\n  t.plan(33)\r\n  const { CloudEvent, JSONBatch, CloudEventValidator: V } = require('../src/')\r\n  t.ok(CloudEvent)\r\n  t.ok(JSONBatch)\r\n\r\n  class NotCESubclass {\r\n  }\r\n  class CESubclass extends CloudEvent {\r\n  }\r\n\r\n  const ceFull = new CloudEvent('1/full',\r\n    ceNamespace,\r\n    ceServerUrl,\r\n    // ceCommonData,\r\n    'sample data', // data as string, to let this ce instance have some strict validation errors\r\n    ceCommonOptions,\r\n    // ceCommonExtensions\r\n    {} // extensions as empty object, to let this ce instance have some strict validation errors\r\n  )\r\n  t.ok(ceFull)\r\n  // check that created instances belongs to the right base class\r\n  t.ok(V.isClass(ceFull, CloudEvent))\r\n  t.ok(!V.isClass(ceFull, NotCESubclass))\r\n  t.ok(!V.isClass(ceFull, CESubclass))\r\n  t.ok(!V.ensureIsClass(ceFull, CloudEvent, 'ceFull')) // no error returned\r\n  t.ok(V.ensureIsClass(ceFull, CESubclass, 'ceFull')) // expected error returned\r\n  t.ok(V.isClass(V.ensureIsClass(ceFull, CESubclass, 'ceFull'), TypeError)) // expected error returned\r\n  t.ok(V.isClass(V.ensureIsClass(ceFull, NotCESubclass, 'ceFull'), TypeError)) // expected error returned\r\n  // in following tests to simplify comparison of results, check only the  number of expected errors ...\r\n  t.strictSame(JSONBatch.validateBatch(ceFull).length, 0)\r\n  t.strictSame(JSONBatch.validateBatch(ceFull, { strict: true }).length, 2)\r\n  t.notOk(JSONBatch.isJSONBatch(ceFull))\r\n\r\n  const ceFullSubclass = new CESubclass('1/full/subclass',\r\n    ceNamespace,\r\n    ceServerUrl,\r\n    // ceCommonData,\r\n    'sample data', // data as string, to let this ce instance have some strict validation errors\r\n    ceCommonOptions,\r\n    // ceCommonExtensions\r\n    {} // extensions as empty object, to let this ce instance have some strict validation errors\r\n  )\r\n  t.ok(ceFullSubclass)\r\n  // check that created instances belongs to the right base class\r\n  t.ok(V.isClass(ceFullSubclass, CloudEvent))\r\n  t.ok(!V.isClass(ceFullSubclass, NotCESubclass))\r\n  t.ok(V.isClass(ceFullSubclass, CESubclass))\r\n  t.ok(!V.ensureIsClass(ceFullSubclass, CloudEvent, 'ceFullSubclass')) // no error returned\r\n  t.ok(!V.ensureIsClass(ceFullSubclass, CESubclass, 'ceFullSubclass')) // no error returned\r\n  t.ok(!V.isClass(V.ensureIsClass(ceFullSubclass, CESubclass, 'ceFullSubclass'), TypeError)) // no error returned\r\n  t.ok(V.isClass(V.ensureIsClass(ceFullSubclass, NotCESubclass, 'ceFullSubclass'), TypeError)) // expected error returned\r\n  // in following tests to simplify comparison of results, check only the  number of expected errors ...\r\n  t.strictSame(JSONBatch.validateBatch(ceFullSubclass).length, 0)\r\n  t.strictSame(JSONBatch.validateBatch(ceFullSubclass, { strict: true }).length, 2)\r\n  t.notOk(JSONBatch.isJSONBatch(ceFullSubclass))\r\n\r\n  // try even with a plain object\r\n  const plainObject = { id: '1/plainObject', data: 'sample data' }\r\n  t.strictSame(JSONBatch.validateBatch(plainObject).length, 1)\r\n  t.strictSame(JSONBatch.validateBatch(plainObject, { strict: true }).length, 1)\r\n  t.notOk(JSONBatch.isJSONBatch(plainObject))\r\n  t.throws(function () {\r\n    const ce = [] // CloudEvent instances\r\n    // get values from the generator function\r\n    for (const event of JSONBatch.getEvent(plainObject, { })) {\r\n      assert(event === null) // never executed\r\n      ce.push(event) // never executed\r\n    }\r\n    assert(ce.length === 0) // never executed\r\n  }, Error, 'Expected exception when trying to get an event from a bad JSONBatch')\r\n  t.throws(function () {\r\n    const eventsGot = JSONBatch.getEvents(plainObject)\r\n    assert(eventsGot === null) // never executed\r\n  }, Error, 'Expected exception when trying to get events from a bad JSONBatch')\r\n\r\n  // try with some references\r\n  t.throws(function () {\r\n    JSONBatch.isJSONBatch(undefined)\r\n    assert(true) // never executed\r\n  }, Error, 'Expected exception when checking for a JSONBatch with bad data')\r\n  t.throws(function () {\r\n    JSONBatch.isJSONBatch(null)\r\n    assert(true) // never executed\r\n  }, Error, 'Expected exception when checking for a JSONBatch with bad data')\r\n  t.notOk(JSONBatch.isJSONBatch({}))\r\n  t.ok(JSONBatch.isJSONBatch([]))\r\n})\r\n",
    "static": true,
    "longname": "/Users/martinis/work/prove/cloudevent.js/test/jsonbatch.test.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 212,
    "kind": "test",
    "name": "test29",
    "testId": 29,
    "memberof": "test/jsonbatch.test.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/jsonbatch.test.js~test29",
    "access": null,
    "description": "ensure CloudEvent and JSONBatch class (and related Validator and Transformer classes) are exported by the library",
    "lineNumber": 33,
    "testTargets": [
      "CloudEvent"
    ]
  },
  {
    "__docId__": 213,
    "kind": "test",
    "name": "test30",
    "testId": 30,
    "memberof": "test/jsonbatch.test.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/jsonbatch.test.js~test30",
    "access": null,
    "description": "ensure isValid and validate works good on undefined and null arguments, and even on empty and bad ones",
    "lineNumber": 106,
    "testTargets": [
      "JSONBatch"
    ]
  },
  {
    "__docId__": 214,
    "kind": "test",
    "name": "test31",
    "testId": 31,
    "memberof": "test/jsonbatch.test.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/jsonbatch.test.js~test31",
    "access": null,
    "description": "ensure isValid and validate works good on array and related items",
    "lineNumber": 165,
    "testTargets": [
      "JSONBatch"
    ]
  },
  {
    "__docId__": 215,
    "kind": "test",
    "name": "test32",
    "testId": 32,
    "memberof": "test/jsonbatch.test.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/jsonbatch.test.js~test32",
    "access": null,
    "description": "ensure isValid and validate works good on plain object and even CloudEvent instance and CloudEvent subclasses and not",
    "lineNumber": 253,
    "testTargets": [
      "JSONBatch"
    ]
  },
  {
    "__docId__": 216,
    "kind": "testFile",
    "name": "test/transformer.test.js",
    "content": "/*\r\n * Copyright 2018 the original author or authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n'use strict'\r\n\r\nconst assert = require('assert').strict\r\nconst test = require('tap').test\r\n\r\n/** @test {Transformer} */\r\ntest('ensure the Transformer class (direct reference to it) works good', (t) => {\r\n  t.plan(4)\r\n\r\n  {\r\n    const T = require('../src/transformer') // direct reference to the library\r\n    t.ok(T)\r\n    t.strictEqual(typeof T, 'function')\r\n    // optional, using some standard Node.js assert statements, as a sample\r\n    assert(T !== null)\r\n    assert.strictEqual(typeof T, 'function')\r\n    // assert(new T() instanceof T) // no more allowed\r\n  }\r\n\r\n  {\r\n    const { CloudEventValidator: V, CloudEventTransformer: T } = require('../src/') // get references via destructuring\r\n    t.ok(V.isFunction(T))\r\n    t.throws(function () {\r\n      const t = new T()\r\n      assert(t === null) // never executed\r\n    }, Error, 'Expected exception when creating a Transformer instance')\r\n  }\r\n})\r\n\r\n/** @test {Transformer} */\r\ntest('ensure the Transformer class is good and expose some functions to transform timestamps', (t) => {\r\n  t.plan(10)\r\n  const { CloudEvent, CloudEventValidator: V, CloudEventTransformer: T } = require('../src/') // get references via destructuring\r\n  t.strictEqual(typeof CloudEvent, 'function')\r\n  t.strictEqual(typeof V.isClass, 'function')\r\n  t.strictEqual(typeof T.dumpObject, 'function')\r\n  t.strictEqual(typeof T.timestampFromString, 'function')\r\n  t.strictEqual(typeof T.timestampToString, 'function')\r\n  t.ok(V.isFunction(CloudEvent))\r\n  t.ok(V.isFunction(V.isClass))\r\n  t.ok(V.isFunction(T.dumpObject))\r\n  t.ok(V.isFunction(T.timestampFromString))\r\n  t.ok(V.isFunction(T.timestampToString))\r\n})\r\n\r\n/** create some common options, for better reuse in tests */\r\nconst commonEventTime = new Date()\r\nconst endOf2018TimestampAsString = '2018-12-31T23:59:59.999Z'\r\nconst endOf2018TimestampAsNumber = 1546300799999 // Date.parse(endOf2018TimestampAsString)\r\n\r\n/** @test {Transformer} */\r\ntest('ensure timestamps are transformed to string in the right way', (t) => {\r\n  t.plan(14)\r\n\r\n  const { CloudEventValidator: V, CloudEventTransformer: T } = require('../src/') // get references via destructuring\r\n  t.ok(V.isFunction(T))\r\n  t.ok(endOf2018TimestampAsString)\r\n  t.ok(V.isString(endOf2018TimestampAsString))\r\n  t.ok(V.isStringNotEmpty(endOf2018TimestampAsString))\r\n  t.ok(!V.ensureIsString(endOf2018TimestampAsString, 'endOf2018TimestampAsString')) // no error returned\r\n  t.ok(!V.ensureIsStringNotEmpty(endOf2018TimestampAsString, 'endOf2018TimestampAsString')) // no error returned\r\n\r\n  t.throws(function () {\r\n    const timestampAsString = T.timestampToString()\r\n    assert(timestampAsString === null) // never executed\r\n  }, Error, 'Expected exception when transforming an undefined reference to a string')\r\n\r\n  t.throws(function () {\r\n    const timestampAsString = T.timestampToString(undefined)\r\n    assert(timestampAsString === null) // never executed\r\n  }, Error, 'Expected exception when transforming an undefined reference to a string')\r\n\r\n  t.throws(function () {\r\n    const timestampAsString = T.timestampToString(null)\r\n    assert(timestampAsString === null) // never executed\r\n  }, Error, 'Expected exception when transforming an null timestamp to a string')\r\n\r\n  t.throws(function () {\r\n    const timestampAsString = T.timestampToString({})\r\n    assert(timestampAsString === null) // never executed\r\n  }, Error, 'Expected exception when transforming not a right timestamp (Date) to a string')\r\n\r\n  t.throws(function () {\r\n    const timestampAsString = T.timestampToString('bad timestamp')\r\n    assert(timestampAsString === null) // never executed\r\n  }, Error, 'Expected exception when transforming not a right timestamp (Date) to a string')\r\n\r\n  t.throws(function () {\r\n    const timestampAsString = T.timestampToString(endOf2018TimestampAsString) // ok but no string accepted here\r\n    assert(timestampAsString === null) // never executed\r\n  }, Error, 'Expected exception when transforming not a right timestamp (Date) to a string')\r\n\r\n  {\r\n    const timestampAsString = T.timestampToString(commonEventTime)\r\n    t.ok(timestampAsString)\r\n    t.ok(V.isString(timestampAsString))\r\n    // console.log(`timestampAsString: '${timestampAsString}'`)\r\n  }\r\n})\r\n\r\n/** @test {Transformer} */\r\ntest('ensure timestamps are transformed from string in the right way', (t) => {\r\n  t.plan(23)\r\n\r\n  const { CloudEventValidator: V, CloudEventTransformer: T } = require('../src/') // get references via destructuring\r\n  t.ok(V.isFunction(T))\r\n\r\n  t.throws(function () {\r\n    const timestamp = T.timestampFromString()\r\n    assert(timestamp === null) // never executed\r\n  }, Error, 'Expected exception when transforming an undefined reference to a timestamp (Date)')\r\n\r\n  t.throws(function () {\r\n    const timestamp = T.timestampFromString(undefined)\r\n    assert(timestamp === null) // never executed\r\n  }, Error, 'Expected exception when transforming an undefined reference to a timestamp (Date)')\r\n\r\n  t.throws(function () {\r\n    const timestamp = T.timestampFromString(null)\r\n    assert(timestamp === null) // never executed\r\n  }, Error, 'Expected exception when transforming an null timestamp string to a timestamp (Date)')\r\n\r\n  t.throws(function () {\r\n    const timestamp = T.timestampFromString({})\r\n    assert(timestamp === null) // never executed\r\n  }, Error, 'Expected exception when transforming not a right timestamp string to a timestamp (Date)')\r\n\r\n  t.throws(function () {\r\n    const timestamp = T.timestampFromString('bad timestamp')\r\n    assert(timestamp === null) // never executed\r\n  }, Error, 'Expected exception when transforming not a right timestamp string to a timestamp (Date)')\r\n\r\n  {\r\n    const timestamp = T.timestampFromString(endOf2018TimestampAsString)\r\n    t.ok(timestamp)\r\n    t.ok(V.isDateValid(timestamp))\r\n    t.ok(V.isNumber(timestamp.getTime()))\r\n    // console.log(`timestamp (without timezone offset): '${timestamp}'`)\r\n  }\r\n\r\n  {\r\n    const timestamp = T.timestampFromString(endOf2018TimestampAsString, T.timezoneOffsetMsec)\r\n    t.ok(timestamp)\r\n    t.ok(V.isDateValid(timestamp))\r\n    t.ok(V.isNumber(timestamp.getTime()))\r\n    // console.log(`timestamp (with timezone offset): '${timestamp}'`)\r\n  }\r\n\r\n  {\r\n    const timestampFuture = new Date(Date.now() + 1000)\r\n    t.ok(timestampFuture)\r\n    t.ok(V.isDateValid(timestampFuture))\r\n    t.ok(V.isNumber(timestampFuture.getTime()))\r\n    t.ok(!V.isDatePast(timestampFuture))\r\n    t.ok(V.isDateFuture(timestampFuture))\r\n    t.ok(V.ensureIsDatePast(timestampFuture, 'timestampFuture')) // expected error returned\r\n    t.ok(!V.ensureIsDateFuture(timestampFuture, 'timestampFuture')) // no error returned\r\n    t.strictSame(V.ensureIsDate(timestampFuture, 'timestampFuture'), undefined) // no error returned\r\n    t.strictSame(V.ensureIsDatePast(timestampFuture, 'timestampFuture') instanceof Error, true) // expected error returned\r\n    t.strictSame(V.ensureIsDateFuture(timestampFuture, 'timestampFuture'), undefined) // no error returned\r\n  }\r\n\r\n  t.throws(function () {\r\n    const timestamp = T.timestampFromString(commonEventTime) // ok but no Date accepted here\r\n    assert(timestamp === null) // never executed\r\n  }, Error, 'Expected exception when transforming not a right timestamp string to a timestamp (Date)')\r\n})\r\n\r\n/** @test {Transformer} */\r\ntest('ensure the current timestamp is transformed to string and back as date in the right way', (t) => {\r\n  t.plan(13)\r\n\r\n  const { CloudEventValidator: V, CloudEventTransformer: T } = require('../src/') // get references via destructuring\r\n  t.ok(V.isFunction(T))\r\n\r\n  const timestampAsString = T.timestampToString(commonEventTime)\r\n  t.ok(timestampAsString)\r\n  t.ok(V.isString(timestampAsString))\r\n  // console.log(`current timestamp as string (UTC): '${timestampAsString}'`)\r\n\r\n  {\r\n    const timestampFromString = T.timestampFromString(timestampAsString)\r\n    t.ok(timestampFromString)\r\n    t.ok(V.isDateValid(timestampFromString))\r\n    // console.log(`current timestamp from string (without timezone offset): '${timestampFromString}'`)\r\n    // ensure both timestamps have the same value, but they are different object references\r\n    t.strictSame(timestampFromString.getTime(), commonEventTime.getTime())\r\n    t.notStrictEqual(timestampFromString, commonEventTime)\r\n    t.notEqual(timestampFromString, commonEventTime)\r\n  }\r\n\r\n  {\r\n    const timestampFromString = T.timestampFromString(timestampAsString, T.timezoneOffsetMsec)\r\n    t.ok(timestampFromString)\r\n    t.ok(V.isDateValid(timestampFromString))\r\n    // console.log(`current timestamp from string (with timezone offset): '${timestampFromString}'`)\r\n    // ensure both timestamps have the same value, but they are different object references\r\n    t.strictSame(timestampFromString.getTime(), commonEventTime.getTime() + T.timezoneOffsetMsec)\r\n    t.notStrictEqual(timestampFromString, commonEventTime)\r\n    t.notEqual(timestampFromString, commonEventTime)\r\n  }\r\n})\r\n\r\n/** @test {Transformer} */\r\ntest('ensure timestamps are transformed from number in the right way', (t) => {\r\n  t.plan(29)\r\n\r\n  const { CloudEventValidator: V, CloudEventTransformer: T } = require('../src/') // get references via destructuring\r\n  t.ok(V.isFunction(V))\r\n  t.ok(V.isFunction(T))\r\n  t.ok(endOf2018TimestampAsNumber)\r\n  t.ok(V.isNumber(endOf2018TimestampAsNumber))\r\n  t.ok(!V.isStringNotEmpty(endOf2018TimestampAsNumber))\r\n  t.ok(!V.ensureIsNumber(endOf2018TimestampAsNumber, 'endOf2018TimestampAsNumber')) // no error returned\r\n  t.ok(V.ensureIsStringNotEmpty(endOf2018TimestampAsNumber, 'endOf2018TimestampAsNumber')) // error returned\r\n\r\n  t.throws(function () {\r\n    const timestamp = T.timestampFromNumber()\r\n    assert(timestamp === null) // never executed\r\n  }, Error, 'Expected exception when transforming an undefined reference to a timestamp (Date)')\r\n\r\n  t.throws(function () {\r\n    const timestamp = T.timestampFromNumber(undefined)\r\n    assert(timestamp === null) // never executed\r\n  }, Error, 'Expected exception when transforming an undefined reference to a timestamp (Date)')\r\n\r\n  t.throws(function () {\r\n    const timestamp = T.timestampFromNumber(null)\r\n    assert(timestamp === null) // never executed\r\n  }, Error, 'Expected exception when transforming an null timestamp number to a timestamp (Date)')\r\n\r\n  t.throws(function () {\r\n    const timestamp = T.timestampFromNumber({})\r\n    assert(timestamp === null) // never executed\r\n  }, Error, 'Expected exception when transforming not a right timestamp number to a timestamp (Date)')\r\n\r\n  t.throws(function () {\r\n    const timestamp = T.timestampFromNumber('bad timestamp')\r\n    assert(timestamp === null) // never executed\r\n  }, Error, 'Expected exception when transforming not a right timestamp number to a timestamp (Date)')\r\n\r\n  {\r\n    const timestamp = T.timestampFromNumber(endOf2018TimestampAsNumber)\r\n    t.ok(timestamp)\r\n    t.ok(V.isDateValid(timestamp))\r\n    t.ok(V.isNumber(timestamp.getTime()))\r\n    // console.log(`timestamp (without timezone offset): '${timestamp}'`)\r\n  }\r\n\r\n  {\r\n    const timestamp = T.timestampFromNumber(endOf2018TimestampAsNumber, T.timezoneOffsetMsec)\r\n    t.ok(timestamp)\r\n    t.ok(V.isDateValid(timestamp))\r\n    t.ok(V.isNumber(timestamp.getTime()))\r\n    // console.log(`timestamp (with timezone offset): '${timestamp}'`)\r\n  }\r\n\r\n  {\r\n    const timestampFuture = new Date(Date.now() + 1000)\r\n    t.ok(timestampFuture)\r\n    t.ok(V.isDateValid(timestampFuture))\r\n    t.ok(V.isNumber(timestampFuture.getTime()))\r\n    t.ok(!V.isDatePast(timestampFuture))\r\n    t.ok(V.isDateFuture(timestampFuture))\r\n    t.ok(V.ensureIsDatePast(timestampFuture, 'timestampFuture')) // expected error returned\r\n    t.ok(!V.ensureIsDateFuture(timestampFuture, 'timestampFuture')) // no error returned\r\n    t.strictSame(V.ensureIsDate(timestampFuture, 'timestampFuture'), undefined) // no error returned\r\n    t.strictSame(V.ensureIsDatePast(timestampFuture, 'timestampFuture') instanceof Error, true) // expected error returned\r\n    t.strictSame(V.ensureIsDateFuture(timestampFuture, 'timestampFuture'), undefined) // no error returned\r\n  }\r\n\r\n  t.throws(function () {\r\n    const timestamp = T.timestampFromNumber(commonEventTime) // ok but no Date accepted here\r\n    assert(timestamp === null) // never executed\r\n  }, Error, 'Expected exception when transforming not a right timestamp number to a timestamp (Date)')\r\n})\r\n\r\n/** @test {Transformer} */\r\ntest('ensure the current timestamp is transformed to number and back as date in the right way', (t) => {\r\n  t.plan(17)\r\n\r\n  const { CloudEventValidator: V, CloudEventTransformer: T } = require('../src/') // get references via destructuring\r\n  t.ok(V.isFunction(T))\r\n\r\n  const nowAsNumber = T.timestampToNumber()\r\n  t.ok(nowAsNumber)\r\n  t.ok(V.isNumber(nowAsNumber))\r\n  // console.log(`current timestamp as number: '${nowAsNumber}'`)\r\n\r\n  t.throws(function () {\r\n    const timestamp = T.timestampToNumber('bad timestamp')\r\n    assert(timestamp === null) // never executed\r\n  }, Error, 'Expected exception when transforming not a right timestamp to a timestamp (Number)')\r\n\r\n  t.throws(function () {\r\n    const timestamp = T.timestampToNumber({}) // bad timestamp\r\n    assert(timestamp === null) // never executed\r\n  }, Error, 'Expected exception when transforming not a right timestamp to a timestamp (Number)')\r\n\r\n  const timestampAsNumber = T.timestampToNumber(commonEventTime)\r\n  t.ok(timestampAsNumber)\r\n  t.ok(V.isNumber(timestampAsNumber))\r\n  // console.log(`timestamp as number: '${timestampAsNumber}'`)\r\n\r\n  {\r\n    const timestampFromNumber = T.timestampFromNumber(timestampAsNumber)\r\n    t.ok(timestampFromNumber)\r\n    t.ok(V.isDateValid(timestampFromNumber))\r\n    // console.log(`timestamp from number (without timezone offset): '${timestampFromNumber}'`)\r\n    // ensure both timestamps have the same value, but they are different object references\r\n    t.strictSame(timestampFromNumber.getTime(), commonEventTime.getTime())\r\n    t.notStrictEqual(timestampFromNumber, commonEventTime)\r\n    t.notEqual(timestampFromNumber, commonEventTime)\r\n  }\r\n\r\n  {\r\n    const timestampFromNumber = T.timestampFromNumber(timestampAsNumber, T.timezoneOffsetMsec)\r\n    t.ok(timestampFromNumber)\r\n    t.ok(V.isDateValid(timestampFromNumber))\r\n    // console.log(`timestamp from number (with timezone offset): '${timestampFromNumber}'`)\r\n    // ensure both timestamps have the same value, but they are different object references\r\n    t.strictSame(timestampFromNumber.getTime(), commonEventTime.getTime() + T.timezoneOffsetMsec)\r\n    t.notStrictEqual(timestampFromNumber, commonEventTime)\r\n    t.notEqual(timestampFromNumber, commonEventTime)\r\n  }\r\n})\r\n\r\n/** @test {Transformer} */\r\ntest('ensure errors are transformed into data attribute in the right way', (t) => {\r\n  t.plan(60)\r\n\r\n  const { CloudEventValidator: V, CloudEventTransformer: T } = require('../src/') // get references via destructuring\r\n  t.ok(V.isFunction(T))\r\n\r\n  t.throws(function () {\r\n    const data = T.errorToData()\r\n    assert(data === null) // never executed\r\n  }, Error, 'Expected exception when transforming an undefined reference to object')\r\n\r\n  t.throws(function () {\r\n    const data = T.errorToData(undefined)\r\n    assert(data === null) // never executed\r\n  }, Error, 'Expected exception when transforming an undefined reference to object')\r\n\r\n  t.throws(function () {\r\n    const data = T.errorToData(null)\r\n    assert(data === null) // never executed\r\n  }, Error, 'Expected exception when transforming an null error to object')\r\n\r\n  t.throws(function () {\r\n    const data = T.errorToData({})\r\n    assert(data === null) // never executed\r\n  }, Error, 'Expected exception when transforming not a right error to object')\r\n\r\n  t.throws(function () {\r\n    const data = T.errorToData('error string')\r\n    assert(data === null) // never executed\r\n  }, Error, 'Expected exception when transforming not a right error to object')\r\n\r\n  {\r\n    const error = {}\r\n    // console.log(`DEBUG - error details: ${T.dumpObject(error, 'error')}`)\r\n    t.ok(!V.isError(error))\r\n    t.ok(!V.ensureIsObjectOrCollection(error, 'error')) // no error returned\r\n    t.ok(V.ensureIsError(error, 'error')) // expected error returned\r\n    t.strictSame(V.ensureIsObjectOrCollection(error, 'error'), undefined) // no error returned\r\n    t.strictSame(V.ensureIsError(error, 'error') instanceof Error, true) // expected error returned\r\n  }\r\n\r\n  {\r\n    const error = new Error()\r\n    // console.log(`DEBUG - error details: ${T.dumpObject(error, 'error')}`)\r\n    t.ok(V.isError(error))\r\n    const data = T.errorToData(error)\r\n    // console.log(`DEBUG - data details: ${T.dumpObject(data, 'data')}`)\r\n    t.ok(data)\r\n    t.ok(V.isObject(data))\r\n    t.strictSame(data, { name: 'Error', message: '', stack: null, status: 'error' })\r\n  }\r\n\r\n  {\r\n    const error = new TypeError()\r\n    // console.log(`DEBUG - error details: ${T.dumpObject(error, 'error')}`)\r\n    t.ok(V.isError(error))\r\n    const data = T.errorToData(error)\r\n    // console.log(`DEBUG - data details: ${T.dumpObject(data, 'data')}`)\r\n    t.ok(data)\r\n    t.ok(V.isObject(data))\r\n    t.strictSame(data, { name: 'TypeError', message: '', stack: null, status: 'error' })\r\n  }\r\n\r\n  {\r\n    const error = new Error('sample error')\r\n    t.ok(V.isError(error))\r\n    error.code = 1000 // add a sample error code, as number\r\n    t.ok(V.isNumber(error.code))\r\n    const data = T.errorToData(error, {\r\n      includeStackTrace: true,\r\n      // addStatus: false,\r\n      addTimestamp: true\r\n    })\r\n    t.ok(data)\r\n    t.ok(V.isObject(data))\r\n    t.ok(data.stack)\r\n    t.ok(V.isString(data.stack))\r\n    data.stack = null // empty the attribute to simplify next comparison\r\n    t.ok(data.timestamp)\r\n    t.ok(V.isNumber(data.timestamp))\r\n    const timestampParsed = new Date(data.timestamp)\r\n    t.ok(V.isDatePast(timestampParsed))\r\n    t.ok(!V.isDateFuture(timestampParsed))\r\n    t.ok(!V.ensureIsDate(timestampParsed, 'timestampParsed')) // no error returned\r\n    t.ok(!V.ensureIsDatePast(timestampParsed, 'timestampParsed')) // no error returned\r\n    t.ok(V.ensureIsDateFuture(timestampParsed, 'timestampParsed')) // expected error returned\r\n    t.strictSame(V.ensureIsDate(timestampParsed, 'timestampParsed'), undefined) // no error returned\r\n    t.strictSame(V.ensureIsDateFuture(timestampParsed, 'timestampParsed') instanceof Error, true) // expected error returned\r\n    delete data.code // delete the attribute to simplify next comparison\r\n    delete data.timestamp // delete the attribute to simplify next comparison\r\n    t.strictSame(data, { name: 'Error', message: 'sample error', stack: null, status: 'error' })\r\n  }\r\n\r\n  {\r\n    const error = new TypeError('sample type error')\r\n    t.ok(V.isError(error))\r\n    error.code = '1000' // add a sample error code, as string\r\n    t.ok(V.isString(error.code))\r\n    const data = T.errorToData(error, {\r\n      includeStackTrace: true,\r\n      // addStatus: false,\r\n      addTimestamp: true\r\n    })\r\n    t.ok(data)\r\n    t.ok(V.isObject(data))\r\n    t.ok(data.stack)\r\n    t.ok(V.isString(data.stack))\r\n    data.stack = null // empty the attribute to simplify next comparison\r\n    t.ok(data.timestamp)\r\n    t.ok(V.isNumber(data.timestamp))\r\n    const timestampParsed = new Date(data.timestamp)\r\n    t.ok(V.isDatePast(timestampParsed))\r\n    t.ok(!V.isDateFuture(timestampParsed))\r\n    t.ok(!V.ensureIsDate(timestampParsed, 'timestampParsed')) // no error returned\r\n    t.ok(!V.ensureIsDatePast(timestampParsed, 'timestampParsed')) // no error returned\r\n    t.ok(V.ensureIsDateFuture(timestampParsed, 'timestampParsed')) // expected error returned\r\n    t.strictSame(V.ensureIsDate(timestampParsed, 'timestampParsed'), undefined) // no error returned\r\n    t.strictSame(V.ensureIsDateFuture(timestampParsed, 'timestampParsed') instanceof Error, true) // expected error returned\r\n    delete data.code // delete the attribute to simplify next comparison\r\n    delete data.timestamp // delete the attribute to simplify next comparison\r\n    t.strictSame(data, { name: 'TypeError', message: 'sample type error', stack: null, status: 'error' })\r\n  }\r\n\r\n  {\r\n    const error = new TypeError('sample type error')\r\n    t.ok(V.isError(error))\r\n    error.code = '1000' // add a sample error code, as string\r\n    t.ok(V.isString(error.code))\r\n    const data = T.errorToData(error, {\r\n      includeStackTrace: true,\r\n      addStatus: false,\r\n      addTimestamp: false\r\n    })\r\n    t.ok(data)\r\n    t.ok(V.isObject(data))\r\n    t.ok(data.stack)\r\n    t.ok(V.isString(data.stack))\r\n    data.stack = null // empty the attribute to simplify next comparison\r\n    t.ok(!data.status)\r\n    t.ok(!data.timestamp)\r\n    t.strictSame(data, { name: 'TypeError', message: 'sample type error', stack: null, code: '1000' })\r\n  }\r\n})\r\n\r\n/** @test {Transformer} */\r\ntest('ensure dumpObject works in the right way', (t) => {\r\n  t.plan(12)\r\n\r\n  const { CloudEventValidator: V, CloudEventTransformer: T } = require('../src/') // get references via destructuring\r\n  t.ok(V.isFunction(T))\r\n\r\n  t.ok(T.dumpObject())\r\n  t.ok(T.dumpObject(null))\r\n  t.ok(T.dumpObject(null, null))\r\n  t.ok(T.dumpObject({}, 'empty_object'))\r\n  t.ok(T.dumpObject({ name: 'Name', age: 20, note: null }, 'object'))\r\n  t.ok(T.dumpObject([1, 2, 3, null], 'array'))\r\n  t.ok(T.dumpObject(new Map([['key-1', 'value 1'], ['key-2', 'value 2']]), 'map'))\r\n  t.ok(T.dumpObject(new Set([['key-1', 'value 1'], ['key-2', 'value 2']]), 'set'))\r\n  t.ok(T.dumpObject('12345 67890 ', 'string'))\r\n  t.ok(T.dumpObject(1234567890, 'number'))\r\n  t.ok(T.dumpObject(true, 'boolean'))\r\n})\r\n\r\n/** @test {Transformer} */\r\ntest('ensure process info are transformed into data attribute in the right way', (t) => {\r\n  t.plan(10)\r\n\r\n  const { CloudEventValidator: V, CloudEventTransformer: T } = require('../src/') // get references via destructuring\r\n  t.ok(V.isFunction(V))\r\n  t.ok(V.isFunction(T))\r\n  t.ok(V.isFunction(T.processInfoToData))\r\n\r\n  const hostname = require('os').hostname()\r\n  const pid = require('process').pid\r\n\r\n  {\r\n    const data = T.processInfoToData()\r\n    // console.log(`DEBUG - data: ${T.dumpObject(data, 'data')}`)\r\n    t.ok(V.isObject(data))\r\n    t.ok(!V.ensureIsObjectOrCollection(data, 'data')) // no error returned\r\n    t.strictSame(V.ensureIsObjectOrCollection(data, 'data'), undefined) // no error returned\r\n    t.ok(data.hostname)\r\n    t.ok(data.pid)\r\n    t.strictSame(data.hostname, hostname)\r\n    t.strictSame(data.pid, pid)\r\n  }\r\n})\r\n\r\n/** @test {Transformer} */\r\ntest('ensure uri/url are stripped by query arguments in the right way', (t) => {\r\n  t.plan(22)\r\n\r\n  const { CloudEventValidator: V, CloudEventTransformer: T } = require('../src/') // get references via destructuring\r\n  // t.ok(V.isFunction(V))\r\n  t.ok(V.isFunction(T))\r\n  t.ok(V.isFunction(T.uriStripArguments))\r\n\r\n  t.throws(function () {\r\n    const url = T.uriStripArguments()\r\n    assert(url === null) // never executed\r\n  }, Error, 'Expected exception when transforming an undefined reference to a stripped url (string)')\r\n  t.throws(function () {\r\n    const url = T.uriStripArguments(null)\r\n    assert(url === null) // never executed\r\n  }, Error, 'Expected exception when transforming a null reference to a stripped url (string)')\r\n\r\n  {\r\n    const url = T.uriStripArguments('')\r\n    t.ok(V.isString(url))\r\n    t.strictSame(url, '')\r\n  }\r\n  {\r\n    const url = T.uriStripArguments('sample string')\r\n    t.ok(V.isString(url))\r\n    t.strictSame(url, 'sample string')\r\n  }\r\n  {\r\n    const url = T.uriStripArguments('http://localhost:3000/path/nested')\r\n    t.ok(V.isString(url))\r\n    t.strictSame(url, 'http://localhost:3000/path/nested')\r\n  }\r\n  {\r\n    const url = T.uriStripArguments('http://localhost:3000/path/nested?param1=value1&param2=&param3=Test')\r\n    t.ok(V.isString(url))\r\n    t.strictSame(url, 'http://localhost:3000/path/nested')\r\n  }\r\n  {\r\n    const url = T.uriStripArguments('/path/nested?param1=value1&param2=&param3=Test')\r\n    t.ok(V.isString(url))\r\n    t.strictSame(url, '/path/nested')\r\n  }\r\n\r\n  // the same but woth strict mode enabled\r\n  t.throws(function () {\r\n    const url = T.uriStripArguments('', { strict: true })\r\n    assert(url === null) // never executed\r\n  }, Error, 'Expected exception when transforming a bad URI/URL to a stripped one (string)')\r\n  t.throws(function () {\r\n    const url = T.uriStripArguments('sample string', { strict: true })\r\n    assert(url === null) // never executed\r\n  }, Error, 'Expected exception when transforming a bad URI/URL to a stripped one (string)')\r\n  {\r\n    const url = T.uriStripArguments('http://localhost:3000/path/nested', { strict: true })\r\n    t.ok(V.isString(url))\r\n    t.strictSame(url, 'http://localhost:3000/path/nested')\r\n  }\r\n  {\r\n    const url = T.uriStripArguments('http://localhost:3000/path/nested?param1=value1&param2=&param3=Test', { strict: true })\r\n    t.ok(V.isString(url))\r\n    t.strictSame(url, 'http://localhost:3000/path/nested')\r\n  }\r\n  {\r\n    const url = T.uriStripArguments('/path/nested?param1=value1&param2=&param3=Test', { strict: true })\r\n    t.ok(V.isString(url))\r\n    t.strictSame(url, '/path/nested')\r\n  }\r\n})\r\n\r\n/** @test {Transformer} */\r\ntest('ensure objects are merged in the right way', (t) => {\r\n  t.plan(8)\r\n\r\n  const { CloudEventValidator: V, CloudEventTransformer: T } = require('../src/') // get references via destructuring\r\n  t.ok(V.isFunction(T))\r\n  t.ok(V.isFunction(T.mergeObjects))\r\n\r\n  t.throws(function () {\r\n    const obj = T.mergeObjects()\r\n    assert(obj === null) // never executed\r\n  }, Error, 'Expected exception when merging an undefined reference to object with another undefined reference')\r\n  t.throws(function () {\r\n    const obj = T.mergeObjects(null)\r\n    assert(obj === null) // never executed\r\n  }, Error, 'Expected exception when merging null reference to object with another undefined reference')\r\n\r\n  {\r\n    const base = {}\r\n    const obj = T.mergeObjects(base)\r\n    t.ok(V.isObject(obj))\r\n    t.strictSame(Object.getPrototypeOf(obj), Object.getPrototypeOf(base))\r\n  }\r\n  {\r\n    const base = { bVal: 1, bName: 'Base' }\r\n    const obj = T.mergeObjects(base, { ext1Val: 10, ext1Name: 'Extension1' }, { ext2Val: 20, ext2Name: 'Extension2' })\r\n    // console.log(`DEBUG - merged details: ${T.dumpObject(obj, 'merged')}`)\r\n    t.ok(V.isObject(obj))\r\n    t.strictSame(Object.getPrototypeOf(obj), Object.getPrototypeOf(base))\r\n  }\r\n})\r\n\r\n/** @test {Transformer} */\r\ntest('ensure strings are encoded/decoded in th right way in base64', (t) => {\r\n  t.plan(13)\r\n\r\n  const { CloudEventTransformer: T } = require('../src/') // get references via destructuring\r\n\r\n  t.strictSame(T.stringToBase64(), '')\r\n  t.strictSame(T.stringToBase64(undefined), '')\r\n  t.strictSame(T.stringToBase64(null), '')\r\n  t.strictSame(T.stringToBase64(''), '')\r\n  t.throws(function () {\r\n    const base64 = T.stringToBase64({}) // not a string\r\n    assert(base64 === null) // never executed\r\n  }, Error, 'Expected exception when transforming not a right string to a base64 (String)')\r\n  t.strictSame(T.stringToBase64('Hello World, 2019'), 'SGVsbG8gV29ybGQsIDIwMTk=')\r\n\r\n  t.strictSame(T.stringFromBase64(), '')\r\n  t.strictSame(T.stringFromBase64(undefined), '')\r\n  t.strictSame(T.stringFromBase64(null), '')\r\n  t.strictSame(T.stringFromBase64(''), '')\r\n  t.throws(function () {\r\n    const base64 = T.stringFromBase64({}) // not a string\r\n    assert(base64 === null) // never executed\r\n  }, Error, 'Expected exception when transforming not a right string from a base64 (String)')\r\n  t.strictSame(T.stringFromBase64('SGVsbG8gV29ybGQsIDIwMTk='), 'Hello World, 2019')\r\n\r\n  t.strictSame(T.stringFromBase64(T.stringToBase64('Hello World, 2019')), 'Hello World, 2019')\r\n})\r\n",
    "static": true,
    "longname": "/Users/martinis/work/prove/cloudevent.js/test/transformer.test.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 217,
    "kind": "test",
    "name": "test33",
    "testId": 33,
    "memberof": "test/transformer.test.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/transformer.test.js~test33",
    "access": null,
    "description": "ensure the Transformer class (direct reference to it) works good",
    "lineNumber": 22,
    "testTargets": [
      "Transformer"
    ]
  },
  {
    "__docId__": 218,
    "kind": "test",
    "name": "test34",
    "testId": 34,
    "memberof": "test/transformer.test.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/transformer.test.js~test34",
    "access": null,
    "description": "ensure the Transformer class is good and expose some functions to transform timestamps",
    "lineNumber": 46,
    "testTargets": [
      "Transformer"
    ]
  },
  {
    "__docId__": 219,
    "kind": "test",
    "name": "test35",
    "testId": 35,
    "memberof": "test/transformer.test.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/transformer.test.js~test35",
    "access": null,
    "description": "ensure timestamps are transformed to string in the right way",
    "lineNumber": 67,
    "testTargets": [
      "Transformer"
    ]
  },
  {
    "__docId__": 220,
    "kind": "test",
    "name": "test36",
    "testId": 36,
    "memberof": "test/transformer.test.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/transformer.test.js~test36",
    "access": null,
    "description": "ensure timestamps are transformed from string in the right way",
    "lineNumber": 117,
    "testTargets": [
      "Transformer"
    ]
  },
  {
    "__docId__": 221,
    "kind": "test",
    "name": "test37",
    "testId": 37,
    "memberof": "test/transformer.test.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/transformer.test.js~test37",
    "access": null,
    "description": "ensure the current timestamp is transformed to string and back as date in the right way",
    "lineNumber": 185,
    "testTargets": [
      "Transformer"
    ]
  },
  {
    "__docId__": 222,
    "kind": "test",
    "name": "test38",
    "testId": 38,
    "memberof": "test/transformer.test.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/transformer.test.js~test38",
    "access": null,
    "description": "ensure timestamps are transformed from number in the right way",
    "lineNumber": 220,
    "testTargets": [
      "Transformer"
    ]
  },
  {
    "__docId__": 223,
    "kind": "test",
    "name": "test39",
    "testId": 39,
    "memberof": "test/transformer.test.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/transformer.test.js~test39",
    "access": null,
    "description": "ensure the current timestamp is transformed to number and back as date in the right way",
    "lineNumber": 294,
    "testTargets": [
      "Transformer"
    ]
  },
  {
    "__docId__": 224,
    "kind": "test",
    "name": "test40",
    "testId": 40,
    "memberof": "test/transformer.test.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/transformer.test.js~test40",
    "access": null,
    "description": "ensure errors are transformed into data attribute in the right way",
    "lineNumber": 344,
    "testTargets": [
      "Transformer"
    ]
  },
  {
    "__docId__": 225,
    "kind": "test",
    "name": "test41",
    "testId": 41,
    "memberof": "test/transformer.test.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/transformer.test.js~test41",
    "access": null,
    "description": "ensure dumpObject works in the right way",
    "lineNumber": 489,
    "testTargets": [
      "Transformer"
    ]
  },
  {
    "__docId__": 226,
    "kind": "test",
    "name": "test42",
    "testId": 42,
    "memberof": "test/transformer.test.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/transformer.test.js~test42",
    "access": null,
    "description": "ensure process info are transformed into data attribute in the right way",
    "lineNumber": 509,
    "testTargets": [
      "Transformer"
    ]
  },
  {
    "__docId__": 227,
    "kind": "test",
    "name": "test43",
    "testId": 43,
    "memberof": "test/transformer.test.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/transformer.test.js~test43",
    "access": null,
    "description": "ensure uri/url are stripped by query arguments in the right way",
    "lineNumber": 534,
    "testTargets": [
      "Transformer"
    ]
  },
  {
    "__docId__": 228,
    "kind": "test",
    "name": "test44",
    "testId": 44,
    "memberof": "test/transformer.test.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/transformer.test.js~test44",
    "access": null,
    "description": "ensure objects are merged in the right way",
    "lineNumber": 604,
    "testTargets": [
      "Transformer"
    ]
  },
  {
    "__docId__": 229,
    "kind": "test",
    "name": "test45",
    "testId": 45,
    "memberof": "test/transformer.test.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/transformer.test.js~test45",
    "access": null,
    "description": "ensure strings are encoded/decoded in th right way in base64",
    "lineNumber": 636,
    "testTargets": [
      "Transformer"
    ]
  },
  {
    "__docId__": 230,
    "kind": "testFile",
    "name": "test/validator.test.js",
    "content": "/*\r\n * Copyright 2018 the original author or authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n'use strict'\r\n\r\nconst assert = require('assert').strict\r\nconst test = require('tap').test\r\n\r\n/** @test {Validator} */\r\ntest('ensure the Validator class (direct reference to it) works good', (t) => {\r\n  t.plan(5)\r\n  const V = require('../src/validator') // direct reference to the library\r\n  t.ok(V)\r\n  t.strictEqual(typeof V, 'function')\r\n\r\n  // optional, using some standard Node.js assert statements, as a sample\r\n  assert(V !== null)\r\n  assert.strictEqual(typeof V, 'function')\r\n  // assert(new V() instanceof V) // no more allowed\r\n\r\n  t.ok(V.isFunction(V))\r\n  t.ok(V.isFunction(V.isClass))\r\n  t.throws(function () {\r\n    const v = new V()\r\n    assert(v === null) // never executed\r\n  }, Error, 'Expected exception when creating a Validator instance')\r\n})\r\n\r\n/** @test {CloudEvent} */\r\ntest('create CloudEvent instances with different class hierarchy, and ensure the validation is right', (t) => {\r\n  t.plan(33)\r\n\r\n  /** create some classes, for better reuse in following tests */\r\n  const { CloudEvent: CEClass } = require('../src/') // get references via destructuring\r\n  class NotCESubclass {\r\n  }\r\n  class CESubclass extends CEClass {\r\n  }\r\n\r\n  {\r\n    const { CloudEvent, CloudEventValidator: V, CloudEventTransformer: T } = require('../src/') // get references via destructuring\r\n    t.strictEqual(typeof CloudEvent, 'function')\r\n    t.strictEqual(typeof CloudEvent.version, 'function')\r\n    t.strictEqual(typeof V.isClass, 'function')\r\n    t.strictEqual(typeof T.dumpObject, 'function')\r\n    t.ok(V.isFunction(CloudEvent))\r\n    t.ok(V.isFunction(V.isClass))\r\n    t.ok(V.isFunction(T.dumpObject))\r\n\r\n    // create an instance with only mandatory arguments (no strict mode, but doesn't matter in this case): expected success ...\r\n    const ceMinimal = new CEClass('1', // id\r\n      'com.github.smartiniOnGitHub.cloudeventjs.testevent', // type\r\n      '/', // source\r\n      {} // data (empty) // optional, but useful the same in this sample usage\r\n    )\r\n    t.ok(ceMinimal)\r\n    // console.log(`DEBUG - cloudEvent details: ceMinimal = ${JSON.stringify(ceMinimal)}`)\r\n    // console.log(`DEBUG - cloudEvent details: ${T.dumpObject(ceMinimal, 'ceMinimal')}`)\r\n\r\n    // check that created instances belongs to the right base class\r\n    t.ok(V.isClass(ceMinimal, CloudEvent))\r\n    t.ok(V.isClass(ceMinimal, CEClass))\r\n    t.ok(!V.isClass(ceMinimal, NotCESubclass))\r\n    t.ok(!V.isClass(ceMinimal, CESubclass))\r\n    t.ok(!V.ensureIsClass(ceMinimal, CloudEvent, 'ceMinimal')) // no error returned\r\n    t.ok(!V.ensureIsClass(ceMinimal, CEClass, 'ceMinimal')) // no error returned\r\n    t.ok(V.isClass(V.ensureIsClass(ceMinimal, CESubclass, 'ceMinimal'), TypeError)) // expected error returned\r\n    t.ok(V.isClass(V.ensureIsClass(ceMinimal, NotCESubclass, 'ceMinimal'), TypeError)) // expected error returned\r\n\r\n    // create an instance with only mandatory arguments (no strict mode, but doesn't matter in this case): expected success ...\r\n    const ceMinimalSubclass = new CESubclass('1EX', // id\r\n      'org.github.smartiniOnGitHub.cloudeventjs.testeventEx', // type\r\n      '/', // source\r\n      {} // data (empty) // optional, but useful the same in this sample usage\r\n    )\r\n    t.ok(ceMinimalSubclass)\r\n    // console.log(`DEBUG - cloudEvent details: ceMinimalSubclass = ${JSON.stringify(ceMinimalSubclass)}`)\r\n    // console.log(`DEBUG - cloudEvent details: ${T.dumpObject(ceMinimalSubclass, 'ceMinimalSubclass')}`)\r\n\r\n    // check that created instances belongs to the right base class\r\n    t.ok(V.isClass(ceMinimalSubclass, CloudEvent))\r\n    t.ok(V.isClass(ceMinimalSubclass, CEClass))\r\n    t.ok(!V.isClass(ceMinimalSubclass, NotCESubclass))\r\n    t.ok(V.isClass(ceMinimalSubclass, CESubclass))\r\n    t.ok(!V.ensureIsClass(ceMinimalSubclass, CloudEvent, 'ceMinimal')) // no error returned\r\n    t.ok(!V.ensureIsClass(ceMinimalSubclass, CEClass, 'ceMinimal')) // no error returned\r\n    t.ok(!V.ensureIsClass(ceMinimalSubclass, CESubclass, 'ceMinimal')) // no error returned\r\n    t.ok(V.isClass(V.ensureIsClass(ceMinimalSubclass, NotCESubclass, 'ceMinimal'), TypeError)) // expected error returned\r\n  }\r\n\r\n  {\r\n    const { CloudEventValidator: V } = require('../src/') // get references via destructuring\r\n    t.strictEqual(typeof V, 'function')\r\n    t.strictEqual(typeof V.isClass, 'function')\r\n    t.ok(V.isFunction(V))\r\n    t.ok(V.isFunction(V.isClass))\r\n\r\n    const { CloudEvent, CloudEventValidator } = require('../src/') // get references via destructuring\r\n    t.strictEqual(typeof CloudEvent, 'function')\r\n    t.strictEqual(typeof CloudEventValidator, 'function')\r\n    t.ok(V.isFunction(CloudEvent))\r\n    t.ok(V.isFunction(CloudEventValidator))\r\n  }\r\n})\r\n\r\n/** @test {Validator} */\r\ntest('ensure some (edge cases for) validation functions are right', (t) => {\r\n  t.plan(26)\r\n\r\n  const { CloudEventValidator: V } = require('../src/') // get references via destructuring\r\n  t.ok(V)\r\n\r\n  {\r\n    const arg = undefined\r\n    t.ok(V.isUndefined())\r\n    t.ok(V.isUndefined(arg))\r\n    t.strictSame(V.ensureIsUndefined(), undefined) // no error returned\r\n    t.strictSame(V.ensureIsUndefined(arg, undefined), undefined) // no error returned\r\n    t.strictSame(V.ensureIsUndefined(arg, null), undefined) // no error returned\r\n    t.strictSame(V.ensureIsUndefined(arg, 'test'), undefined) // no error returned\r\n    t.strictSame(V.ensureIsUndefined(arg, {}), undefined) // no error returned\r\n    // check what happens with opposite value instead\r\n    const narg = 'sample' // sample value\r\n    t.notOk(V.isUndefined(narg))\r\n    t.strictSame(V.ensureIsUndefined(narg) instanceof Error, true) // expected error returned\r\n    t.strictSame(V.ensureIsUndefined(narg, undefined) instanceof Error, true) // expected error returned\r\n    t.strictSame(V.ensureIsUndefined(narg, null) instanceof Error, true) // expected error returned\r\n    t.strictSame(V.ensureIsUndefined(narg, 'test') instanceof Error, true) // expected error returned\r\n    t.strictSame(V.ensureIsUndefined(narg, {}) instanceof Error, true) // expected error returned\r\n  }\r\n  {\r\n    const arg = null\r\n    t.ok(V.isNull(arg))\r\n    t.strictSame(V.ensureIsNull(arg), undefined) // no error returned\r\n    t.strictSame(V.ensureIsNull(arg, undefined), undefined) // no error returned\r\n    t.strictSame(V.ensureIsNull(arg, null), undefined) // no error returned\r\n    t.strictSame(V.ensureIsNull(arg, 'test'), undefined) // no error returned\r\n    t.strictSame(V.ensureIsNull(arg, {}), undefined) // no error returned\r\n    // check what happens with opposite value instead\r\n    const narg = 'sample' // sample value\r\n    t.notOk(V.isNull(narg))\r\n    t.strictSame(V.ensureIsNull(narg) instanceof Error, true) // expected error returned\r\n    t.strictSame(V.ensureIsNull(narg, undefined) instanceof Error, true) // expected error returned\r\n    t.strictSame(V.ensureIsNull(narg, null) instanceof Error, true) // expected error returned\r\n    t.strictSame(V.ensureIsNull(narg, 'test') instanceof Error, true) // expected error returned\r\n    t.strictSame(V.ensureIsNull(narg, {}) instanceof Error, true) // expected error returned\r\n  }\r\n\r\n  // similar tests for all other is / ensure methods ...\r\n})\r\n\r\n/** @test {Validator} */\r\ntest('ensure some (less used) validation functions are right', (t) => {\r\n  t.plan(136)\r\n\r\n  const { CloudEventValidator: V } = require('../src/') // get references via destructuring\r\n  t.ok(V)\r\n\r\n  {\r\n    const undefinedGood = undefined\r\n    t.ok(V.isUndefined(undefinedGood))\r\n    t.strictSame(V.ensureIsUndefined(undefinedGood, 'test'), undefined) // no error returned\r\n    t.ok(V.isUndefinedOrNull(undefinedGood))\r\n    t.strictSame(V.ensureIsUndefinedOrNull(undefinedGood, 'test'), undefined) // no error returned\r\n    t.strictSame(V.ensureIsDefinedAndNotNull(undefinedGood, 'test') instanceof Error, true) // expected error returned\r\n    t.ok(!V.isObject(undefinedGood))\r\n    t.ok(!V.isObjectPlain(undefinedGood))\r\n    t.ok(V.ensureIsObject(undefinedGood, 'test')) // expected error returned\r\n    t.ok(V.ensureIsObjectPlain(undefinedGood, 'test')) // expected error returned\r\n    const undefinedBad = 'defined'\r\n    t.ok(!V.isUndefined(undefinedBad))\r\n    t.strictSame(V.ensureIsUndefined(undefinedBad, 'test') instanceof Error, true) // expected error returned\r\n    t.ok(!V.isUndefinedOrNull(undefinedBad))\r\n    t.strictSame(V.ensureIsUndefinedOrNull(undefinedBad, 'test') instanceof Error, true) // expected error returned\r\n    t.strictSame(V.ensureIsDefinedAndNotNull(undefinedBad, 'test'), undefined) // no error returned\r\n  }\r\n\r\n  {\r\n    const nullGood = null\r\n    t.ok(V.isNull(nullGood))\r\n    t.strictSame(V.ensureIsNull(nullGood, 'test'), undefined) // no error returned\r\n    t.ok(V.isUndefinedOrNull(nullGood))\r\n    t.strictSame(V.ensureIsUndefinedOrNull(nullGood, 'test'), undefined) // no error returned\r\n    t.strictSame(V.ensureIsDefinedAndNotNull(nullGood, 'test') instanceof Error, true) // expected error returned\r\n    t.ok(!V.isObject(nullGood))\r\n    t.ok(!V.isObjectPlain(nullGood))\r\n    t.ok(V.ensureIsObject(nullGood, 'test')) // expected error returned\r\n    t.ok(V.ensureIsObjectPlain(nullGood, 'test')) // expected error returned\r\n    const nullBad = 'defined'\r\n    t.ok(!V.isNull(nullBad))\r\n    t.strictSame(V.ensureIsNull(nullBad, 'test') instanceof Error, true) // expected error returned\r\n    t.ok(!V.isUndefinedOrNull(nullBad))\r\n    t.strictSame(V.ensureIsUndefinedOrNull(nullBad, 'test') instanceof Error, true) // expected error returned\r\n    t.strictSame(V.ensureIsDefinedAndNotNull(nullBad, 'test'), undefined) // no error returned\r\n  }\r\n\r\n  {\r\n    const errorGood = new Error('Sample error')\r\n    t.ok(V.isError(errorGood))\r\n    t.strictSame(V.ensureIsError(errorGood, 'test'), undefined) // no error returned\r\n    t.ok(V.isObject(errorGood))\r\n    t.ok(!V.isObjectPlain(errorGood))\r\n    t.ok(!V.ensureIsObject(errorGood, 'error')) // no error returned\r\n    t.ok(V.ensureIsObjectPlain(errorGood, 'error')) // expected error returned\r\n    const errorBad = 'Error string'\r\n    t.ok(!V.isError(errorBad))\r\n    t.strictSame(V.ensureIsError(errorBad, 'test') instanceof Error, true) // expected error returned\r\n  }\r\n\r\n  {\r\n    const dateGood = new Date()\r\n    t.ok(V.isDate(dateGood))\r\n    t.strictSame(V.ensureIsDate(dateGood, 'test'), undefined) // no error returned\r\n    t.ok(V.isObject(dateGood))\r\n    t.ok(!V.isObjectPlain(dateGood))\r\n    t.ok(!V.ensureIsObject(dateGood, 'date')) // no error returned\r\n    t.ok(V.ensureIsObjectPlain(dateGood, 'date')) // expected error returned\r\n    const dateBad = Date.now()\r\n    t.ok(!V.isDate(dateBad))\r\n    t.strictSame(V.ensureIsDate(dateBad, 'test') instanceof Error, true) // expected error returned\r\n    t.ok(V.ensureIsObjectOrCollectionOrString(dateGood, 'date')) // expected error returned\r\n    t.ok(V.ensureIsNumber(dateGood, 'date')) // expected error returned\r\n    t.ok(!V.ensureIsNumber(dateGood.getTime(), 'number')) // no error returned\r\n  }\r\n\r\n  {\r\n    const relGood = '1.0.0'\r\n    t.ok(V.isVersion(relGood))\r\n    t.strictSame(V.ensureIsVersion(relGood, 'test'), undefined) // no error returned\r\n    const relBad = 'a.b.c-d'\r\n    t.ok(!V.isVersion(relBad))\r\n    t.strictSame(V.ensureIsVersion(relBad, 'test') instanceof Error, true) // expected error returned\r\n  }\r\n\r\n  {\r\n    const objectBad = 1234567890\r\n    t.ok(V.isNumber(objectBad))\r\n    t.ok(!V.isObject(objectBad))\r\n    t.ok(V.ensureIsObjectOrCollection(objectBad, 'error')) // expected error returned\r\n    t.strictSame(V.ensureIsObjectOrCollection(objectBad, 'error') instanceof Error, true) // expected error returned\r\n  }\r\n\r\n  {\r\n    const objectGood = { name: 'Name', age: 100, note: null }\r\n    t.ok(V.isObject(objectGood))\r\n    t.ok(!V.isString(objectGood))\r\n    t.ok(!V.ensureIsObjectOrCollection(objectGood, 'object')) // no error returned\r\n    t.strictSame(V.ensureIsObjectOrCollection(objectGood, 'object') instanceof Error, false) // no error returned\r\n    t.ok(!V.ensureIsObjectOrCollectionNotString(objectGood, 'object')) // no error returned\r\n    t.ok(!V.ensureIsObjectOrCollectionOrString(objectGood, 'object')) // no error returned\r\n    t.ok(V.isObject(objectGood))\r\n    t.ok(V.isObjectPlain(objectGood))\r\n    t.ok(!V.ensureIsObject(objectGood, 'object')) // no error returned\r\n    t.ok(!V.ensureIsObjectPlain(objectGood, 'object')) // no error returned\r\n  }\r\n\r\n  {\r\n    const objectAsStringGood = '{ name: \"Name\", age: 100, note: null }'\r\n    t.ok(!V.isObject(objectAsStringGood))\r\n    t.ok(V.isString(objectAsStringGood))\r\n    t.ok(V.ensureIsObjectOrCollection(objectAsStringGood, 'string')) // expected error returned\r\n    t.strictSame(V.ensureIsObjectOrCollection(objectAsStringGood, 'string') instanceof Error, true) // expected error returned\r\n    t.ok(V.ensureIsObjectOrCollectionNotString(objectAsStringGood, 'object')) // expected error returned\r\n    t.ok(!V.ensureIsObjectOrCollectionOrString(objectAsStringGood, 'object')) // no error returned\r\n    t.ok(!V.isObject(objectAsStringGood))\r\n    t.ok(!V.isObjectPlain(objectAsStringGood))\r\n    t.ok(V.ensureIsObject(objectAsStringGood, 'string')) // expected error returned\r\n    t.ok(V.ensureIsObjectPlain(objectAsStringGood, 'string')) // expected error returned\r\n  }\r\n\r\n  {\r\n    const stringBad = 1234567890\r\n    t.ok(!V.isString(stringBad))\r\n    t.ok(!V.isStringNotEmpty(stringBad))\r\n    t.ok(V.ensureIsString(stringBad, 'error')) // expected error returned\r\n    t.strictSame(V.ensureIsString(stringBad, 'error') instanceof Error, true) // expected error returned\r\n    t.ok(V.ensureIsStringNotEmpty(stringBad, 'error')) // expected error returned\r\n    t.strictSame(V.ensureIsStringNotEmpty(stringBad, 'error') instanceof Error, true) // expected error returned\r\n  }\r\n\r\n  {\r\n    const functionBad = '1234567890'\r\n    t.ok(V.isString(functionBad))\r\n    t.ok(!V.isFunction(functionBad))\r\n    t.ok(V.ensureIsFunction(functionBad, 'error')) // expected error returned\r\n    t.strictSame(V.ensureIsFunction(functionBad, 'error') instanceof Error, true) // expected error returned\r\n  }\r\n\r\n  {\r\n    const arrayGood = []\r\n    t.ok(V.isArray(arrayGood))\r\n    t.strictSame(V.ensureIsArray(arrayGood, 'test'), undefined) // no error returned\r\n    t.ok(V.isObject(arrayGood))\r\n    t.ok(!V.isObjectPlain(arrayGood))\r\n    t.ok(!V.ensureIsObject(arrayGood, 'array')) // no error returned\r\n    t.ok(V.ensureIsObjectPlain(arrayGood, 'array')) // expected error returned\r\n    const arrayBad = {}\r\n    t.ok(!V.isArray(arrayBad))\r\n    t.strictSame(V.ensureIsArray(arrayBad, 'test') instanceof Error, true) // expected error returned\r\n    t.ok(V.ensureIsObjectOrCollectionNotArray(arrayGood, 'array')) // expected error returned\r\n    t.strictSame(V.ensureIsObjectOrCollectionNotArray({}, 'test'), undefined) // no error returned\r\n  }\r\n\r\n  {\r\n    const boolGood = true\r\n    t.ok(V.isBoolean(boolGood))\r\n    t.strictSame(V.ensureIsBoolean(boolGood, 'test'), undefined) // no error returned\r\n    const boolBad = 'false'\r\n    t.ok(!V.isBoolean(boolBad))\r\n    t.strictSame(V.ensureIsBoolean(boolBad, 'test') instanceof Error, true) // expected error returned\r\n    t.ok(V.ensureIsObjectOrCollectionOrString(boolGood, 'boolean')) // expected error returned\r\n    t.strictSame(V.ensureIsObjectOrCollectionOrString({}, 'test'), undefined) // no error returned\r\n  }\r\n\r\n  {\r\n    const uriGood = 'http://localhost:3000/path/nested?param1=value1'\r\n    t.ok(V.isURI(uriGood))\r\n    t.strictSame(V.ensureIsURI(uriGood, null, 'test'), undefined) // no error returned\r\n    const uriBad = 'path/nested?param1=value1' // not relative nor absolute uri, so not a real uri string\r\n    t.ok(!V.isURI(uriBad))\r\n    t.strictSame(V.ensureIsURI(uriBad, null, 'test') instanceof Error, true) // expected error returned\r\n  }\r\n\r\n  {\r\n    const uriGoodPath = '/path/nested?param1=value1'\r\n    const uriGoodBase = 'http://localhost:3000'\r\n    t.ok(V.isURI(uriGoodPath, uriGoodBase))\r\n    t.strictSame(V.ensureIsURI(uriGoodPath, uriGoodBase, 'test'), undefined) // no error returned\r\n    const uriBad = 'path/nested?param1=value1' // not relative nor absolute uri, so not a real uri string\r\n    t.ok(!V.isURI(uriBad, null))\r\n    t.strictSame(V.ensureIsURI(uriBad, null, 'test') instanceof Error, true) // expected error returned\r\n  }\r\n\r\n  {\r\n    const uriGoodPath = '/path/nested?param1=value1'\r\n    const uriBadBase = 'httpz:bad'\r\n    t.ok(!V.isURI(uriGoodPath, uriBadBase))\r\n    t.strictSame(V.ensureIsURI(uriGoodPath, uriBadBase, 'test') instanceof Error, true) // expected error returned\r\n  }\r\n\r\n  {\r\n    // test getSize with different argument types\r\n    t.ok(V.isUndefined(V.getSize(null)))\r\n    t.strictSame(V.getSize(null), undefined)\r\n    const obj = { name: 'Name', age: 20, note: null }\r\n    t.ok(V.isNumber(V.getSize(obj)))\r\n    t.strictSame(V.getSize(obj), 3) // include even null items in the size\r\n    const arr = [1, 2, 3, null]\r\n    t.ok(V.isNumber(V.getSize(arr)))\r\n    t.strictSame(V.getSize(arr), 4) // include even null items in the size\r\n    const map = new Map([['key-1', 'value 1'], ['key-2', 'value 2']])\r\n    t.ok(V.isNumber(V.getSize(map)))\r\n    t.strictSame(V.getSize(map), 2)\r\n    const set = new Set([['key-1', 'value 1'], ['key-2', 'value 2']])\r\n    t.ok(V.isNumber(V.getSize(set)))\r\n    t.strictSame(V.getSize(set), 2)\r\n    const str = '12345 67890 '\r\n    t.ok(V.isNumber(V.getSize(str)))\r\n    t.strictSame(V.getSize(str), 12)\r\n    const otherBadNumber = 1234567890\r\n    t.ok(V.isNumber(otherBadNumber))\r\n    t.throws(function () {\r\n      const size = V.getSize(otherBadNumber)\r\n      assert(size !== null) // never executed\r\n    }, Error, 'Expected exception when trying to get the size of a bad object')\r\n    const otherBadBoolean = true\r\n    t.ok(V.isBoolean(otherBadBoolean))\r\n    t.throws(function () {\r\n      const size = V.getSize(otherBadBoolean)\r\n      assert(size !== null) // never executed\r\n    }, Error, 'Expected exception when trying to get the size of a bad object')\r\n  }\r\n\r\n  {\r\n    // test getSizeInBytes with different argument types\r\n    t.ok(V.isUndefined(V.getSizeInBytes(null)))\r\n    t.strictSame(V.getSizeInBytes(null), undefined)\r\n    t.throws(function () {\r\n      const size = V.getSizeInBytes({})\r\n      assert(size !== null) // never executed\r\n    }, Error, 'Expected exception when trying to get the size in bytes of not a string')\r\n    const str = '12345 67890 '\r\n    t.ok(V.isNumber(V.getSizeInBytes(str)))\r\n    t.strictSame(V.getSizeInBytes(str), 12)\r\n    t.strictSame(V.getSizeInBytes(str), V.getSize(str))\r\n    t.ok(V.isNumber(V.getSizeInBytes('π')))\r\n    t.strictSame(V.getSizeInBytes('π'), 2)\r\n  }\r\n})\r\n\r\n/** @test {Validator} */\r\ntest('ensure some (utility) functions are right', (t) => {\r\n  t.plan(28)\r\n\r\n  const { CloudEventValidator: V } = require('../src/') // get references via destructuring\r\n  t.ok(V)\r\n\r\n  {\r\n    const u = undefined\r\n    const n = null\r\n    const s = 'Sample string'\r\n    const o = {}\r\n\r\n    t.strictSame(V.getArgumentValue(), undefined) // no error returned\r\n    t.strictSame(V.getArgumentValue(u), undefined)\r\n    t.strictSame(V.getArgumentValue(n), null)\r\n    t.strictSame(V.getArgumentValue(s), s)\r\n    t.strictSame(V.getArgumentValue(o), {})\r\n\r\n    t.strictSame(V.getArgumentName(), undefined) // no error returned\r\n    t.strictSame(V.getArgumentName(u), undefined)\r\n    t.strictSame(V.getArgumentName(n), undefined)\r\n    t.strictSame(V.getArgumentName(s), '0') // not the right way to call it\r\n    t.strictSame(V.getArgumentName(o), undefined) // not the right way to call it\r\n    t.strictSame(V.getArgumentName({ u }), 'u')\r\n    t.strictSame(V.getArgumentName({ n }), 'n')\r\n    t.strictSame(V.getArgumentName({ s }), 's')\r\n\r\n    t.strictSame(V.getOrElse(), undefined) // no error returned\r\n    t.strictSame(V.getOrElse(u), undefined)\r\n    t.strictSame(V.getOrElse(u, u), undefined)\r\n    t.strictSame(V.getOrElse(u, n), null)\r\n    t.strictSame(V.getOrElse(n), undefined)\r\n    t.strictSame(V.getOrElse(n, u), undefined)\r\n    t.strictSame(V.getOrElse(n, n), null)\r\n    t.strictSame(V.getOrElse(s), s)\r\n    t.strictSame(V.getOrElse(s, s), s)\r\n    t.strictSame(V.getOrElse(s, o), s)\r\n    t.strictSame(V.getOrElse(u, s), s)\r\n    t.strictSame(V.getOrElse(n, s), s)\r\n    t.strictSame(V.getOrElse(u, o), o)\r\n    t.strictSame(V.getOrElse(n, o), o)\r\n  }\r\n})\r\n\r\n/** @test {Validator} */\r\ntest('ensure validation functions on standard properties are right', (t) => {\r\n  t.plan(19)\r\n\r\n  const { CloudEventValidator: V } = require('../src/') // get references via destructuring\r\n  t.ok(V)\r\n\r\n  // sample function that tell if the given property name is standard\r\n  function isPropStandard (prop) {\r\n    return prop === 'standard'\r\n  }\r\n\r\n  t.ok(!V.doesStringIsStandardProperty())\r\n  t.ok(!V.doesStringIsStandardProperty(undefined, undefined))\r\n  t.ok(!V.doesStringIsStandardProperty(null, null))\r\n  t.ok(!V.doesStringIsStandardProperty({}, isPropStandard))\r\n  t.ok(!V.doesStringIsStandardProperty('non_standard', isPropStandard))\r\n  t.ok(V.doesStringIsStandardProperty('standard', isPropStandard))\r\n  t.ok(!V.doesStringIsStandardProperty('property', {}))\r\n  t.ok(!V.doesStringIsStandardProperty('standard', {}))\r\n\r\n  t.ok(!V.doesObjectContainsStandardProperty())\r\n  t.ok(!V.doesObjectContainsStandardProperty(undefined, undefined))\r\n  t.ok(!V.doesObjectContainsStandardProperty(null, null))\r\n  t.ok(!V.doesObjectContainsStandardProperty({}, isPropStandard))\r\n  t.ok(!V.doesObjectContainsStandardProperty({ non_standard: 'value' }, isPropStandard))\r\n  t.ok(V.doesObjectContainsStandardProperty({ standard: 'value' }, isPropStandard))\r\n  t.ok(!V.doesObjectContainsStandardProperty({ property: 'value' }, {}))\r\n  t.ok(!V.doesObjectContainsStandardProperty({ standard: 'value' }, {}))\r\n\r\n  t.strictSame(V.ensureObjectDoesNotContainStandardProperty({ property: 'value' }, isPropStandard, 'test'), undefined) // no error returned\r\n  t.strictSame(V.ensureObjectDoesNotContainStandardProperty({ standard: 'value' }, isPropStandard, 'test') instanceof Error, true) // expected error returned\r\n})\r\n\r\n/** @test {Validator} */\r\ntest('ensure validation functions to filter bad object instances raise exceptions', (t) => {\r\n  t.plan(3)\r\n\r\n  const { CloudEventValidator: V } = require('../src/') // get references via destructuring\r\n  t.ok(V)\r\n\r\n  // sample function that tell if the given property name is standard\r\n  function isPropStandard (prop) {\r\n    return prop === 'standard'\r\n  }\r\n\r\n  t.throws(function () {\r\n    const objFiltered = V.getObjectFilteredProperties([], isPropStandard)\r\n    assert(objFiltered !== null) // never executed\r\n  }, Error, 'Expected exception when trying to filter not a plain object')\r\n  t.throws(function () {\r\n    const objFiltered = V.getObjectFilteredProperties({}, 'isPropStandard')\r\n    assert(objFiltered !== null) // never executed\r\n  }, Error, 'Expected exception when trying to filter a plain object but with a wrong filtering function')\r\n})\r\n\r\n/** @test {Validator} */\r\ntest('ensure validation functions to throw exceptions, works good', (t) => {\r\n  t.plan(12)\r\n\r\n  const { CloudEventValidator: V } = require('../src/') // get references via destructuring\r\n  t.ok(V)\r\n\r\n  t.notOk(V.throwOnError()) // no error returned\r\n  t.notOk(V.throwOnError(undefined)) // no error returned\r\n  t.notOk(V.throwOnError(null)) // no error returned\r\n  t.notOk(V.throwOnError({})) // no error returned\r\n  t.throws(function () {\r\n    V.throwOnError(new TypeError('Sample TypeError'))\r\n    assert(false) // never executed\r\n  }, Error, 'Expected exception when trying to throw from an Error')\r\n\r\n  t.throws(function () {\r\n    V.throwOnFalse()\r\n    assert(false) // never executed\r\n  }, Error, 'Expected exception when trying to throw from an undefined value')\r\n  t.throws(function () {\r\n    V.throwOnFalse(undefined)\r\n    assert(false) // never executed\r\n  }, Error, 'Expected exception when trying to throw from an undefined value')\r\n  t.throws(function () {\r\n    V.throwOnFalse(null)\r\n    assert(false) // never executed\r\n  }, Error, 'Expected exception when trying to throw from a null value')\r\n  t.throws(function () {\r\n    V.throwOnFalse({})\r\n    assert(false) // never executed\r\n  }, Error, 'Expected exception when trying to throw from a not boolean value')\r\n  t.notOk(V.throwOnFalse(true)) // no error returned\r\n  t.throws(function () {\r\n    V.throwOnFalse(false)\r\n    assert(false) // never executed\r\n  }, Error, 'Expected exception when trying to throw from a false value')\r\n})\r\n",
    "static": true,
    "longname": "/Users/martinis/work/prove/cloudevent.js/test/validator.test.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 231,
    "kind": "test",
    "name": "test46",
    "testId": 46,
    "memberof": "test/validator.test.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/validator.test.js~test46",
    "access": null,
    "description": "ensure the Validator class (direct reference to it) works good",
    "lineNumber": 22,
    "testTargets": [
      "Validator"
    ]
  },
  {
    "__docId__": 232,
    "kind": "test",
    "name": "test47",
    "testId": 47,
    "memberof": "test/validator.test.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/validator.test.js~test47",
    "access": null,
    "description": "create CloudEvent instances with different class hierarchy, and ensure the validation is right",
    "lineNumber": 42,
    "testTargets": [
      "CloudEvent"
    ]
  },
  {
    "__docId__": 233,
    "kind": "test",
    "name": "test48",
    "testId": 48,
    "memberof": "test/validator.test.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/validator.test.js~test48",
    "access": null,
    "description": "ensure some (edge cases for) validation functions are right",
    "lineNumber": 119,
    "testTargets": [
      "Validator"
    ]
  },
  {
    "__docId__": 234,
    "kind": "test",
    "name": "test49",
    "testId": 49,
    "memberof": "test/validator.test.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/validator.test.js~test49",
    "access": null,
    "description": "ensure some (less used) validation functions are right",
    "lineNumber": 165,
    "testTargets": [
      "Validator"
    ]
  },
  {
    "__docId__": 235,
    "kind": "test",
    "name": "test50",
    "testId": 50,
    "memberof": "test/validator.test.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/validator.test.js~test50",
    "access": null,
    "description": "ensure some (utility) functions are right",
    "lineNumber": 404,
    "testTargets": [
      "Validator"
    ]
  },
  {
    "__docId__": 236,
    "kind": "test",
    "name": "test51",
    "testId": 51,
    "memberof": "test/validator.test.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/validator.test.js~test51",
    "access": null,
    "description": "ensure validation functions on standard properties are right",
    "lineNumber": 449,
    "testTargets": [
      "Validator"
    ]
  },
  {
    "__docId__": 237,
    "kind": "test",
    "name": "test52",
    "testId": 52,
    "memberof": "test/validator.test.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/validator.test.js~test52",
    "access": null,
    "description": "ensure validation functions to filter bad object instances raise exceptions",
    "lineNumber": 483,
    "testTargets": [
      "Validator"
    ]
  },
  {
    "__docId__": 238,
    "kind": "test",
    "name": "test53",
    "testId": 53,
    "memberof": "test/validator.test.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/validator.test.js~test53",
    "access": null,
    "description": "ensure validation functions to throw exceptions, works good",
    "lineNumber": 505,
    "testTargets": [
      "Validator"
    ]
  }
]
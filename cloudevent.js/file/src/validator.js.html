<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">src/validator.js | cloudevent.js</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="JavaScript/Node.js implementation of the CloudEvents standard format"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="cloudevent.js"><meta property="twitter:description" content="JavaScript/Node.js implementation of the CloudEvents standard format"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/smartiniOnGitHub/cloudevent.js"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/validator.js~Validator.html">Validator</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/validator.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">/*
 * Copyright 2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
&apos;use strict&apos;

/**
 * Validators:
 * this module exports some useful generic functions for the validation of objects.
 */

const url = require(&apos;url&apos;)

/**
 * Generic Validator implementation.
 *
 * Note that all methods here are static, so no need to instance this class;
 * see it as an Utility/Companion class.
 */
class Validator {
  /**
   * Create a new instance of a Validator object.
   * @throws {Error} because instancing not allowed for this class
   */
  constructor () {
    throw new Error(`Instancing not allowed for this class`)
  }

  /**
   * Gives a string valued property that is used in the creation of the default string description of an object.
   *
   * See {@link Symbol.toStringTag}.
   *
   * @return {string} a string representation of the object type
   */
  get [Symbol.toStringTag] () {
    return &apos;Validator&apos;
  }

  /**
   * Tell if the given ergument is undefined.
   *
   * @static
   * @param {object} arg the object to check
   * @return {boolean} true if undefined, false otherwise
   */
  static isUndefined (arg) {
    return (arg === undefined)
  }

  /**
   * Tell if the given ergument is null.
   *
   * @static
   * @param {object} arg the object to check
   * @return {boolean} true if null, false otherwise
   */
  static isNull (arg) {
    return (arg === null)
  }

  /**
   * Tell if the given ergument is undefined or null.
   *
   * @static
   * @param {object} arg the object to check
   * @return {boolean} true if undefined or null, false otherwise
   */
  static isUndefinedOrNull (arg) {
    return (arg === undefined || arg === null)
  }

  /**
   * Tell if the given ergument is defined and not null.
   *
   * @static
   * @param {object} arg the object to check
   * @return {boolean} true if defined and not null, false otherwise
   */
  static isDefinedAndNotNull (arg) {
    return (arg !== undefined &amp;&amp; arg !== null)
  }

  /**
   * Tell if the given ergument is a string.
   *
   * @static
   * @param {object} arg the object to check
   * @return {boolean} true if it&apos;s a string, false otherwise
   */
  static isString (arg) {
    return (Validator.isDefinedAndNotNull(arg) &amp;&amp; (typeof arg === &apos;string&apos;))
  }

  /**
   * Tell if the given ergument is a not empty string.
   *
   * See {@link Validator.isString}.
   *
   * @static
   * @param {object} arg the object to check
   * @return {boolean} true if it&apos;s a not empty string, false otherwise
   */
  static isStringNotEmpty (arg) {
    return (Validator.isString(arg) &amp;&amp; (arg.length &gt; 0))
  }

  /**
   * Tell if the given ergument is a date.
   *
   * @static
   * @param {object} arg the object to check
   * @return {boolean} true if it&apos;s a date, false otherwise
   */
  static isDate (arg) {
    return (Validator.isDefinedAndNotNull(arg) &amp;&amp; (typeof arg === &apos;object&apos; || arg instanceof Date))
  }

  /**
   * Tell if the given ergument is a valid date.
   *
   * See {@link Validator.isDate}.
   *
   * @static
   * @param {object} arg the object to check
   * @return {boolean} true if it&apos;s a valid date, false otherwise
   */
  static isDateValid (arg) {
    return (Validator.isDate(arg) &amp;&amp; !isNaN(arg))
  }

  /**
   * Tell if the given ergument is a valid date and in the past.
   *
   * See {@link Validator.isDateValid}.
   *
   * @static
   * @param {object} arg the object to check
   * @return {boolean} true if it&apos;s a valid date in the past, false otherwise
   */
  static isDatePast (arg) {
    return (Validator.isDateValid(arg) &amp;&amp; arg &lt; Date.now())
  }

  /**
   * Tell if the given ergument is a number.
   *
   * @static
   * @param {object} arg the object to check
   * @return {boolean} true if it&apos;s a number, false otherwise
   */
  static isNumber (arg) {
    return (Validator.isDefinedAndNotNull(arg) &amp;&amp; typeof arg === &apos;number&apos; &amp;&amp; !isNaN(arg))
  }

  /**
   * Tell if the given ergument is an array.
   *
   * @static
   * @param {object} arg the object to check
   * @return {boolean} true if it&apos;s an array, false otherwise
   */
  static isArray (arg) {
    return (Validator.isDefinedAndNotNull(arg) &amp;&amp; (Array.isArray(arg)))
  }

  /**
   * Tell if the given ergument is a boolean.
   *
   * @static
   * @param {object} arg the object to check
   * @return {boolean} true if it&apos;s a boolean, false otherwise
   */
  static isBoolean (arg) {
    return (typeof arg === &apos;boolean&apos;)
  }

  /**
   * Tell if the given ergument is an instance of the given class reference.
   *
   * @static
   * @param {object} arg the object to check
   * @param {object} classReference the class that should be implemented/extended
   * @return {boolean} true if it&apos;s an instance (or extends) that class, false otherwise
   */
  static isClass (arg, classReference) {
    return (arg instanceof classReference)
  }

  /**
   * Tell if the given ergument is a function.
   *
   * @static
   * @param {object} arg the object to check
   * @return {boolean} true if it&apos;s a function, false otherwise
   */
  static isFunction (arg) {
    return (typeof arg === &apos;function&apos;)
  }

  /**
   * Tell if the given ergument is an object.
   *
   * @static
   * @param {object} arg the object to check
   * @return {boolean} true if it&apos;s an object, false otherwise
   */
  static isObject (arg) {
    return (Validator.isDefinedAndNotNull(arg) &amp;&amp; (typeof arg === &apos;object&apos;))
  }

  /**
   * Tell if the given ergument is a keyed collection.
   *
   * @static
   * @param {object} arg the object to check
   * @return {boolean} true if it&apos;s a Map|WeakMap or a Set|WeakSet, false otherwise
   */
  static isKeyedCollection (arg) {
    return (Validator.isDefinedAndNotNull(arg) &amp;&amp; (
      arg instanceof Map || arg instanceof WeakMap ||
      arg instanceof Set || arg instanceof WeakSet
    ))
  }

  /**
   * Tell if the given ergument is an object or a keyed collection.
   *
   * See {@link Validator.isObject}, {@link Validator.isKeyedCollection}.
   *
   * @static
   * @param {object} arg the object to check
   * @return {boolean} true if it&apos;s an object or a keyed collection, false otherwise
   */
  static isObjectOrCollection (arg) {
    return (Validator.isObject(arg) || Validator.isKeyedCollection(arg))
  }

  /**
   * Tell if the given ergument is an object or a keyed collection, but not a string.
   *
   * See {@link Validator.isObjectOrCollection}.
   *
   * @static
   * @param {object} arg the object to check
   * @return {boolean} true if it&apos;s an object or a keyed collection but not a string, false otherwise
   */
  static isObjectOrCollectionNotString (arg) {
    return (Validator.isObjectOrCollection(arg) &amp;&amp; (typeof arg !== &apos;string&apos;))
  }

  /**
   * Tell if the given ergument is a string representation of a version number.
   *
   * Note that the version string could be something like:
   * - as minimum a number is needed for an integer version
   * - at the beginning I can have an optional char &apos;v&apos; or &apos;V&apos;
   * - anything after the third number will be considered as a string
   * - format updated to handle version output of &apos;git describe&apos;
   *
   * @static
   * @param {string} arg the version string to check
   * @return {boolean} true if it&apos;s a version string, false otherwise
   */
  static isVersion (arg) {
    // quick check if the given string is in the format &apos;n.n.n&apos;
    const versionRegex = /^(?:v|V?)((\d+)(?:\.?)){1,3}(?:\W|_?)(.*)$/gm
    return (Validator.isStringNotEmpty(arg) &amp;&amp; versionRegex.test(arg))
  }

  /**
   * Tell if the given ergument is an URI or an URL.
   *
   * @static
   * @param {string} arg the uri/url to check
   * @param {string} base the (optional) base to build the full URL
   * @return {boolean} true if it&apos;s an URI/URL, false otherwise
   */
  static isURI (arg, base) {
    // quick check if the given string is an URI or an URL
    if (!Validator.isStringNotEmpty(arg)) {
      return false
    }
    // simple check if it&apos;s an URL, trying to instancing it
    // note that this requires to import related module here (but not in Browsers) ...
    if (Validator.isStringNotEmpty(base)) {
      try {
        const u = new url.URL(arg, base)
        return (u !== null)
      } catch (e) {
        // console.error(e)
        return false
      }
    } else {
      // simple check if it&apos;s an URI (or better, a relative URL)
      if (arg.startsWith(&apos;/&apos;)) {
        return true
      }
      try {
        // return (new URL(arg) !== null)
        const u = new url.URL(arg)
        return (u !== null)
      } catch (e) {
        // console.error(e)
        return false
      }
    }
  }

  /**
   * Ensure that the given ergument is an instance of the given class reference.
   *
   * @static
   * @param {object} arg the object to check
   * @param {object} classReference the class that should be implemented/extended
   * @param {string} name the name to use in generated error (if any)
   * @return {TypeError} if it&apos;s not an instance (or extends) that class, nothing otherwise
   */
  static ensureIsClass (arg, classReference, name) {
    if (!Validator.isClass(arg, classReference)) {
      return new TypeError(`The argument &apos;${name}&apos; must be an instance of the given class reference, instead got a &apos;${typeof arg}&apos;`)
    }
  }

  /**
   * Ensure that the given ergument is a function.
   *
   * @static
   * @param {object} arg the object to check
   * @param {string} name the name to use in generated error (if any)
   * @return {TypeError} if it&apos;s not an instance (or extends) that class, nothing otherwise
   */
  static ensureIsFunction (arg, name) {
    if (!Validator.isFunction(arg)) {
      return new TypeError(`The argument &apos;${name}&apos; must be a function, instead got a &apos;${typeof arg}&apos;`)
    }
  }

  /**
   * Ensure that the given argument ia a string.
   *
   * See {@link Validator.isString}.
   *
   * @static
   * @param {object} arg the object to check
   * @param {string} name the name to use in generated error (if any)
   * @return {TypeError} if it&apos;s not a string, nothing otherwise
   */
  static ensureIsString (arg, name) {
    if (!Validator.isString(arg)) {
      return new TypeError(`The argument &apos;${name}&apos; must be a string, instead got a &apos;${typeof arg}&apos;`)
    }
  }

  /**
   * Ensure that the given argument ia a not empty string.
   *
   * See {@link Validator.isStringNotEmpty}.
   *
   * @static
   * @param {object} arg the object to check
   * @param {string} name the name to use in generated error (if any)
   * @return {Error} if it&apos;s not a not empty string, nothing otherwise
   */
  static ensureIsStringNotEmpty (arg, name) {
    if (!Validator.isStringNotEmpty(arg)) {
      return new Error(`The string &apos;${name}&apos; must be not empty`)
    }
  }

  /**
   * Ensure that the given argument ia an object or a collection.
   *
   * See {@link Validator.isObjectOrCollection}.
   *
   * @static
   * @param {object} arg the object to check
   * @param {string} name the name to use in generated error (if any)
   * @return {TypeError} if it&apos;s not an object nor a collection, nothing otherwise
   */
  static ensureIsObjectOrCollection (arg, name) {
    if (!Validator.isObjectOrCollection(arg)) {
      return new TypeError(`The object &apos;${name}&apos; must be an object or a collection`)
    }
  }

  /**
   * Ensure that the given argument ia an object or a collection, not a string.
   *
   * See {@link Validator.isObjectOrCollectionNotString}.
   *
   * @static
   * @param {object} arg the object to check
   * @param {string} name the name to use in generated error (if any)
   * @return {TypeError} if it&apos;s not an object nor a collection, nothing otherwise
   */
  static ensureIsObjectOrCollectionNotString (arg, name) {
    if (!Validator.isObjectOrCollectionNotString(arg)) {
      return new TypeError(`The object &apos;${name}&apos; must be an object or a collection, and not a string`)
    }
  }

  /**
   * Ensure that the given argument ia a date.
   *
   * See {@link Validator.isDate}.
   *
   * @static
   * @param {object} arg the object to check
   * @param {string} name the name to use in generated error (if any)
   * @return {Error} if it&apos;s not a date, nothing otherwise
   */
  static ensureIsDate (arg, name) {
    if (!Validator.isDate(arg)) {
      return new Error(`The object &apos;${name}&apos; must be a Date`)
    }
  }

  /**
   * Ensure that the given argument ia a date in the past.
   *
   * See {@link Validator.isDatePast}.
   *
   * @static
   * @param {object} arg the object to check
   * @param {string} name the name to use in generated error (if any)
   * @return {Error} if it&apos;s not a date in the past, nothing otherwise
   */
  static ensureIsDatePast (arg, name) {
    if (!Validator.isDatePast(arg)) {
      return new Error(`The object &apos;${name}&apos; must be a Date that belongs to the past`)
    }
  }

  /**
   * Ensure that the given argument ia a string version.
   *
   * See {@link Validator.isVersion}.
   *
   * @static
   * @param {object} arg the object to check
   * @param {string} name the name to use in generated error (if any)
   * @return {Error} if it&apos;s not a string version, nothing otherwise
   */
  static ensureIsVersion (arg, name) {
    if (!Validator.isVersion(arg)) {
      return new Error(`The object &apos;${name}&apos; must be a string in the format &apos;n.n.n&apos;, and not &apos;${arg}&apos;`)
    }
  }

  /**
   * Ensure that the given argument ia an URI/URL.
   *
   * See {@link Validator.isURI}.
   *
   * @static
   * @param {object} arg the object to check
   * @param {string} name the name to use in generated error (if any)
   * @return {Error} if it&apos;s not an URI/URL, nothing otherwise
   */
  static ensureIsURI (arg, name) {
    if (!Validator.isURI(arg)) {
      return new Error(`The object &apos;${name}&apos; must be an URI or URL string, and not &apos;${arg}&apos;`)
    }
  }

  /**
   * Tell the size of the given aobject
   *
   * @static
   * @param {object} arg the object to check
   * @return {number} the size if it&apos;s an array|Map|Set|object|string, nothing otherwise
   */
  static getSize (arg) {
    if ((arg === undefined || arg === null)) {
      return
    }
    if (Array.isArray(arg)) {
      return arg.length
    } else if (arg instanceof Map || arg instanceof Set) {
      return arg.size
    } else if (typeof arg === &apos;object&apos;) {
      return Object.keys(arg).length
    } else if (typeof arg === &apos;string&apos;) {
      return arg.length
    }
  }
}

module.exports = Validator
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>

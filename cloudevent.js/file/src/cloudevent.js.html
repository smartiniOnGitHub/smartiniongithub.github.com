<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">src/cloudevent.js | cloudevent.js</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="JavaScript/Node.js implementation of the CloudEvents standard format"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="cloudevent.js"><meta property="twitter:description" content="JavaScript/Node.js implementation of the CloudEvents standard format"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  <a href="test.html" data-ice="testLink">Test</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/smartiniOnGitHub/cloudevent.js"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/cloudevent.js~CloudEvent.html">CloudEvent</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/validator.js~Validator.html">Validator</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/cloudevent.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">/*
 * Copyright 2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
&apos;use strict&apos;

/**
 * CloudEvent:
 * this module exports some useful definition and utility related to CloudEvents.
 */

/**
 * Get a reference to cloudevent validator class.
 */
const V = require(&apos;./validator&apos;) // get validator from here

/**
 * CloudEvent implementation.
 *
 * @see https://github.com/cloudevents/spec/blob/master/json-format.md
 */
class CloudEvent {
  /**
   * Create a new instance of a CloudEvent object.
   * @param {!string} eventID the ID of the event (unique), mandatory
   * @param {!string} eventType the type of the event (usually), mandatory
   * @param {!uri} source the source uri of the event (use &apos;/&apos; if empty), mandatory
   * @param {(object|Map|Set)} data the real event data
   * @param {object} options optional attributes of the event; some has default values chosen here:
   *        eventTypeVersion (string) optional,
   *        eventTime (timestamp, default now),
   *        extensions (object) optional but if given must contain at least 1 property (key/value),
   *        contentType (string, default &apos;application/json&apos;) tell how the data attribute must be encoded,
   *        schemaURL (uri) optional,
   *        strict (boolean, default false) tell if object instance will be validated in a more strict way
   * @throws {Error} if strict is true and eventID or eventType is undefined or null
   */
  constructor (eventID, eventType, source, data, {
    eventTypeVersion,
    eventTime = new Date(),
    extensions,
    contentType = &apos;application/json&apos;,
    schemaURL,
    strict = false } = {}
  ) {
    if (strict === true) {
      if (!eventID || !eventType || !source) {
        throw new Error(&apos;Unable to create CloudEvent instance, mandatory field missing&apos;)
      }
    }

    /**
     * The event ID.
     * @type {string}
     * @private
     */
    this.eventID = eventID
    /**
     * The event type.
     * @type {string}
     * @private
     */
    this.eventType = eventType
    /**
     * The source URI of the event.
     * @type {uri}
     * @private
     */
    this.source = source
    /**
     * The real event data.
     * Usually it&apos;s an object, but could be even a Map or a Set.
     * Copy the original object to avoid changing objects that could be shared.
     * @type {(object|Map|Set)}
     * @private
     */
    // this.data = { ...data }
    this.data = { data } // temp
    if (V.isString(data)) {
      // handle an edge case: if the given data is a String, I need to clone in a different way ...
      this.data = data.slice()
    }

    /**
     * The CloudEvent specification version.
     * @type {string}
     * @private
     */
    this.cloudEventsVersion = this.constructor.version()
    /**
     * The MIME Type for the encoding of the data attribute, when serialized.
     * @type {string}
     * @private
     */
    this.contentType = contentType
    /**
     * The event timestamp.
     * Copy the original object to avoid changing objects that could be shared.
     * @type {timestamp}
     * @private
     */
    this.eventTime = new Date(eventTime.valueOf())
    /**
     * The event version.
     * @type {string}
     * @private
     */
    this.eventTypeVersion = eventTypeVersion
    /**
     * Extensions defined for the event.
     * Copy the original object to avoid changing objects that could be shared.
     * @type {object}
     * @private
     */
    // this.extensions = { ...extensions }
    this.extensions = { extensions } // temp
    /**
     * The URL of schema for the event, if any.
     * @type {uri}
     * @private
     */
    this.schemaURL = schemaURL

    // add strict to extensions, but only when defined
    if (strict === true) {
      this.extensions = this.extensions || {}
      this.extensions.strict = strict
    }
  }

  /**
   * Utility function that return a dump of the given object.
   *
   * @static
   * @param {(object|Map|Set)} obj the object to dump
   * @param {string} name the name to assign in the returned string
   * @return {string} the dump of the object or a message when obj is undefined/null/not an object
   */
  static dumpObject (obj, name) {
    const n = name || &apos;noname&apos;
    if (V.isUndefined(obj)) {
      return `${n}: undefined`
    } else if (V.isNull(obj)) {
      return `${n}: null`
    } else if (!V.isObjectOrCollection(obj)) {
      return `${n}: &apos;${obj.toString()}&apos;`
    } else {
      return `${n}: ${JSON.stringify(obj)}`
    }
  }

  /**
   * Return the version of the CloudEvent Specification implemented here
   *
   * @static
   * @return {string} the value
   */
  static version () {
    return &apos;0.1&apos;
  }

  /**
   * Return the MIME Type for a CloudEvent
   *
   * @static
   * @return {string} the value
   */
  static mediaType () {
    return &apos;application/cloudevents+json&apos;
  }

  /**
   * Tell if the object has the strict flag enabled.
   *
   * @static
   * @param {!object} event the CloudEvent to validate
   * @return {boolean} true if strict, otherwise false
   * @throws {Error} if event if undefined or null
   */
  static isStrictEvent (event) {
    if (V.isUndefinedOrNull(event)) {
      throw new Error(&apos;CloudEvent undefined or null&apos;)
    }
    if (V.isDefinedAndNotNull(event.extensions)) {
      return event.extensions.strict === true
    } else {
      return false
    }
  }

  /**
   * Validate the given CloudEvent.
   *
   * @static
   * @param {!object} event the CloudEvent to validate
   * @param {object} options containing: strict (boolean, default false) to validate it in a more strict way
   * @return {object[]} an array of (non null) validation errors, or at least an empty array
   */
  static validateEvent (event, { strict = false } = {}) {
    if (V.isUndefinedOrNull(event)) {
      return [new Error(&apos;CloudEvent undefined or null&apos;)]
    }
    let ve = [] // validation errors

    // standard validation
    // note that some properties are not checked here because I assign a default value, and I check them in strict mode, like:
    // data, eventTime, extensions, contentType ...
    // ve.push(V.ensureIsStringNotEmpty(event.cloudEventsVersion, &apos;cloudEventsVersion&apos;)) // no more a public attribute
    ve.push(V.ensureIsStringNotEmpty(event.eventID, &apos;eventID&apos;))
    ve.push(V.ensureIsStringNotEmpty(event.eventType, &apos;eventType&apos;))
    ve.push(V.ensureIsStringNotEmpty(event.source, &apos;source&apos;))
    if (V.isDefinedAndNotNull(event.eventTypeVersion)) {
      ve.push(V.ensureIsStringNotEmpty(event.eventTypeVersion, &apos;eventTypeVersion&apos;))
    }
    if (V.isDefinedAndNotNull(event.schemaURL)) {
      ve.push(V.ensureIsStringNotEmpty(event.schemaURL, &apos;schemaURL&apos;))
    }

    // additional validation if strict mode enabled, or if enabled in the event ...
    if (strict === true || CloudEvent.isStrictEvent(event) === true) {
      ve.push(V.ensureIsClass(event, CloudEvent, &apos;CloudEvent_Subclass&apos;))
      ve.push(V.ensureIsVersion(event.cloudEventsVersion, &apos;cloudEventsVersion&apos;))
      if (V.isDefinedAndNotNull(event.data)) {
        ve.push(V.ensureIsObjectOrCollectionNotString(event.data, &apos;data&apos;))
      }
      if (V.isDefinedAndNotNull(event.eventTypeVersion)) {
        ve.push(V.ensureIsVersion(event.eventTypeVersion, &apos;eventTypeVersion&apos;))
      }
      ve.push(V.ensureIsURI(event.source, &apos;source&apos;))
      if (V.isDefinedAndNotNull(event.extensions)) {
        ve.push(V.ensureIsObjectOrCollectionNotString(event.extensions, &apos;extensions&apos;))
        const extensionsSize = V.getSize(event.extensions)
        if (extensionsSize &lt; 1) {
          ve.push(new Error(`The object &apos;extensions&apos; must contain at least 1 property`))
        }
      }
      ve.push(V.ensureIsDatePast(event.eventTime, &apos;eventTime&apos;))
      ve.push(V.ensureIsStringNotEmpty(event.contentType, &apos;contentType&apos;))
      ve.push(V.ensureIsURI(event.schemaURL, &apos;schemaURL&apos;))
    }

    return ve.filter((i) =&gt; i)
  }

  /**
   * Tell the given CloudEvent, if it&apos;s valid.
   *
   * See {@link CloudEvent.validateEvent}.
   *
   * @static
   * @param {!object} event the CloudEvent to validate
   * @param {object} options containing: strict (boolean, default false) to validate it in a more strict way
   * @return {boolean} true if valid, otherwise false
   */
  static isValidEvent (event, { strict = false } = {}) {
    const validationErrors = CloudEvent.validateEvent(event, { strict })
    const size = V.getSize(validationErrors)
    return (size === 0)
  }

  /**
   * Serialize the given CloudEvent in JSON format.
   * Note that here standard serialization to JSON is used (no additional libraries).
   *
   * @param {!object} event the CloudEvent to serialize
   * @return {string} the serialized event, as a string
   */
  static serializeEvent (event) {
    if (V.isUndefinedOrNull(event)) {
      throw new Error(&apos;CloudEvent undefined or null&apos;)
    }
    if (event.contentType !== &apos;application/json&apos;) {
      throw new Error(`Unsupported content type: &apos;${event.contentType}&apos;. Not yet implemented.`)
    }

    const serialized = JSON.stringify(event)
    return serialized
  }

  /**
   * Serialize the current CloudEvent.
   *
   * See {@link CloudEvent.serializeeEvent}.
   *
   * @return {string} the serialized event, as a string
   */
  serialize () {
    return this.constructor.serializeEvent(this)
  }

  /**
   * Validate the current CloudEvent.
   *
   * See {@link CloudEvent.validateEvent}.
   *
   * @param {object} options containing: strict (boolean, default false) to validate it in a more strict way
   * @return {object[]} an array of (non null) validation errors, or at least an empty array
   */
  validate ({ strict = false } = {}) {
    return this.constructor.validateEvent(this, { strict })
  }

  /**
   * Tell the current CloudEvent, if it&apos;s valid.
   *
   * See {@link CloudEvent.isValidEvent}.
   *
   * @param {object} options containing: strict (boolean, default false) to validate it in a more strict way
   * @return {boolean} true if valid, otherwise false
   */
  isValid ({ strict = false } = {}) {
    return this.constructor.isValidEvent(this, { strict })
  }

  /**
   * Getter method to tell if the object has the strict flag enabled.
   *
   * See {@link CloudEvent.isStrictEvent}.
   *
   * @type {boolean}
   */
  get isStrict () {
    return this.constructor.isStrictEvent(this)
  }

  /**
   * Getter method to return JSON Schema for a CloudEvent.
   *
   * See JSON Schema.
   *
   * @type {object}
   */
  get schema () {
    // define a schema for serializing a CloudEvent object to JSON
    // note that properties not in the schema will be ignored
    // (in json output) by some json serialization libraries, if additionalProperties is false
    return {
      title: &apos;CloudEvent Schema with required fields&apos;,
      type: &apos;object&apos;,
      properties: {
        cloudEventsVersion: { type: &apos;string&apos; },
        eventID: { type: &apos;string&apos; },
        eventType: { type: &apos;string&apos; },
        // data: { type: &apos;object&apos; },
        eventTypeVersion: { type: &apos;string&apos; },
        source: { type: &apos;string&apos; },
        eventTime: { type: &apos;string&apos; },
        // extensions: { type: &apos;object&apos; },
        contentType: { type: &apos;string&apos; },
        // TODO: use if/then/else on contentType ... wip
        schemaURL: { type: &apos;string&apos; }
      },
      required: [&apos;cloudEventsVersion&apos;, &apos;eventID&apos;, &apos;eventType&apos;,
        &apos;source&apos;, &apos;contentType&apos;
      ],
      additionalProperties: true // to handle data, extensions, and maybe other (non-standard) properties
    }
  }

  /**
   * Override the usual toString method.
   *
   * See {@link Object.toString}.
   *
   * @return {string} a string representation for object instance
   */
  toString () {
    return `CloudEvent[cloudEventsVersion: ${this.cloudEventsVersion}, ${this.constructor.dumpObject(this.eventID, &apos;eventID&apos;)}, ${this.constructor.dumpObject(this.eventType, &apos;eventType&apos;)}, ${this.constructor.dumpObject(this.data, &apos;data&apos;)}, ...]`
  }

  /**
   * Gives a string valued property that is used in the creation of the default string description of an object.
   *
   * See {@link Symbol.toStringTag}.
   *
   * @return {string} a string representation of the object type
   */
  get [Symbol.toStringTag] () {
    return &apos;CloudEvent&apos;
  }
}

module.exports = CloudEvent
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
